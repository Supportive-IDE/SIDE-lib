(function(U,E){typeof exports=="object"&&typeof module<"u"?E(exports):typeof define=="function"&&define.amd?define(["exports"],E):(U=typeof globalThis<"u"?globalThis:U||self,E(U["side-lib"]={}))})(this,function(U){"use strict";var yd=Object.defineProperty;var Fd=Object.getPrototypeOf;var Td=Reflect.get;var Gr=U=>{throw TypeError(U)};var Nd=(U,E,B)=>E in U?yd(U,E,{enumerable:!0,configurable:!0,writable:!0,value:B}):U[E]=B;var l=(U,E,B)=>Nd(U,typeof E!="symbol"?E+"":E,B),Mi=(U,E,B)=>E.has(U)||Gr("Cannot "+B);var c=(U,E,B)=>(Mi(U,E,"read from private field"),B?B.call(U):E.get(U)),I=(U,E,B)=>E.has(U)?Gr("Cannot add the same private member more than once"):E instanceof WeakSet?E.add(U):E.set(U,B),y=(U,E,B,a)=>(Mi(U,E,"write to private field"),a?a.call(U,B):E.set(U,B),B),m=(U,E,B)=>(Mi(U,E,"access private method"),B);var Ys=(U,E,B,a)=>({set _(t){y(U,E,t,B)},get _(){return c(U,E,a)}}),xi=(U,E,B)=>Td(Fd(U),B,E);var xt,Dt,Bt,At,kt,_t,en,tn,nn,Pt,Ve,ct,st,sn,Jn,Kn,De,$r,Di,Jr,Kr,Wr,ut,Fe,rn,Wn,dt,qr,_s,qn,jn,on,it,Lt,an,ht,ft,ve,gt,ae,Hn,Q,W,jr,Hr,zr,Qr,Bi,Ai,ki,Xr,Pi,Li,Vi,Cs,yi,Fi,ln,Ti,zn,Us,Zr,Qn,vi,q,tt,Os,Yr,_r,eo,to,no,Ri,ee,Vt,Xn,cn,qe,Te,G,vt,Zn,Be,Re,ge,pt,Ni,N,so,io,Ui,ro,jt,ze,xe,oo,ao,Ei,Gi,lo,$i,co,uo,ho,fo,go,po,mo,wo,vn,So,Cd,Io,bo,yo,Fo,To,No,Co,Oo,Mo,xo,x,Ji,Do,Bo,Ao,ko,Po,Lo,Vo,vo,Ki,Ro,Uo,Eo,Go,fe,$o,Jo,Ko,Wi,Wo,qi,qo,ji,jo,Ho,zo,Qo,Hi,Xo,mt,wt,St,rt,un,dn,hn,_n,fn,Se,Rt,gn,es,Ae,Gs,Zo,pe,ts,pn,Yo,mn,_o,ea,ta,ss,ue,Ne,na,sa,ei,ia,ra,Js,oa,de,Ce,aa,la,ti,ca,ua,wn,da,ha,Ks,fa,Xe,Ie,Sn,ga,pa,Ws,ma,qs,wa,Ze,In,Sa,Ia,js,ba,It,bt,is,rs,os,re,ni,ya,Fa,Ta,Na,Ca,Oa,zi,as,Ye,ls,Qi,bn,Hs,Ma,te,zs,xa,le,yn,Da,Ba,X,we,_,Aa,ka,Pa,Xi,La,Zi,Yi,Va,va,Ra,Ue,ke,Fn,ot,Ee,Ua,Ea,Ga,$a,Ja,ne,Tn,Ka,Wa,Oe,at,Nn,qa,ja,cs,_i,Ge,Ha,_e,er,tr,za,Qa,Xa,Za,Ya,$e,_a,ds,nr,el,tl,nl,sl,je,il,fs,sr,rl,ol,Od,al,Cn,he,se,be,ll,cl,ul,ir,dl,hl,ps,ms,ws,rr,Qs,fl,On,gl,pl,Je,ml,wl,Sl,Il,bl,Xs,Mn,xn,Et,me,Is,bs,Pe,Le,or,yl,Fl,Tl,Nl,yt,Cl,Ol,Ml,j,et,ar,xl,Md,Dl,Dn,ys,$t,Bn,An,kn,Pn,Fs,Jt,Ke,Ft,Ts,Kt,Wt,Ln,Zs,Bl,Tt,Vn,He,Al,lr,kl,Pl,Ns,Me,ye,v,Ll,Ht,Vl,vl,Rl,Ul,El,Gl,$l,Jl,Kl,Wl,cr,ur,ql,jl,Hl,zl,Ql,Xl,Rn;class E{constructor(i){this.name=i}}const C=class C extends E{static getCategory(i){return i>=65&&i<=90||i>=97&&i<=122?C.Letter:i>=48&&i<=57?C.Digit:i===46?C.Decimal:i===95?C.Underscore:i===32?C.Space:i===9?C.Tab:i===10||i===13?C.NewLine:i===40?C.OpenParentheses:i===41?C.CloseParentheses:i===123?C.OpenCurlyBrace:i===125?C.CloseCurlyBrace:i===91?C.OpenSquareBracket:i===93?C.CloseSquareBracket:i===44?C.Comma:i===58?C.Colon:i===59?C.Semicolon:i===43?C.Plus:i===45?C.Minus:i===42?C.Asterisk:i===37?C.Modulo:i===61?C.Equals:i===60?C.LessThan:i===62?C.GreaterThan:i===33?C.Exclamation:i===47?C.ForwardSlash:i===92?C.BackSlash:i===35?C.Hash:i===39?C.SingleQuote:i===34?C.DoubleQuote:C.Unknown}isQuote(){return this===C.SingleQuote||this===C.DoubleQuote}};l(C,"Letter",new C("letter")),l(C,"Digit",new C("digit")),l(C,"Decimal",new C("decimal")),l(C,"Underscore",new C("underscore")),l(C,"Space",new C("space")),l(C,"Tab",new C("tab")),l(C,"NewLine",new C("newline")),l(C,"OpenParentheses",new C("openParentheses")),l(C,"CloseParentheses",new C("closeParentheses")),l(C,"OpenCurlyBrace",new C("openCurlyBrace")),l(C,"CloseCurlyBrace",new C("closeCurlyBrace")),l(C,"OpenSquareBracket",new C("openSquareBracket")),l(C,"CloseSquareBracket",new C("closeSquareBracket")),l(C,"Comma",new C("comma")),l(C,"Colon",new C("colon")),l(C,"Semicolon",new C("semicolon")),l(C,"Plus",new C("plus")),l(C,"Minus",new C("minus")),l(C,"Asterisk",new C("asterisk")),l(C,"Modulo",new C("modulo")),l(C,"Equals",new C("equals")),l(C,"LessThan",new C("lessThan")),l(C,"GreaterThan",new C("greaterThan")),l(C,"Exclamation",new C("exclamation")),l(C,"ForwardSlash",new C("forwardSlash")),l(C,"BackSlash",new C("backSlash")),l(C,"Hash",new C("hash")),l(C,"SingleQuote",new C("singleQuote")),l(C,"DoubleQuote",new C("doubleQuote")),l(C,"Unknown",new C("unknown"));let B=C;const A=class A extends E{};l(A,"BlockDefinitions",new A("BlockDefinitions")),l(A,"LogicalOperators",new A("LogicalOperators")),l(A,"Types",new A("Types")),l(A,"MathsOperators",new A("MathsOperators")),l(A,"ComparisonOperators",new A("ComparisonOperators")),l(A,"OtherKeywords",new A("OtherKeywords")),l(A,"BuiltInFunctions",new A("BuiltInFunctions")),l(A,"BuiltInMethods",new A("BuiltInMethods")),l(A,"OtherMethods",new A("OtherMethods")),l(A,"Identifiers",new A("Identifiers")),l(A,"MagicMethods",new A("MagicMethods")),l(A,"SpecialVariables",new A("SpecialVariables")),l(A,"Properties",new A("Properties")),l(A,"BuiltInExceptions",new A("BuiltInExceptions")),l(A,"Literals",new A("Literals")),l(A,"CompoundTypes",new A("CompoundTypes")),l(A,"Other",new A("Other")),l(A,"Comment",new A("Comment")),l(A,"Unknown",new A("Unknown")),l(A,"BuiltInModules",new A("BuiltInModules")),l(A,"ModuleFunctions",new A("ModuleFunctions")),l(A,"ModuleProperties",new A("ModuleProperties")),l(A,"ClassAttributes",new A("ClassAttributes")),l(A,"ImportedEntities",new A("ImportedEntities")),l(A,"TypeHint",new A("TypeHint")),l(A,"FunctionCall",new A("FunctionCall")),l(A,"MethodCall",new A("MethodCall")),l(A,"ExceptionCall",new A("ExceptionCall")),l(A,"BlockDefinitionStatement",new A("BlockDefinitionStatement")),l(A,"Group",new A("Group")),l(A,"MultipartValue",new A("MultipartValue")),l(A,"Assignment",new A("Assigment")),l(A,"KeywordStatement",new A("KeywordStatement"));let a=A;const r=class r extends E{};l(r,"ClassDefinition",new r("class")),l(r,"FunctionDefinition",new r("def")),l(r,"ElifDefinition",new r("elif")),l(r,"ElseDefinition",new r("else")),l(r,"ExceptDefinition",new r("except")),l(r,"FinallyDefinition",new r("finally")),l(r,"ForDefinition",new r("for")),l(r,"IfDefinition",new r("if")),l(r,"LambdaDefinition",new r("lambda")),l(r,"TryDefinition",new r("try")),l(r,"WhileDefinition",new r("while")),l(r,"DocumentDefinition",new r("document")),l(r,"ListComprehension",new r("listComprehension")),l(r,"AndOperator",new r("and")),l(r,"NotOperator",new r("not")),l(r,"OrOperator",new r("or")),l(r,"FalseType",new r("False")),l(r,"NoneType",new r("None")),l(r,"TrueType",new r("True")),l(r,"AsKeyword",new r("AsKeyword")),l(r,"AssertKeyword",new r("AssertKeyword")),l(r,"BreakKeyword",new r("BreakKeyword")),l(r,"ContinueKeyword",new r("continue")),l(r,"DelKeyword",new r("del")),l(r,"FromKeyword",new r("from")),l(r,"ImportKeyword",new r("import")),l(r,"InKeyword",new r("in")),l(r,"IsKeyword",new r("is")),l(r,"NotInKeyword",new r("not in")),l(r,"IsNotKeyword",new r("is not")),l(r,"PassKeyword",new r("pass")),l(r,"RaiseKeyword",new r("raise")),l(r,"ReturnKeyword",new r("return")),l(r,"WithKeyword",new r("with")),l(r,"YieldKeyword",new r("yield")),l(r,"GlobalKeyword",new r("global")),l(r,"AddOperator",new r("+")),l(r,"SubtractOperator",new r("-")),l(r,"MultiplyOperator",new r("*")),l(r,"DivideOperator",new r("/")),l(r,"ModulusOperator",new r("%")),l(r,"ExponentOperator",new r("**")),l(r,"IntDivideOperator",new r("//")),l(r,"AssignmentOperator",new r("=")),l(r,"IncrementOperator",new r("+=")),l(r,"DecrementOperator",new r("-=")),l(r,"MultiplyAssignOperator",new r("*=")),l(r,"DivideAssignOperator",new r("/=")),l(r,"RemainderAssignOperator",new r("%=")),l(r,"IntDivideAssignOperator",new r("//=")),l(r,"ExponentAssignOperator",new r("**=")),l(r,"EqualOperator",new r("==")),l(r,"NotEqualOperator",new r("!=")),l(r,"GreaterThanOperator",new r(">")),l(r,"LessThanOperator",new r("<")),l(r,"GreaterThanOrEqualOperator",new r(">=")),l(r,"LessThanOrEqualOperator",new r("<=")),l(r,"TypeHintReturn",new r("->")),l(r,"AbsFunction",new r("abs")),l(r,"AllFunction",new r("all")),l(r,"AnyFunction",new r("any")),l(r,"AsciiFunction",new r("ascii")),l(r,"AssertFunction",new r("assert")),l(r,"BinFunction",new r("bin")),l(r,"BoolFunction",new r("bool")),l(r,"CallableFunction",new r("callable")),l(r,"ChrFunction",new r("chr")),l(r,"DictFunction",new r("dict")),l(r,"DivModFunction",new r("divmod")),l(r,"EnumerateFunction",new r("enumerate")),l(r,"EvalFunction",new r("eval")),l(r,"ExecFunction",new r("exec")),l(r,"ExitFunction",new r("exit")),l(r,"FilterFunction",new r("filter")),l(r,"FloatFunction",new r("float")),l(r,"FormatFunction",new r("format")),l(r,"GetAttrFunction",new r("getattr")),l(r,"GlobalsFunction",new r("globals")),l(r,"HasAttrFunction",new r("hasattr")),l(r,"InputFunction",new r("input")),l(r,"IntFunction",new r("int")),l(r,"IsInstanceFunction",new r("isinstance")),l(r,"LenFunction",new r("len")),l(r,"ListFunction",new r("list")),l(r,"MapFunction",new r("map")),l(r,"MaxFunction",new r("max")),l(r,"MinFunction",new r("min")),l(r,"OpenFunction",new r("open")),l(r,"OrdFunction",new r("ord")),l(r,"PowFunction",new r("pow")),l(r,"PrintFunction",new r("print")),l(r,"QuitFunction",new r("quit")),l(r,"RangeFunction",new r("range")),l(r,"ReversedFunction",new r("reversed")),l(r,"RoundFunction",new r("round")),l(r,"SetFunction",new r("set")),l(r,"SortedFunction",new r("sorted")),l(r,"StrFunction",new r("str")),l(r,"SumFunction",new r("sum")),l(r,"TupleFunction",new r("tuple")),l(r,"TypeFunction",new r("type")),l(r,"ZipFunction",new r("zip")),l(r,"Capitalize",new r("capitalize")),l(r,"Casefold",new r("casefold")),l(r,"Center",new r("center")),l(r,"Count",new r("count")),l(r,"Encode",new r("encode")),l(r,"EndsWith",new r("endswith")),l(r,"ExpandTabs",new r("expandtabs")),l(r,"Find",new r("find")),l(r,"Format",new r("format")),l(r,"FormatMap",new r("format_map")),l(r,"Index",new r("index")),l(r,"IsAlnum",new r("isalnum")),l(r,"IsAlpha",new r("isalpha")),l(r,"IsAscii",new r("isascii")),l(r,"IsDecimal",new r("isdecimal")),l(r,"IsDigit",new r("isdigit")),l(r,"IsIdentifier",new r("isidentifier")),l(r,"IsLower",new r("islower")),l(r,"IsNumeric",new r("isnumeric")),l(r,"IsPrintable",new r("isprintable")),l(r,"IsSpace",new r("isspace")),l(r,"IsTitle",new r("istitle")),l(r,"IsUpper",new r("isupper")),l(r,"Join",new r("join")),l(r,"LJust",new r("ljust")),l(r,"Lower",new r("lower")),l(r,"LStrip",new r("lstrip")),l(r,"MakeTrans",new r("maketrans")),l(r,"Partition",new r("partition")),l(r,"Replace",new r("replace")),l(r,"RFind",new r("rfind")),l(r,"RIndex",new r("rindex")),l(r,"RJust",new r("rjust")),l(r,"RPartition",new r("rpartition")),l(r,"RSplit",new r("rsplit")),l(r,"RStrip",new r("rstrip")),l(r,"Split",new r("split")),l(r,"SplitLines",new r("splitlines")),l(r,"StartsWith",new r("startswith")),l(r,"Strip",new r("strip")),l(r,"SwapCase",new r("swapcase")),l(r,"Title",new r("title")),l(r,"Translate",new r("translate")),l(r,"Upper",new r("upper")),l(r,"ZFill",new r("zfill")),l(r,"Append",new r("append")),l(r,"Clear",new r("clear")),l(r,"Copy",new r("copy")),l(r,"Extend",new r("extend")),l(r,"Insert",new r("insert")),l(r,"Pop",new r("pop")),l(r,"Remove",new r("remove")),l(r,"Reverse",new r("reverse")),l(r,"Sort",new r("sort")),l(r,"FromKeys",new r("fromkeys")),l(r,"Get",new r("get")),l(r,"Items",new r("items")),l(r,"Keys",new r("keys")),l(r,"PopItem",new r("popitem")),l(r,"SetDefault",new r("setdefault")),l(r,"Update",new r("update")),l(r,"Values",new r("values")),l(r,"Add",new r("add")),l(r,"Difference",new r("difference")),l(r,"DifferenceUpdate",new r("difference_update")),l(r,"Discard",new r("discard")),l(r,"Intersection",new r("intersection")),l(r,"IntersectionUpdate",new r("intersection_update")),l(r,"IsDisjoint",new r("isdisjoint")),l(r,"IsSubset",new r("issubset")),l(r,"IsSuperset",new r("issuperset")),l(r,"SymmetricDifference",new r("symmetric_difference")),l(r,"SymmetricDifferenceUpdate",new r("symmetric_difference_update")),l(r,"Union",new r("union")),l(r,"Close",new r("close")),l(r,"Detach",new r("detach")),l(r,"FileNo",new r("fileno")),l(r,"Flush",new r("flush")),l(r,"IsAtty",new r("isatty")),l(r,"Read",new r("read")),l(r,"Readable",new r("readable")),l(r,"ReadLine",new r("readline")),l(r,"ReadLines",new r("readlines")),l(r,"Seek",new r("seek")),l(r,"Seekable",new r("seekable")),l(r,"Tell",new r("tell")),l(r,"Truncate",new r("truncate")),l(r,"Writable",new r("writable")),l(r,"Write",new r("write")),l(r,"WriteLines",new r("writelines")),l(r,"Main",new r("__main__")),l(r,"Cmp",new r("__cmp__")),l(r,"Eq",new r("__eq__")),l(r,"Ne",new r("__ne__")),l(r,"Lt",new r("__lt__")),l(r,"Gt",new r("__gt__")),l(r,"Le",new r("__le__")),l(r,"Ge",new r("__ge__")),l(r,"Str",new r("__str__")),l(r,"SpecialContains",new r("__contains__")),l(r,"SpecialLen",new r("__len__")),l(r,"Name",new r("__name__")),l(r,"Self",new r("__self__")),l(r,"Doc",new r("__doc__")),l(r,"GetAttrVariable",new r("__getattr__")),l(r,"SetAttrVariable",new r("__setattr__")),l(r,"ClassVariable",new r("__class__")),l(r,"R",new r("r")),l(r,"F",new r("f")),l(r,"Sep",new r("sep")),l(r,"End",new r("end")),l(r,"Dot",new r(".")),l(r,"OpenParenthesis",new r("(")),l(r,"CloseParenthesis",new r(")")),l(r,"OpenSquareBracket",new r("[")),l(r,"CloseSquareBracket",new r("]")),l(r,"OpenBrace",new r("{")),l(r,"CloseBrace",new r("}")),l(r,"Comma",new r(",")),l(r,"Colon",new r(":")),l(r,"SingleQuote",new r("'")),l(r,"DoubleQuote",new r('"')),l(r,"MultiLineCommentDelimiter",new r("'''")),l(r,"ImportAll",new r("import all (*)")),l(r,"NamedImport",new r("named import")),l(r,"ExceptionName",new r("exceptionName")),l(r,"VariableName",new r("variableName")),l(r,"FunctionName",new r("functionName")),l(r,"MethodName",new r("methodName")),l(r,"ClassName",new r("className")),l(r,"PropertyName",new r("propertyName")),l(r,"ModuleName",new r("moduleName")),l(r,"IntLiteral",new r("intLiteral")),l(r,"StringLiteral",new r("stringLiteral")),l(r,"ContinuationLine",new r("continuationLine")),l(r,"Separator",new r("separator")),l(r,"FloatLiteral",new r("floatLiteral")),l(r,"SingleLineComment",new r("singleLineComment")),l(r,"MultiLineComment",new r("multilineComment")),l(r,"TypeHint",new r("typeHint")),l(r,"StrType",new r("strType")),l(r,"IntType",new r("intType")),l(r,"FloatType",new r("floatType")),l(r,"BoolType",new r("boolType")),l(r,"ListType",new r("listType")),l(r,"SetType",new r("setType")),l(r,"DictType",new r("dictType")),l(r,"TupleType",new r("tupleType")),l(r,"ListDefinition",new r("listDefinition")),l(r,"TupleDefinition",new r("tupleDefinition")),l(r,"SetDefinition",new r("setDefinition")),l(r,"DictDefinition",new r("dictDefinition")),l(r,"IndexKey",new r("indexKey")),l(r,"Slice",new r("slice")),l(r,"Unknown",new r("unknown")),l(r,"RandomModule",new r("randomModule")),l(r,"MathModule",new r("mathModule")),l(r,"StringModule",new r("stringModule")),l(r,"ReModule",new r("reModule")),l(r,"Pattern",new r("Pattern")),l(r,"Match",new r("Match")),l(r,"Sys",new r("sys")),l(r,"Seed",new r("seed")),l(r,"GetState",new r("getstate")),l(r,"SetState",new r("setstate")),l(r,"GetRandBits",new r("getrandbits")),l(r,"RandRange",new r("randrange")),l(r,"RandInt",new r("randint")),l(r,"Choice",new r("choice")),l(r,"Choices",new r("choices")),l(r,"Shuffle",new r("shuffle")),l(r,"Sample",new r("sample")),l(r,"RandomMethod",new r("random")),l(r,"Uniform",new r("uniform")),l(r,"Triangular",new r("triangular")),l(r,"BetaVariate",new r("betavariate")),l(r,"ExpoVariate",new r("expovariate")),l(r,"GammaVariate",new r("gammavariate")),l(r,"Gauss",new r("gauss")),l(r,"LogNormVariate",new r("lognormvariate")),l(r,"NormalVariate",new r("normalvariate")),l(r,"VonMisesVariate",new r("vonmisesvariate")),l(r,"ParetoVariate",new r("paretovariate")),l(r,"WeibullVariate",new r("weibullvariate")),l(r,"Acos",new r("acos")),l(r,"Acosh",new r("acosh")),l(r,"Asin",new r("asin")),l(r,"Asinh",new r("asinh")),l(r,"Atan",new r("atan")),l(r,"Atan2",new r("atan2")),l(r,"Atanh",new r("atanh")),l(r,"Ceil",new r("ceil")),l(r,"Comb",new r("comb")),l(r,"CopySign",new r("copysign")),l(r,"Cos",new r("cos")),l(r,"Cosh",new r("cosh")),l(r,"Degrees",new r("degrees")),l(r,"Dist",new r("dist")),l(r,"Erf",new r("erf")),l(r,"Erfc",new r("erfc")),l(r,"Exp",new r("exp")),l(r,"Expm1",new r("expm1")),l(r,"Fabs",new r("fabs")),l(r,"Factorial",new r("factorial")),l(r,"Floor",new r("floor")),l(r,"Fmod",new r("fmod")),l(r,"Frexp",new r("frexp")),l(r,"Fsum",new r("fsum")),l(r,"Gamma",new r("gamma")),l(r,"Gcd",new r("gcd")),l(r,"Hypot",new r("hypot")),l(r,"IsClose",new r("isclose")),l(r,"IsFinite",new r("isfinite")),l(r,"IsInf",new r("isinf")),l(r,"IsNaN",new r("isnan")),l(r,"ISqrt",new r("isqrt")),l(r,"Ldexp",new r("ldexp")),l(r,"LGamma",new r("lgamma")),l(r,"Log",new r("log")),l(r,"Log10",new r("log10")),l(r,"Log1P",new r("log1p")),l(r,"Log2",new r("log2")),l(r,"Perm",new r("perm")),l(r,"Pow",new r("pow")),l(r,"Prod",new r("prod")),l(r,"Radians",new r("radians")),l(r,"Remainder",new r("remainder")),l(r,"Sin",new r("sin")),l(r,"Sinh",new r("sinh")),l(r,"Sqrt",new r("sqrt")),l(r,"Tan",new r("tan")),l(r,"Tanh",new r("tanh")),l(r,"Trunc",new r("trunc")),l(r,"E",new r("e")),l(r,"Inf",new r("inf")),l(r,"Nan",new r("nan")),l(r,"Pi",new r("pi")),l(r,"Tau",new r("tau")),l(r,"AsciiLetters",new r("ascii_letters")),l(r,"AsciiLowercase",new r("ascii_lowercase")),l(r,"AsciiUppercase",new r("ascii_uppercase")),l(r,"Digits",new r("digits")),l(r,"Hexdigits",new r("hexdigits")),l(r,"Octdigits",new r("octdigits")),l(r,"Punctuation",new r("punctuation")),l(r,"Printable",new r("printable")),l(r,"Whitespace",new r("whitespace")),l(r,"Formatter",new r("Formatter")),l(r,"Template",new r("Template")),l(r,"Capwords",new r("capwords")),l(r,"ReA",new r("A")),l(r,"ReASCII",new r("ASCII")),l(r,"ReDebug",new r("DEBUG")),l(r,"ReI",new r("I")),l(r,"ReIGNORECASE",new r("IGNORECASE")),l(r,"ReL",new r("L")),l(r,"ReLOCALE",new r("LOCALE")),l(r,"ReM",new r("M")),l(r,"ReMULTILINE",new r("MULTILINE")),l(r,"ReS",new r("S")),l(r,"ReDOTALL",new r("DOTALL")),l(r,"ReX",new r("X")),l(r,"ReVERBOSE",new r("VERBOSE")),l(r,"Compile",new r("compile")),l(r,"Search",new r("search")),l(r,"Match",new r("match")),l(r,"FullMatch",new r("fullmatch")),l(r,"FindAll",new r("findall")),l(r,"FindIter",new r("finditer")),l(r,"Sub",new r("sub")),l(r,"SubN",new r("subn")),l(r,"Escape",new r("escape")),l(r,"Purge",new r("purge")),l(r,"AddAuditHook",new r("addaudithook")),l(r,"Audit",new r("audit")),l(r,"CallTracing",new r("call_tracing")),l(r,"ClearTypeCache",new r("_clear_type_cache")),l(r,"CurrentFrames",new r("_current_frames")),l(r,"CurrentExceptions",new r("_current_exceptions")),l(r,"BreakpointHook",new r("breakpointhook")),l(r,"DebugMallocStats",new r("_debugmallocstats")),l(r,"DisplayHook",new r("displayhook")),l(r,"ExceptHook",new r("excepthook")),l(r,"ExcInfo",new r("exc_info")),l(r,"SysExit",new r("exit")),l(r,"GetAllocatedBlocks",new r("getallocatedblocks")),l(r,"GetAndroidApiLevel",new r("getandroidapilevel")),l(r,"GetDefaultEncoding",new r("getdefaultencoding")),l(r,"GetDLOpenFlags",new r("getdlopenflags")),l(r,"GetFileSystemEncoding",new r("getfilesystemencoding")),l(r,"GetFileSystemEncodeErrors",new r("getfilesystemencodeerrors")),l(r,"GetRefCount",new r("getrefcount")),l(r,"GetRecursionLimit",new r("getrecursionlimit")),l(r,"GetSizeOf",new r("getsizeof")),l(r,"GetSwitchInterval",new r("getswitchinterval")),l(r,"GetFrame",new r("_getframe")),l(r,"GetProfile",new r("getprofile")),l(r,"GetTrace",new r("gettrace")),l(r,"GetWindowsVersion",new r("getwindowsversion")),l(r,"GetAsyncGenHooks",new r("get_asyncgen_hooks")),l(r,"GetCoroutineOriginTrackingDepth",new r("get_coroutine_origin_tracking_depth")),l(r,"Intern",new r("intern")),l(r,"IsFinalizing",new r("is_finalizing")),l(r,"SetDLOpenFlags",new r("setdlopenflags")),l(r,"SetProfile",new r("setprofile")),l(r,"SetRecursionLimit",new r("setrecursionlimit")),l(r,"SetSwitchInterval",new r("setswitchinterval")),l(r,"SetTrace",new r("settrace")),l(r,"SetAsyncgenHooks",new r("set_asyncgen_hooks")),l(r,"EnableLegacyWindowsFSEncoding",new r("_enablelegacywindowsfsencoding")),l(r,"ABIFlags",new r("abiflags")),l(r,"Argv",new r("argv")),l(r,"BaseExecPrefix",new r("base_exec_prefix")),l(r,"BasePrefix",new r("base_prefix")),l(r,"ByteOrder",new r("byte_order")),l(r,"BuiltInModuleNames",new r("built_in_module_names")),l(r,"Copyright",new r("copyright")),l(r,"DllHandle",new r("dllhandle")),l(r,"DontWriteBytecode",new r("dont_write_bytecode")),l(r,"PycachePrefix",new r("pycache_prefix")),l(r,"ExecPrefix",new r("exec_prefix")),l(r,"Executable",new r("executable")),l(r,"Flags",new r("flags")),l(r,"FloatInfo",new r("float_info")),l(r,"FloatReprStyle",new r("float_repr_style")),l(r,"HashInfo",new r("hash_info")),l(r,"HexVersion",new r("hexversion")),l(r,"Implementation",new r("implementation")),l(r,"IntInfo",new r("int_info")),l(r,"LastType",new r("last_type")),l(r,"LastValue",new r("last_value")),l(r,"LastTraceback",new r("last_traceback")),l(r,"MaxSize",new r("maxsize")),l(r,"MaxUnicode",new r("maxunicode")),l(r,"MetaPath",new r("meta_path")),l(r,"Modules",new r("modules")),l(r,"OrigArgv",new r("orig_argv")),l(r,"Path",new r("path")),l(r,"PathHooks",new r("path_hooks")),l(r,"PathImporterCache",new r("path_importer_cache")),l(r,"Platform",new r("platform")),l(r,"Prefix",new r("prefix")),l(r,"PS1",new r("ps1")),l(r,"PS2",new r("ps2")),l(r,"StdIn",new r("stdin")),l(r,"StdOut",new r("stdout")),l(r,"StdErr",new r("stderr")),l(r,"StdLibModuleNames",new r("stdlib_module_names")),l(r,"ThreadInfo",new r("thread_info")),l(r,"TracebackLimit",new r("tracebacklimit")),l(r,"Version",new r("version")),l(r,"ApiVersion",new r("api_version")),l(r,"VersionInfo",new r("version_info")),l(r,"WarnOptions",new r("warnoptions")),l(r,"WinVer",new r("winver")),l(r,"XOptions",new r("_xoptions")),l(r,"UserDefinedFunctionCall",new r("UserDefinedFunctionCall")),l(r,"BuiltInFunctionCall",new r("BuiltInFunctionCall")),l(r,"UserDefinedMethodCall",new r("UserDefinedMethodCall")),l(r,"BuiltInMethodCall",new r("BuiltInMethodCall")),l(r,"ExceptionCall",new r("ExceptionCall")),l(r,"FunctionDefinitionStatement",new r("FunctionDefinitionStatement")),l(r,"MethodDefinitionStatement",new r("MethodDefinitionStatement")),l(r,"ForDefinitionStatement",new r("ForDefinitionStatement")),l(r,"ExceptDefinitionStatement",new r("ExceptDefinitionStatement")),l(r,"ClassDefinitionStatement",new r("ClassDefinitionStatement")),l(r,"LambdaDefinitionStatement",new r("LambdaDefinitionStatement")),l(r,"IfDefinitionStatement",new r("IfDefinitionStatement")),l(r,"ElifDefinitionStatement",new r("ElifDefinitionStatement")),l(r,"ElseDefinitionStatement",new r("ElseDefinitionStatement")),l(r,"WhileDefinitionStatement",new r("WhileDefinitionStatement")),l(r,"TryDefinitionStatement",new r("TryDefinitionStatement")),l(r,"FinallyDefinitionStatement",new r("FinallyDefinitionStatement")),l(r,"TernaryStatement",new r("TernaryStatement")),l(r,"WithDefinitionStatement",new r("WithStatment")),l(r,"GroupStatement",new r("GroupStatement")),l(r,"FString",new r("FString")),l(r,"SubscriptedExpression",new r("SubscriptedExpression")),l(r,"CalculatedExpression",new r("CalculatedExpression")),l(r,"ComparisonExpression",new r("ComparisonExpression")),l(r,"BooleanExpression",new r("BooleanExpression")),l(r,"IteratorExpression",new r("IteratorExpression")),l(r,"CombinedStringLiteral",new r("CombinedStringLiteral")),l(r,"ReturnStatement",new r("ReturnStatement")),l(r,"PropertyCallExpression",new r("PropertyCallExpression")),l(r,"AssignmentStatement",new r("AssignmentStatement")),l(r,"ChangeStatement",new r("ChangeStatement")),l(r,"ImportStatement",new r("ImportStatement")),l(r,"AssertStatement",new r("AssertStatement")),l(r,"GlobalStatement",new r("GlobalStatement")),l(r,"ThrowStatement",new r("ThrowStatement"));let t=r;const P=class P extends E{constructor(i,e=!1,n=new Map,s=new Map){super(i),this.isCustom=e,this.attributes=n,this.methods=s}static createCustomType(i){return P[i]=new P(i,!0),P[i]}toJSON(){return{name:this.name,attributes:Array.from(this.attributes.values()).map(i=>i.toJSON()),methods:Array.from(this.methods.values()).map(i=>i.toJSON())}}};l(P,"Int",new P("int")),l(P,"Float",new P("float")),l(P,"Number",new P("number (int or float)")),l(P,"String",new P("string")),l(P,"Bool",new P("bool")),l(P,"List",new P("list")),l(P,"Set",new P("set")),l(P,"Tuple",new P("tuple")),l(P,"Dict",new P("dictionary")),l(P,"File",new P("file")),l(P,"Function",new P("function")),l(P,"Class",new P("class")),l(P,"None",new P("none")),l(P,"Exception",new P("exception")),l(P,"Unknown",new P("unknown data type")),l(P,"NA",new P("N/A")),l(P,"NotParsed",new P("not parsed")),l(P,"Invalid",new P("invalid")),l(P,"Undefined",new P("undefined")),l(P,"Random",new P("random")),l(P,"Math",new P("math")),l(P,"StringModule",new P("string module")),l(P,"Re",new P("re")),l(P,"Pattern",new P("Pattern")),l(P,"Match",new P("Match")),l(P,"Sys",new P("sys"));let d=P;const V=class V extends E{constructor(e,n){super(e);l(this,"description");this.description=n}};l(V,"AssignCompares",new V("AssignCompares","A single equals is used where a boolean expression is expected, e.g. in a conditional statement. This may be a typo or confusion between single and double equals operators.")),l(V,"ColonAssigns",new V("ColonAssigns","A colon is used between a variable name and a value. This may be a typo.")),l(V,"CompareMultipleValuesWithOr",new V("CompareMultipleValuesWithOr","A boolean expression has the form a == some_value or other_value, where other_value is non-boolean. There is likely a misunderstanding of the syntax of comparing multiple values.")),l(V,"ComparisonWithBoolLiteral",new V("ComparisonWithBoolLiteral",'A boolean expression contains "== True" or "== False". The programmer may believe that explicitly checking equality is always necessary in a boolean expression.')),l(V,"DeferredReturn",new V("DeferredReturn","Code follows a return statement in a function. The programmer may not realise that a return statement causes the function to exit immediately.")),l(V,"ForLoopVarIsLocal",new V("ForLoopVarIsLocal","An iterating variable in a for loop overwrites a variable declared before the loop and the value is different from the overwritten value, or the values cannot be determined. This potential misconception is similar to IteratorInitialisedOutsideLoop.")),l(V,"FunctionCallsNoParentheses",new V("FunctionCallsNoParentheses","An undefined variable has the same name as a function. There may be a misunderstanding about how to call a function. Caution: functions in Python are first class objects, so it is possible that use of the function name without parentheses is intended and there is no misconception.")),l(V,"FunctionCallsUseSquareBrackets",new V("FunctionCallsUseSquareBrackets","The name of a function is called followed by square brackets rather than parentheses. The programmer may not be aware of when to use which type of bracket.")),l(V,"IterationRequiresTwoLoops",new V("IterationRequiresTwoLoops","A while loop with an integer loop variable contains a nested for loop. The while loop variable is only modified in the nested for loop and is used to count items in the variable iterated in the for loop. The two nested loops could be replaced with a single for loop using enumerate() or range().")),l(V,"IteratorInitialisedOutsideLoop",new V("TargetInitialisedOutsideLoop","The target variable in a for loop is initialised before the loop with the same value. The programmer may not know that the iterating variable is initialised in the for loop definition.")),l(V,"LocalVariablesAreGlobal",new V("LocalVariablesAreGlobal","An undefined variable in document scope has the same name as a variable with function scope. This may indicate a misunderstanding of variable scope.")),l(V,"LoopCounter",new V("LoopCounter","A for loop target variable is modified in the loop and the modified variable is not used. This may indicate confusion over how loops use loop variables.")),l(V,"MapToBooleanWithIf",new V("MapToBooleanWithIf","A conditional statement checks a boolean expression only to return or assign a value that matches the value of the boolean expression. The programmer may not realise that a boolean expression can be assigned or returned directly.")),l(V,"MapToBooleanWithTernaryOperator",new V("MapToBooleanWithTernaryOperator","A ternary checks a boolean expression only to return or assign a value that matches the value of the boolean expression. The programmer may not realise that a boolean expression can be assigned or returned directly.")),l(V,"NoKeyword",new V("NoKeyword","A block definition keyword (e.g. def, if, while) is missing where one is expected. The programmer may not realise that the keyword is required.")),l(V,"NoReservedWords",new V("NoReservedWords","Any string that meets naming character constraints can be used as an identifier (name of a variable, function, method, or class).")),l(V,"ParameterMustBeAssignedInFunction",new V("ParameterMustBeAssignedInFunction","A user defined function has named parameter but the parameter value is overwritten in the function before it is used e.g. by prompting for command line input. This indicates potential misconceptions about the purpose or use of function parameters.")),l(V,"ParenthesesOnlyIfArgument",new V("ParenthesesOnlyIfArgument","An undefined variable has the same name as a user-defined function with no arguments. There may be a misunderstanding of the syntax of function calls.")),l(V,"PrintSameAsReturn",new V("PrintSameAsReturn","A call to a function that prints but does not return (including the print() function) is assigned or passed, or a call to a function that prints before returning a value is not assigned or passed. There may be confusion about printing a value versus returning a value.")),l(V,"ReturnCall",new V("ReturnCall","Function return values are surrounded by parentheses. There may be a belief that return needs to be called like a function.")),l(V,"ReturnWaitsForLoop",new V("ReturnWaitsForLoop","A return statement in a loop causes the loop to consistently exit on the first iteration. Typically due to a missing if statement, there may be an expectation that the loop implicitly knows when to return and when to continue.")),l(V,"SequentialIfsAreExclusive",new V("ConditionalIsSequence","If statements with very similar conditional statements appear in a sequence. There may be a belief that subsequent if statements will only execute if the previous condition does not. The programmer may not be aware of the efficiency drawbacks of using sequential if statements where a multiway conditional would be more appropriate.")),l(V,"StringMethodsModifyTheString",new V("StringMethodsModifyTheString","A string method is called but the result is not saved or passed. There may be an assumption that string methods mutate the string.")),l(V,"TypeConversionModifiesArgument",new V("TypeConversionModifiesArgument","A type conversion function (e.g. int(), float()) is called but the return value is not saved or used.")),l(V,"TypeMustBeSpecified",new V("TypeMustBeSpecified","A value that is guaranteed to have a particular data type is passed to a type conversion function that returns the same data type. In the case of literals, there may be a belief that type must be specified as in strongly typed languages. In other cases, there may be a misunderstanding or lack of confidence in how Python dynamically determines type.")),l(V,"UnusedReturn",new V("UnusedReturn","The result of a call to a function / method that returns a value is not used in some way.")),l(V,"WhileSameAsIf",new V("WhileSameAsIf","A while loop does not modify any of its loop variables and may also always exit during the first iteration. Where this behaviour is intentional, the while definition would be better replaced with an if statement. Where the loop does not exit, there is a risk of an infinite loop."));let L=V;const D=class D extends E{constructor(e,n){super(e);l(this,"description");this.description=n}};l(D,"AssignmentInBoolean",new D("AssignmentInBoolean","An assignment operator is used in a Boolean expression. This could be a typo or an indication of confusion about = and ==.")),l(D,"AssignmentInReturn",new D("AssignmentInReturn","A variable is assigned in a return statement.")),l(D,"AssignedNone",new D("AssignedNoReturn","A function or method that does not return a value is assigned to a variable, passed as an argument, or used in some way. Commonly seen with the print() function.")),l(D,"CompareBoolLiteral",new D("CompareBoolLiteral","A Boolean expression is compared to a Boolean literal. Although this is not an error, it may indicate a misconception about Boolean values.")),l(D,"DefinitionFollowedByReservedWord",new D("DefinitionFollowedByReservedWord","A definition keyword (def or class) is followed by a reserved word, suggesting the intention to define a function or class with the same name as a reserved word.")),l(D,"DoubleComparisonOperators",new D("DoubleComparisonOperators","Two comparison operators are used side by side. This may be due to an extra space e.g. <= is written as < =.")),l(D,"ForLoopIteratorModified",new D("ForLoopTargetModified","A for loop target variable is modified in the loop and the modified value is not used.")),l(D,"FunctionPrints",new D("FunctionPrints","A user-defined function contains print statements. This is not an issue unless AssignedNoReturn is also present and print is used in place of return statements.")),l(D,"InfiniteLoop",new D("InfiniteLoop","A while loop does not exit.")),l(D,"LoopReturn",new D("LoopEarlyExit","A return or break statement causes a loop to always exit on the first iteration.")),l(D,"LoopVarModifiedInChildLoop",new D("WhileLoopVarModifiedInChildLoop","A while loop variable is modified in a nested for or while loop.")),l(D,"LoopVarNotModified",new D("WhileLoopVarNotModified","None of the variables used in a while loop definition are modified in the body of the while loop. If the while loop contains a nested loop, only usages of the variable in the outer loop are checked.")),l(D,"NaturalLanguageBoolean",new D("NaturalLanguageBoolean",`A Boolean expression uses syntax that makes sense in spoken English but may produce unexpected results or even and error in Python. The most common form is checking if a particular expression is equal to one of a range of values using "or <non_boolean>" e.g., "day == 'sat' or 'sun'".`)),l(D,"OneLineConditional",new D("OneLineConditional","A conditional that could be re-written as one line. Although this is not an error, it may indicate a misconception about Boolean values.")),l(D,"OutOfPlaceBooleanOperator",new D("OutOfPlaceOperatorsInBoolean","A comparison or logical operator is used in an unexpected place in a conditional expression.")),l(D,"OverwrittenVariable",new D("VariableOverwrite","A variable's value is initialised or changed then overwritten without being used.")),l(D,"RedundantException",new D("RedundantException","A specific exception is caught then immediately raised. Suggests confusion about how to work with exceptions.")),l(D,"ReservedWordAssigned",new D("ReservedWordAssigned","A reserved word is followed by the assignment operator, suggesting an intention to create a variable with the same name as a reserved word.")),l(D,"ReturnInParentheses",new D("ReturnInParentheses","The return keyword is followed by a value or compound expression in parentheses. May suggest a belief that returned values must be encapsulated in parentheses.")),l(D,"SequentialIfs",new D("SequentialIfs","Multiple if statements appear in sequence with no other code between the if blocks. If statements that contain a return or break at the top level are not included. Depending on the contents of the boolean expressions and each block, it may indicate a misconception about how conditionals are evaluated.")),l(D,"SubscriptedNonSubscriptable",new D("SubscriptedNonSubscriptable","Square brackets follow a variable name that does not have a subscriptable type (i.e. is not a string, list, tuple, or dictionary)")),l(D,"TernaryReturnsBool",new D("TernaryReturnsBool","A ternary returns a boolean. Although this is not an error, it may indicate a misconception about Boolean values.")),l(D,"TypeErrorInvalid",new D("InvalidCalculation","A calculation that produces a TypeError e.g. string + int.")),l(D,"TypeUnnecessary",new D("UnnecessaryTypeConversion","A value that has a guaranteed data type is passed to a type conversion function that produces the same data type. Also captures strings converted to lists.")),l(D,"UndefinedVariable",new D("UndefinedVariable","A variable that was not declared is called. Depending on context, may be due to sloppiness (e.g. a typo) or may suggest misconception about variable scope, function parameters, or how to call functions.")),l(D,"UnexpectedColon",new D("UnexpectedColon","A colon is found where it is not expected, indicating either a typo or a misunderstanding of syntax.")),l(D,"UnknownFunction",new D("UnknownFunction","A function that is not defined in the file or built in to Python is called. Could be a typo or a misunderstanding about variables.")),l(D,"UnknownMethod",new D("UnknownMethod","An unknown method, or a method that is not valid is called on a value with known data type.")),l(D,"UnreachableExhaustiveConditional",new D("UnreachableCode.exhaustiveConditional","Code that is unreachable because it follows a conditional with an else branch in which all branches return.")),l(D,"UnreachableExit",new D("UnreachableCode.exitKeyword","Code that is unreachable because it follows a <code>return</code> or <code>break</code> statement. This might indicate a misconception about how those keywords affect the flow of control.")),l(D,"UnreachableInfiniteLoop",new D("UnreachableCode.infiniteLoop",'Code that is unreachable because it follows a loop created using "while True" that never exits.')),l(D,"UnusedReturn",new D("UnusedReturn","The result of a call to a function / method that returns a value is not used in some way.")),l(D,"UnusedValue",new D("UnusedValue","A value (either a single variable or a compound expression) is created but not assigned to a variable, passed as a function argument, or used in some other way.")),l(D,"UnusedVariable",new D("UnusedVariable","A variable is not used after initialisation. May be an oversight but could potentially indicate misconceptions about variables.")),l(D,"VariableWithSameNameAsFunction",new D("VariableWithSameNameAsFunction","A variable has the same name as a function.")),l(D,"WhileLoopVarAssignedIntLiteral",new D("WhileLoopVarAssignedIntLiteral","A while loop counter variable is assigned an int value rather than incremented or decremented. The variable is not modified elsewhere in the loop.")),l(D,"WrongArgNumber",new D("WrongArgNumber","A user-defined function is called with the wrong number of arguments.")),l(D,"WhileTrue",new D("WhileTrue","A while loop is defined to iterate forever. This is a valid approach but may be a contributor to misconceptions when combined with other symptoms."));let b=D;const zt="userDefinedFunction",Zl="userDefinedVariable",Qt="builtInFunction",si="valueReturned",ii="valueAssigned",Yl="True",dr="return",_l="string",ec="list",tc="literal",hr="functionCall",nc="variable",fr="compoundTypeDefinition",gr="compoundExpression",pr="booleanExpression",ri="forLoopVariable",sc="forLoopTargetReplacesIterable",oi="assignment",ai="same",mr="different",Ms="unknown",ce="empty",ic="orNonBoolean",rc="andOr",oc="topLevel",ac="allBranchesOfExhaustiveConditional",wr="functionArgument",lc="calculation",cc="comparison";function Z(p,i){this.entity=p,this.category=i}function xs(p){switch(p){case t.TrueType:case t.FalseType:return d.Bool;case t.NoneType:return d.None;case t.StrType:case t.IntType:case t.FloatType:case t.BoolType:case t.ListType:case t.SetType:case t.DictType:case t.TupleType:return d.Class;case t.Name:case t.Doc:case t.Sep:case t.End:return d.String;case t.IntLiteral:return d.Int;case t.FloatLiteral:return d.Float;case t.StringLiteral:return d.String;case t.ListDefinition:return d.List;case t.TupleDefinition:return d.Tuple;case t.SetDefinition:return d.Set;case t.DictDefinition:return d.Dict;case t.RandomModule:return d.Random;case t.MathModule:return d.Math;case t.StringModule:return d.StringModule;case t.ReModule:return d.Re;case t.Pattern:return d.Pattern;case t.Match:return d.Match;case t.Sys:return d.Sys;default:return d.Unknown}}function Nt(p){if(p.length===0)return d.Undefined;if(p.length===1)return p[0];{const i=new Set(p);if(i.size===1)return p[0];for(let e of i)if(e!==d.Int&&e!==d.Float&&e!==d.Number)return d.Unknown;return d.Number}}function Ds(p){return new Set([d.String,d.List,d.Dict,d.Tuple,d.Unknown,d.NotParsed]).has(p)}function oe(p,i=!1){if(p.length===0)return"";let e=p[0].getTextValue();const n=i?p[0].getIndexOnLine():0;for(let s=0;s<n;s++)e=" "+e;for(let s=1;s<p.length;s++){let o=p[s].getDocumentStartIndex()-p[s-1].getDocumentEndIndex()-1;for(let u=p[s-1].getEndLineNumber();u<p[s].getStartLineNumber();u++)e+=`
`,o--;for(let u=0;u<o;u++)e+=" ";e+=p[s].getTextValue()}return e}function Bs(p){const i=[];for(const e of p){const n=e.getExpressions();i.push(...n)}return i}function Un(p,i){for(let e of p)if(e.is(i))return!0;return!1}function Xt(p){return p.getExpressionsOfKind(t.ReturnKeyword).length>0||p.getExpressionsOfKind(t.BreakKeyword).length>0||p.getExpressionsOfKind(t.ExitFunction).length>0||p.getExpressionsOfKind(t.SysExit).length>0||p.getExpressionsOfKind(t.QuitFunction).length>0}function Zt(p,i){for(let e=0;e<p.length;e++)if(p[e].is(i))return e;return-1}function uc(p){return new Set(["str","int","float","bool","str","list","set","dict"]).has(p)}function Ct(p){return p.isOneOf([t.UserDefinedFunctionCall,t.BuiltInFunctionCall,t.UserDefinedMethodCall,t.BuiltInMethodCall])&&p.getDataType()===d.None}function li(p,i,e){if(!dc(i,e))return!1;let n=0,s=0;for(let o of p)o.is(i)?n++:o.is(e)&&s++;return n>0&&n===s}function dc(p,i){return p===t.OpenParenthesis?i===t.CloseParenthesis:p===t.OpenBrace?i===t.CloseBrace:p===t.OpenSquareBracket?i===t.CloseSquareBracket:!1}function Sr(p){return p===t.OpenBrace||p===t.OpenParenthesis||p===t.OpenSquareBracket}function hc(p){return p===t.CloseBrace||p===t.CloseParenthesis||p===t.CloseSquareBracket}function fc(p){if(!Sr(p))throw new Error(`${p} is not a valid open bracket.`);return p===t.OpenBrace?t.CloseBrace:p===t.OpenParenthesis?t.CloseParenthesis:t.CloseSquareBracket}const h=(p,i)=>({entity:p,category:i}),We=p=>{switch(p){case"class":return h(t.ClassDefinition,a.BlockDefinitions);case"def":return h(t.FunctionDefinition,a.BlockDefinitions);case"elif":return h(t.ElifDefinition,a.BlockDefinitions);case"else":return h(t.ElseDefinition,a.BlockDefinitions);case"except":return h(t.ExceptDefinition,a.BlockDefinitions);case"finally":return h(t.FinallyDefinition,a.BlockDefinitions);case"for":return h(t.ForDefinition,a.BlockDefinitions);case"if":return h(t.IfDefinition,a.BlockDefinitions);case"lambda":return h(t.LambdaDefinition,a.BlockDefinitions);case"try":return h(t.TryDefinition,a.BlockDefinitions);case"while":return h(t.WhileDefinition,a.BlockDefinitions);case"with":return h(t.WithKeyword,a.BlockDefinitions);case"and":return h(t.AndOperator,a.LogicalOperators);case"not":return h(t.NotOperator,a.LogicalOperators);case"or":return h(t.OrOperator,a.LogicalOperators);case"False":return h(t.FalseType,a.Types);case"None":return h(t.NoneType,a.Types);case"True":return h(t.TrueType,a.Types);case"as":return h(t.AsKeyword,a.OtherKeywords);case"global":return h(t.GlobalKeyword,a.OtherKeywords);case"assert":return h(t.AssertKeyword,a.OtherKeywords);case"break":return h(t.BreakKeyword,a.OtherKeywords);case"continue":return h(t.ContinueKeyword,a.OtherKeywords);case"del":return h(t.DelKeyword,a.OtherKeywords);case"from":return h(t.FromKeyword,a.OtherKeywords);case"import":return h(t.ImportKeyword,a.OtherKeywords);case"in":return h(t.InKeyword,a.ComparisonOperators);case"is":return h(t.IsKeyword,a.ComparisonOperators);case"pass":return h(t.PassKeyword,a.OtherKeywords);case"raise":return h(t.RaiseKeyword,a.OtherKeywords);case"return":return h(t.ReturnKeyword,a.OtherKeywords);case"yield":return h(t.YieldKeyword,a.OtherKeywords);case"r":return h(t.R,a.OtherKeywords);case"f":return h(t.F,a.OtherKeywords);case"+":return h(t.AddOperator,a.MathsOperators);case"-":return h(t.SubtractOperator,a.MathsOperators);case"*":return h(t.MultiplyOperator,a.MathsOperators);case"/":return h(t.DivideOperator,a.MathsOperators);case"%":return h(t.ModulusOperator,a.MathsOperators);case"**":return h(t.ExponentOperator,a.MathsOperators);case"//":return h(t.IntDivideOperator,a.MathsOperators);case"=":return h(t.AssignmentOperator,a.MathsOperators);case"+=":return h(t.IncrementOperator,a.MathsOperators);case"-=":return h(t.DecrementOperator,a.MathsOperators);case"*=":return h(t.MultiplyAssignOperator,a.MathsOperators);case"/=":return h(t.DivideAssignOperator,a.MathsOperators);case"%=":return h(t.RemainderAssignOperator,a.MathsOperators);case"//=":return h(t.IntDivideAssignOperator,a.MathsOperators);case"**=":return h(t.ExponentAssignOperator,a.MathsOperators);case"==":return h(t.EqualOperator,a.ComparisonOperators);case"!=":return h(t.NotEqualOperator,a.ComparisonOperators);case">":return h(t.GreaterThanOperator,a.ComparisonOperators);case"<":return h(t.LessThanOperator,a.ComparisonOperators);case">=":return h(t.GreaterThanOrEqualOperator,a.ComparisonOperators);case"<=":return h(t.LessThanOrEqualOperator,a.ComparisonOperators);case"->":return h(t.TypeHintReturn,a.TypeHint);case"abs":return h(t.AbsFunction,a.BuiltInFunctions);case"all":return h(t.AllFunction,a.BuiltInFunctions);case"any":return h(t.AnyFunction,a.BuiltInFunctions);case"ascii":return h(t.AsciiFunction,a.BuiltInFunctions);case"bin":return h(t.BinFunction,a.BuiltInFunctions);case"bool":return h(t.BoolFunction,a.BuiltInFunctions);case"callable":return h(t.CallableFunction,a.BuiltInFunctions);case"chr":return h(t.ChrFunction,a.BuiltInFunctions);case"dict":return h(t.DictDefinition,a.BuiltInFunctions);case"divmod":return h(t.DivModFunction,a.BuiltInFunctions);case"enumerate":return h(t.EnumerateFunction,a.BuiltInFunctions);case"eval":return h(t.EvalFunction,a.BuiltInFunctions);case"exec":return h(t.ExecFunction,a.BuiltInFunctions);case"exit":return h(t.ExitFunction,a.BuiltInFunctions);case"filter":return h(t.FilterFunction,a.BuiltInFunctions);case"float":return h(t.FloatFunction,a.BuiltInFunctions);case"getattr":return h(t.GetAttrFunction,a.BuiltInFunctions);case"globals":return h(t.GlobalsFunction,a.BuiltInFunctions);case"hasattr":return h(t.HasAttrFunction,a.BuiltInFunctions);case"input":return h(t.InputFunction,a.BuiltInFunctions);case"int":return h(t.IntFunction,a.BuiltInFunctions);case"isinstance":return h(t.IsInstanceFunction,a.BuiltInFunctions);case"len":return h(t.LenFunction,a.BuiltInFunctions);case"list":return h(t.ListFunction,a.BuiltInFunctions);case"map":return h(t.MapFunction,a.BuiltInFunctions);case"max":return h(t.MaxFunction,a.BuiltInFunctions);case"min":return h(t.MinFunction,a.BuiltInFunctions);case"open":return h(t.OpenFunction,a.BuiltInFunctions);case"ord":return h(t.OrdFunction,a.BuiltInFunctions);case"pow":return h(t.PowFunction,a.BuiltInFunctions);case"print":return h(t.PrintFunction,a.BuiltInFunctions);case"quit":return h(t.QuitFunction,a.BuiltInFunctions);case"range":return h(t.RangeFunction,a.BuiltInFunctions);case"reversed":return h(t.ReversedFunction,a.BuiltInFunctions);case"round":return h(t.RoundFunction,a.BuiltInFunctions);case"set":return h(t.SetFunction,a.BuiltInFunctions);case"sorted":return h(t.SortedFunction,a.BuiltInFunctions);case"str":return h(t.StrFunction,a.BuiltInFunctions);case"sum":return h(t.SumFunction,a.BuiltInFunctions);case"tuple":return h(t.TupleFunction,a.BuiltInFunctions);case"type":return h(t.TypeFunction,a.BuiltInFunctions);case"zip":return h(t.ZipFunction,a.BuiltInFunctions);case"__main__":return h(t.Main,a.MagicMethods);case"__cmp__":return h(t.Cmp,a.MagicMethods);case"__eq__":return h(t.Eq,a.MagicMethods);case"__ne__":return h(t.Ne,a.MagicMethods);case"__lt__":return h(t.Lt,a.MagicMethods);case"__gt__":return h(t.Gt,a.MagicMethods);case"__le__":return h(t.Le,a.MagicMethods);case"__ge__":return h(t.Ge,a.MagicMethods);case"__str__":return h(t.Str,a.MagicMethods);case"__getattr__":return h(t.GetAttrVariable,a.MagicMethods);case"__setattr__":return h(t.SetAttrVariable,a.MagicMethods);case"__contains__":return h(t.SpecialContains,a.MagicMethods);case"__len__":return h(t.SpecialLen,a.MagicMethods);case"__name__":return h(t.Name,a.SpecialVariables);case"__self__":return h(t.Self,a.SpecialVariables);case"__doc__":return h(t.Doc,a.SpecialVariables);case"__class__":return h(t.ClassVariable,a.SpecialVariables);case"sep":return h(t.Sep,a.SpecialVariables);case"end":return h(t.End,a.SpecialVariables);case"ArtithmeticError":return h(t.ExceptionName,a.BuiltInExceptions);case"AssertionError":return h(t.ExceptionName,a.BuiltInExceptions);case"AttributeError":return h(t.ExceptionName,a.BuiltInExceptions);case"BlockingIOError":return h(t.ExceptionName,a.BuiltInExceptions);case"BrokenPipeError":return h(t.ExceptionName,a.BuiltInExceptions);case"BufferError":return h(t.ExceptionName,a.BuiltInExceptions);case"ChildProcessError":return h(t.ExceptionName,a.BuiltInExceptions);case"ConnectionAbortedError":return h(t.ExceptionName,a.BuiltInExceptions);case"ConnectionError":return h(t.ExceptionName,a.BuiltInExceptions);case"ConnectionRefusedError":return h(t.ExceptionName,a.BuiltInExceptions);case"ConnectionResetError":return h(t.ExceptionName,a.BuiltInExceptions);case"Exception":return h(t.ExceptionName,a.BuiltInExceptions);case"EOFError":return h(t.ExceptionName,a.BuiltInExceptions);case"EnvironmentError":return h(t.ExceptionName,a.BuiltInExceptions);case"FileExistsError":return h(t.ExceptionName,a.BuiltInExceptions);case"FileNotFoundError":return h(t.ExceptionName,a.BuiltInExceptions);case"FloatingPointError":return h(t.ExceptionName,a.BuiltInExceptions);case"GeneratorExit":return h(t.ExceptionName,a.BuiltInExceptions);case"ImportError":return h(t.ExceptionName,a.BuiltInExceptions);case"IndentationError":return h(t.ExceptionName,a.BuiltInExceptions);case"IndexError":return h(t.ExceptionName,a.BuiltInExceptions);case"InterruptedError":return h(t.ExceptionName,a.BuiltInExceptions);case"IOError":return h(t.ExceptionName,a.BuiltInExceptions);case"IsADirectoryError":return h(t.ExceptionName,a.BuiltInExceptions);case"KeyError":return h(t.ExceptionName,a.BuiltInExceptions);case"KeyboardInterrupt":return h(t.ExceptionName,a.BuiltInExceptions);case"LookupError":return h(t.ExceptionName,a.BuiltInExceptions);case"MemoryError":return h(t.ExceptionName,a.BuiltInExceptions);case"ModuleNotFoundError":return h(t.ExceptionName,a.BuiltInExceptions);case"NameError":return h(t.ExceptionName,a.BuiltInExceptions);case"NotADirectoryError":return h(t.ExceptionName,a.BuiltInExceptions);case"NotImplementedError":return h(t.ExceptionName,a.BuiltInExceptions);case"OSError":return h(t.ExceptionName,a.BuiltInExceptions);case"OverflowError":return h(t.ExceptionName,a.BuiltInExceptions);case"PermissionError":return h(t.ExceptionName,a.BuiltInExceptions);case"ProcessLookupError":return h(t.ExceptionName,a.BuiltInExceptions);case"RecursionError":return h(t.ExceptionName,a.BuiltInExceptions);case"ReferenceError":return h(t.ExceptionName,a.BuiltInExceptions);case"RuntimeError":return h(t.ExceptionName,a.BuiltInExceptions);case"StopIteration":return h(t.ExceptionName,a.BuiltInExceptions);case"SyntaxError":return h(t.ExceptionName,a.BuiltInExceptions);case"TabError":return h(t.ExceptionName,a.BuiltInExceptions);case"TimeoutError":return h(t.ExceptionName,a.BuiltInExceptions);case"SystemError":return h(t.ExceptionName,a.BuiltInExceptions);case"SystemExit":return h(t.ExceptionName,a.BuiltInExceptions);case"TypeError":return h(t.ExceptionName,a.BuiltInExceptions);case"UnboundLocalError":return h(t.ExceptionName,a.BuiltInExceptions);case"UnicodeError":return h(t.ExceptionName,a.BuiltInExceptions);case"UnicodeEncodeError":return h(t.ExceptionName,a.BuiltInExceptions);case"UnicodeDecodeError":return h(t.ExceptionName,a.BuiltInExceptions);case"UnicodeTranslateError":return h(t.ExceptionName,a.BuiltInExceptions);case"ValueError":return h(t.ExceptionName,a.BuiltInExceptions);case"Warning":return h(t.ExceptionName,a.BuiltInExceptions);case"ZeroDivisionError":return h(t.ExceptionName,a.BuiltInExceptions);case"capitalize":return h(t.Capitalize,a.BuiltInMethods);case"casefold":return h(t.Casefold,a.BuiltInMethods);case"center":return h(t.Center,a.BuiltInMethods);case"count":return h(t.Count,a.BuiltInMethods);case"encode":return h(t.Encode,a.BuiltInMethods);case"endswith":return h(t.EndsWith,a.BuiltInMethods);case"expandtabs":return h(t.ExpandTabs,a.BuiltInMethods);case"find":return h(t.Find,a.BuiltInMethods);case"format":return h(t.Format,a.BuiltInMethods);case"format_map":return h(t.FormatMap,a.BuiltInMethods);case"index":return h(t.Index,a.BuiltInMethods);case"isalnum":return h(t.IsAlnum,a.BuiltInMethods);case"isalpha":return h(t.IsAlpha,a.BuiltInMethods);case"isascii":return h(t.IsAscii,a.BuiltInMethods);case"isdecimal":return h(t.IsDecimal,a.BuiltInMethods);case"isdigit":return h(t.IsDigit,a.BuiltInMethods);case"isidentifier":return h(t.IsIdentifier,a.BuiltInMethods);case"islower":return h(t.IsLower,a.BuiltInMethods);case"isnumeric":return h(t.IsNumeric,a.BuiltInMethods);case"isprintable":return h(t.IsPrintable,a.BuiltInMethods);case"isspace":return h(t.IsSpace,a.BuiltInMethods);case"istitle":return h(t.IsTitle,a.BuiltInMethods);case"isupper":return h(t.IsUpper,a.BuiltInMethods);case"join":return h(t.Join,a.BuiltInMethods);case"ljust":return h(t.LJust,a.BuiltInMethods);case"lower":return h(t.Lower,a.BuiltInMethods);case"lstrip":return h(t.LStrip,a.BuiltInMethods);case"maketrans":return h(t.MakeTrans,a.BuiltInMethods);case"partition":return h(t.Partition,a.BuiltInMethods);case"replace":return h(t.Replace,a.BuiltInMethods);case"rfind":return h(t.RFind,a.BuiltInMethods);case"rindex":return h(t.RIndex,a.BuiltInMethods);case"rjust":return h(t.RJust,a.BuiltInMethods);case"rpartition":return h(t.RPartition,a.BuiltInMethods);case"rsplit":return h(t.RSplit,a.BuiltInMethods);case"rstrip":return h(t.RStrip,a.BuiltInMethods);case"split":return h(t.Split,a.BuiltInMethods);case"splitlines":return h(t.SplitLines,a.BuiltInMethods);case"startswith":return h(t.StartsWith,a.BuiltInMethods);case"strip":return h(t.Strip,a.BuiltInMethods);case"swapcase":return h(t.SwapCase,a.BuiltInMethods);case"title":return h(t.Title,a.BuiltInMethods);case"translate":return h(t.Translate,a.BuiltInMethods);case"upper":return h(t.Upper,a.BuiltInMethods);case"zfill":return h(t.ZFill,a.BuiltInMethods);case"append":return h(t.Append,a.BuiltInMethods);case"clear":return h(t.Clear,a.BuiltInMethods);case"copy":return h(t.Copy,a.BuiltInMethods);case"extend":return h(t.Extend,a.BuiltInMethods);case"insert":return h(t.Insert,a.BuiltInMethods);case"pop":return h(t.Pop,a.BuiltInMethods);case"remove":return h(t.Remove,a.BuiltInMethods);case"reverse":return h(t.Reverse,a.BuiltInMethods);case"sort":return h(t.Sort,a.BuiltInMethods);case"fromkeys":return h(t.FromKeys,a.BuiltInMethods);case"get":return h(t.Get,a.BuiltInMethods);case"items":return h(t.Items,a.BuiltInMethods);case"keys":return h(t.Keys,a.BuiltInMethods);case"popitem":return h(t.PopItem,a.BuiltInMethods);case"setdefault":return h(t.SetDefault,a.BuiltInMethods);case"update":return h(t.Update,a.BuiltInMethods);case"values":return h(t.Values,a.BuiltInMethods);case"add":return h(t.Add,a.BuiltInMethods);case"difference":return h(t.Difference,a.BuiltInMethods);case"difference_update":return h(t.DifferenceUpdate,a.BuiltInMethods);case"discard":return h(t.Discard,a.BuiltInMethods);case"intersection":return h(t.Intersection,a.BuiltInMethods);case"intersection_update":return h(t.IntersectionUpdate,a.BuiltInMethods);case"isdisjoint":return h(t.IsDisjoint,a.BuiltInMethods);case"issubset":return h(t.IsSubset,a.BuiltInMethods);case"issuperset":return h(t.IsSuperset,a.BuiltInMethods);case"symmetric_difference":return h(t.SymmetricDifference,a.BuiltInMethods);case"symmetric_difference_update":return h(t.SymmetricDifferenceUpdate,a.BuiltInMethods);case"union":return h(t.Union,a.BuiltInMethods);case"close":return h(t.Close,a.BuiltInMethods);case"detach":return h(t.Detach,a.BuiltInMethods);case"fileno":return h(t.FileNo,a.BuiltInMethods);case"flush":return h(t.Flush,a.BuiltInMethods);case"isatty":return h(t.IsAtty,a.BuiltInMethods);case"read":return h(t.Read,a.BuiltInMethods);case"readable":return h(t.Readable,a.BuiltInMethods);case"readline":return h(t.ReadLine,a.BuiltInMethods);case"readlines":return h(t.ReadLines,a.BuiltInMethods);case"seek":return h(t.Seek,a.BuiltInMethods);case"seekable":return h(t.Seekable,a.BuiltInMethods);case"tell":return h(t.Tell,a.BuiltInMethods);case"truncate":return h(t.Truncate,a.BuiltInMethods);case"writable":return h(t.Writable,a.BuiltInMethods);case"write":return h(t.Write,a.BuiltInMethods);case"writelines":return h(t.WriteLines,a.BuiltInMethods);case"(":return h(t.OpenParenthesis,a.Other);case")":return h(t.CloseParenthesis,a.Other);case"[":return h(t.OpenSquareBracket,a.Other);case"]":return h(t.CloseSquareBracket,a.Other);case"{":return h(t.OpenBrace,a.Other);case"}":return h(t.CloseBrace,a.Other);case",":return h(t.Comma,a.Other);case":":return h(t.Colon,a.Other);case".":return h(t.Dot,a.Other);case"\\":return h(t.ContinuationLine,a.Other);case";":return h(t.Separator,a.Other);case"'":return h(t.SingleQuote,a.Other);case'"':return h(t.DoubleQuote,a.Other);case"random":return h(t.RandomModule,a.BuiltInModules);case"math":return h(t.MathModule,a.BuiltInModules);case"string":return h(t.StringModule,a.BuiltInModules);case"re":return h(t.ReModule,a.BuiltInModules);case"sys":return h(t.Sys,a.BuiltInModules);case"seed":return h(t.Seed,a.ModuleFunctions);case"getstate":return h(t.GetState,a.ModuleFunctions);case"setstate":return h(t.SetState,a.ModuleFunctions);case"getrandbits":return h(t.GetRandBits,a.ModuleFunctions);case"randrange":return h(t.RandRange,a.ModuleFunctions);case"randint":return h(t.RandInt,a.ModuleFunctions);case"choice":return h(t.Choice,a.ModuleFunctions);case"choices":return h(t.Choices,a.ModuleFunctions);case"shuffle":return h(t.Shuffle,a.ModuleFunctions);case"sample":return h(t.Sample,a.ModuleFunctions);case"uniform":return h(t.Uniform,a.ModuleFunctions);case"triangular":return h(t.Triangular,a.ModuleFunctions);case"betavariate":return h(t.BetaVariate,a.ModuleFunctions);case"expovariate":return h(t.ExpoVariate,a.ModuleFunctions);case"gammavariate":return h(t.GammaVariate,a.ModuleFunctions);case"gauss":return h(t.Gauss,a.ModuleFunctions);case"lognormvariate":return h(t.LogNormVariate,a.ModuleFunctions);case"normalvariate":return h(t.NormalVariate,a.ModuleFunctions);case"vonmisesvariate":return h(t.VonMisesVariate,a.ModuleFunctions);case"paretovariate":return h(t.ParetoVariate,a.ModuleFunctions);case"weibullvariate":return h(t.WeibullVariate,a.ModuleFunctions);case"acos":return h(t.Acos,a.ModuleFunctions);case"acosh":return h(t.Acosh,a.ModuleFunctions);case"asin":return h(t.Asin,a.ModuleFunctions);case"asinh":return h(t.Asinh,a.ModuleFunctions);case"atan":return h(t.Atan,a.ModuleFunctions);case"atan2":return h(t.Atan2,a.ModuleFunctions);case"atanh":return h(t.Atanh,a.ModuleFunctions);case"ceil":return h(t.Ceil,a.ModuleFunctions);case"comb":return h(t.Comb,a.ModuleFunctions);case"copysign":return h(t.Copysign,a.ModuleFunctions);case"cos":return h(t.Cos,a.ModuleFunctions);case"cosh":return h(t.Cosh,a.ModuleFunctions);case"degrees":return h(t.Degrees,a.ModuleFunctions);case"dist":return h(t.Dist,a.ModuleFunctions);case"erf":return h(t.Erf,a.ModuleFunctions);case"erfc":return h(t.Erfc,a.ModuleFunctions);case"exp":return h(t.Exp,a.ModuleFunctions);case"expm1":return h(t.Expm1,a.ModuleFunctions);case"fabs":return h(t.Fabs,a.ModuleFunctions);case"factorial":return h(t.Factorial,a.ModuleFunctions);case"floor":return h(t.Floor,a.ModuleFunctions);case"fmod":return h(t.Fmod,a.ModuleFunctions);case"frexp":return h(t.Frexp,a.ModuleFunctions);case"fsum":return h(t.Fsum,a.ModuleFunctions);case"gamma":return h(t.Gamma,a.ModuleFunctions);case"gcd":return h(t.Gcd,a.ModuleFunctions);case"hypot":return h(t.Hypot,a.ModuleFunctions);case"isclose":return h(t.IsClose,a.ModuleFunctions);case"isfinite":return h(t.IsFinite,a.ModuleFunctions);case"isinf":return h(t.IsInf,a.ModuleFunctions);case"isnan":return h(t.IsNaN,a.ModuleFunctions);case"isqrt":return h(t.ISqrt,a.ModuleFunctions);case"ldexp":return h(t.Ldexp,a.ModuleFunctions);case"lgamma":return h(t.LGamma,a.ModuleFunctions);case"log":return h(t.Log,a.ModuleFunctions);case"log10":return h(t.Log10,a.ModuleFunctions);case"log1p":return h(t.Log1P,a.ModuleFunctions);case"log2":return h(t.Log2,a.ModuleFunctions);case"perm":return h(t.Perm,a.ModuleFunctions);case"pow":return h(t.Pow,a.ModuleFunctions);case"prod":return h(t.Prod,a.ModuleFunctions);case"radians":return h(t.Radians,a.ModuleFunctions);case"remainder":return h(t.Remainder,a.ModuleFunctions);case"sin":return h(t.Sin,a.ModuleFunctions);case"sinh":return h(t.Sinh,a.ModuleFunctions);case"sqrt":return h(t.Sqrt,a.ModuleFunctions);case"tan":return h(t.Tan,a.ModuleFunctions);case"tanh":return h(t.Tanh,a.ModuleFunctions);case"trun":return h(t.Trunc,a.ModuleFunctions);case"e":return h(t.E,a.ModuleProperties);case"inf":return h(t.Inf,a.ModuleProperties);case"nan":return h(t.Nan,a.ModuleProperties);case"pi":return h(t.Pi,a.ModuleProperties);case"tau":return h(t.Tau,a.ModuleProperties);case"ascii_letters":return h(t.AsciiLetters,a.ModuleProperties);case"ascii_lowercase":return h(t.AsciiLowercase,a.ModuleProperties);case"ascii_uppercase":return h(t.AsciiUppercase,a.ModuleProperties);case"digits":return h(t.Digits,a.ModuleProperties);case"hexdigits":return h(t.Hexdigits,a.ModuleProperties);case"octdigits":return h(t.Octdigits,a.ModuleProperties);case"punctuation":return h(t.Punctuation,a.ModuleProperties);case"printable":return h(t.Printable,a.ModuleProperties);case"whitespace":return h(t.Whitespace,a.ModuleProperties);case"Formatter":return h(t.Formatter,a.ModuleFunctions);case"Template":return h(t.Template,a.ModuleFunctions);case"capwords":return h(t.Capwords,a.ModuleFunctions);case"Pattern":return h(t.Pattern,a.Types);case"Match":return h(t.Match,a.Types);case"A":return h(t.ReA,a.ModuleProperties);case"ASCII":return h(t.ReASCII,a.ModuleProperties);case"DEBUG":return h(t.ReDebug,a.ModuleProperties);case"I":return h(t.ReI,a.ModuleProperties);case"IGNORECASE":return h(t.ReIGNORECASE,a.ModuleProperties);case"L":return h(t.ReL,a.ModuleProperties);case"LOCALE":return h(t.ReLOCALE,a.ModuleProperties);case"M":return h(t.ReM,a.ModuleProperties);case"MULTILINE":return h(t.ReMULTILINE,a.ModuleProperties);case"S":return h(t.ReS,a.ModuleProperties);case"DOTALL":return h(t.ReDOTALL,a.ModuleProperties);case"X":return h(t.ReX,a.ModuleProperties);case"VERBOSE":return h(t.ReVERBOSE,a.ModuleProperties);case"compile":return h(t.Compile,a.ModuleFunctions);case"search":return h(t.Search,a.ModuleFunctions);case"match":return h(t.Match,a.ModuleFunctions);case"fullmatch":return h(t.FullMatch,a.ModuleFunctions);case"findall":return h(t.FindAll,a.ModuleFunctions);case"finditer":return h(t.FindIter,a.ModuleFunctions);case"sub":return h(t.Sub,a.ModuleFunctions);case"subn":return h(t.SubN,a.ModuleFunctions);case"escape":return h(t.Escape,a.ModuleFunctions);case"purge":return h(t.Purge,a.ModuleFunctions);case"addaudithook":return h(t.AddAuditHook,a.ModuleFunctions);case"audit":return h(t.Audit,a.ModuleFunctions);case"call_tracing":return h(t.CallTracing,a.ModuleFunctions);case"_clear_type_cache":return h(t.ClearTypeCache,a.ModuleFunctions);case"_current_frames":return h(t.CurrentFrames,a.ModuleFunctions);case"_current_exceptions":return h(t.CurrentExceptions,a.ModuleFunctions);case"breakpointhook":return h(t.BreakpointHook,a.ModuleFunctions);case"_debugmallocstats":return h(t.DebugMallocStats,a.ModuleFunctions);case"displayhook":return h(t.DisplayHook,a.ModuleFunctions);case"excepthook":return h(t.ExceptHook,a.ModuleFunctions);case"exc_info":return h(t.ExcInfo,a.ModuleFunctions);case"getallocatedblocks":return h(t.GetAllocatedBlocks,a.ModuleFunctions);case"getandroidapilevel":return h(t.GetAndroidApiLevel,a.ModuleFunctions);case"getdefaultencoding":return h(t.GetDefaultEncoding,a.ModuleFunctions);case"getdlopenflags":return h(t.GetDLOpenFlags,a.ModuleFunctions);case"getfilesystemencoding":return h(t.GetFileSystemEncoding,a.ModuleFunctions);case"getfilesystemencodeerrors":return h(t.GetFileSystemEncodeErrors,a.ModuleFunctions);case"getrefcount":return h(t.GetRefCount,a.ModuleFunctions);case"getrecursionlimit":return h(t.GetRecursionLimit,a.ModuleFunctions);case"getsizeof":return h(t.GetSizeOf,a.ModuleFunctions);case"getswitchinterval":return h(t.GetSwitchInterval,a.ModuleFunctions);case"_getframe":return h(t.GetFrame,a.ModuleFunctions);case"getprofile":return h(t.GetProfile,a.ModuleFunctions);case"gettrace":return h(t.GetTrace,a.ModuleFunctions);case"getwindowsversion":return h(t.GetWindowsVersion,a.ModuleFunctions);case"get_asyncgen_hooks":return h(t.GetAsyncGenHooks,a.ModuleFunctions);case"get_coroutine_origin_tracking_depth":return h(t.GetCoroutineOriginTrackingDepth,a.ModuleFunctions);case"intern":return h(t.Intern,a.ModuleFunctions);case"is_finalizing":return h(t.IsFinalizing,a.ModuleFunctions);case"setdlopenflags":return h(t.SetDLOpenFlags,a.ModuleFunctions);case"setprofile":return h(t.SetProfile,a.ModuleFunctions);case"setrecursionlimit":return h(t.SetRecursionLimit,a.ModuleFunctions);case"setswitchinterval":return h(t.SetSwitchInterval,a.ModuleFunctions);case"settrace":return h(t.SetTrace,a.ModuleFunctions);case"set_asyncgen_hooks":return h(t.SetAsyncgenHooks,a.ModuleFunctions);case"_enablelegacywindowsfsencoding":return h(t.EnableLegacyWindowsFSEncoding,a.ModuleFunctions);case"abiflags":return h(t.ABIFlags,a.ModuleProperties);case"argv":return h(t.Argv,a.ModuleProperties);case"base_exec_prefix":return h(t.BaseExecPrefix,a.ModuleProperties);case"base_prefix":return h(t.BasePrefix,a.ModuleProperties);case"byte_order":return h(t.ByteOrder,a.ModuleProperties);case"built_in_module_names":return h(t.BuiltInModuleNames,a.ModuleProperties);case"copyright":return h(t.Copyright,a.ModuleProperties);case"dllhandle":return h(t.DllHandle,a.ModuleProperties);case"dont_write_bytecode":return h(t.DontWriteBytecode,a.ModuleProperties);case"pycache_prefix":return h(t.PycachePrefix,a.ModuleProperties);case"exec_prefix":return h(t.ExecPrefix,a.ModuleProperties);case"executable":return h(t.Executable,a.ModuleProperties);case"flags":return h(t.Flags,a.ModuleProperties);case"float_info":return h(t.FloatInfo,a.ModuleProperties);case"float_repr_style":return h(t.FloatReprStyle,a.ModuleProperties);case"hash_info":return h(t.HashInfo,a.ModuleProperties);case"hexversion":return h(t.HexVersion,a.ModuleProperties);case"implementation":return h(t.Implementation,a.ModuleProperties);case"int_info":return h(t.IntInfo,a.ModuleProperties);case"last_type":return h(t.LastType,a.ModuleProperties);case"last_value":return h(t.LastValue,a.ModuleProperties);case"last_traceback":return h(t.LastTraceback,a.ModuleProperties);case"maxsize":return h(t.MaxSize,a.ModuleProperties);case"maxunicode":return h(t.MaxUnicode,a.ModuleProperties);case"meta_path":return h(t.MetaPath,a.ModuleProperties);case"modules":return h(t.Modules,a.ModuleProperties);case"orig_argv":return h(t.OrigArgv,a.ModuleProperties);case"path":return h(t.Path,a.ModuleProperties);case"path_hooks":return h(t.PathHooks,a.ModuleProperties);case"path_importer_cache":return h(t.PathImporterCache,a.ModuleProperties);case"platform":return h(t.Platform,a.ModuleProperties);case"prefix":return h(t.Prefix,a.ModuleProperties);case"ps1":return h(t.PS1,a.ModuleProperties);case"ps2":return h(t.PS2,a.ModuleProperties);case"stdin":return h(t.StdIn,a.ModuleProperties);case"stdout":return h(t.StdOut,a.ModuleProperties);case"stderr":return h(t.StdErr,a.ModuleProperties);case"stdlib_module_names":return h(t.StdLibModuleNames,a.ModuleProperties);case"thread_info":return h(t.ThreadInfo,a.ModuleProperties);case"tracebacklimit":return h(t.TracebackLimit,a.ModuleProperties);case"version":return h(t.Version,a.ModuleProperties);case"api_version":return h(t.ApiVersion,a.ModuleProperties);case"version_info":return h(t.VersionInfo,a.ModuleProperties);case"warnoptions":return h(t.WarnOptions,a.ModuleProperties);case"winver":return h(t.WinVer,a.ModuleProperties);case"_xoptions":return h(t.XOptions,a.ModuleProperties);default:return h(t.Unknown,a.Unknown)}},Ir=p=>{switch(p){case"str":return h(t.StrType,a.Types);case"int":return h(t.IntType,a.Types);case"float":return h(t.FloatType,a.Types);case"bool":return h(t.BoolType,a.Types);case"list":return h(t.ListType,a.Types);case"set":return h(t.SetType,a.Types);case"dict":return h(t.DictType,a.Types);case"tuple":return h(t.TupleType,a.Types);default:return h(t.Unknown,a.Unknown)}},Ot=new Map([[t.AbsFunction,d.Number],[t.AllFunction,d.Bool],[t.AnyFunction,d.Bool],[t.AsciiFunction,d.String],[t.AssertFunction,d.None],[t.BinFunction,d.String],[t.BoolFunction,d.Bool],[t.CallableFunction,d.Bool],[t.ChrFunction,d.String],[t.DictFunction,d.Dict],[t.DivModFunction,d.Tuple],[t.EnumerateFunction,d.Tuple],[t.EvalFunction,d.Unknown],[t.ExecFunction,d.None],[t.ExitFunction,d.None],[t.FilterFunction,d.Unknown],[t.FloatFunction,d.Float],[t.GetAttrFunction,d.Unknown],[t.GlobalsFunction,d.Dict],[t.HasAttrFunction,d.Bool],[t.InputFunction,d.String],[t.IntFunction,d.Int],[t.IsInstanceFunction,d.Bool],[t.LenFunction,d.Int],[t.ListFunction,d.List],[t.MapFunction,d.Unknown],[t.MaxFunction,d.Number],[t.MinFunction,d.Number],[t.OpenFunction,d.File],[t.OrdFunction,d.Int],[t.PowFunction,d.Number],[t.PrintFunction,d.None],[t.QuitFunction,d.None],[t.RangeFunction,d.Unknown],[t.ReversedFunction,d.Unknown],[t.RoundFunction,d.Float],[t.SetFunction,d.Set],[t.SortedFunction,d.List],[t.StrFunction,d.String],[t.SumFunction,d.Number],[t.TupleFunction,d.Tuple],[t.TypeFunction,d.Class],[t.Capitalize,d.String],[t.Casefold,d.String],[t.Center,d.String],[t.Count,d.Int],[t.Encode,d.String],[t.EndsWith,d.Bool],[t.ExpandTabs,d.String],[t.Find,d.Int],[t.Format,d.String],[t.FormatFunction,d.String],[t.Index,d.Int],[t.IsAlnum,d.Bool],[t.IsAlpha,d.Bool],[t.IsAscii,d.Bool],[t.IsDecimal,d.Bool],[t.IsDigit,d.Bool],[t.IsIdentifier,d.Bool],[t.IsLower,d.Bool],[t.IsNumeric,d.Bool],[t.IsPrintable,d.Bool],[t.IsSpace,d.Bool],[t.IsTitle,d.Bool],[t.IsUpper,d.Bool],[t.Join,d.String],[t.LJust,d.String],[t.Lower,d.String],[t.LStrip,d.String],[t.MakeTrans,d.Dict],[t.Partition,d.Tuple],[t.Replace,d.String],[t.RFind,d.Int],[t.RIndex,d.Int],[t.RJust,d.String],[t.RPartition,d.Tuple],[t.RSplit,d.List],[t.RStrip,d.String],[t.Split,d.List],[t.SplitLines,d.List],[t.StartsWith,d.Bool],[t.Strip,d.String],[t.SwapCase,d.String],[t.Title,d.String],[t.Translate,d.String],[t.Upper,d.String],[t.ZFill,d.String],[t.Append,d.None],[t.Clear,d.None],[t.Copy,d.Unknown],[t.Extend,d.None],[t.Insert,d.None],[t.Pop,d.Unknown],[t.Remove,d.None],[t.Reverse,d.None],[t.Sort,d.None],[t.FromKeys,d.Dict],[t.Get,d.Unknown],[t.Items,d.List],[t.Keys,d.Unknown],[t.PopItem,d.None],[t.SetDefault,d.Unknown],[t.Update,d.None],[t.Values,d.Unknown],[t.Add,d.None],[t.Difference,d.Set],[t.DifferenceUpdate,d.None],[t.Discard,d.None],[t.Intersection,d.Set],[t.IntersectionUpdate,d.None],[t.IsDisjoint,d.Bool],[t.IsSubset,d.Bool],[t.IsSuperset,d.Bool],[t.SymmetricDifference,d.Set],[t.SymmetricDifferenceUpdate,d.None],[t.Union,d.Set],[t.Close,d.None],[t.FileNo,d.Int],[t.Flush,d.None],[t.IsAtty,d.Bool],[t.Read,d.String],[t.Readable,d.Bool],[t.ReadLine,d.String],[t.ReadLines,d.List],[t.Seek,d.None],[t.Seekable,d.Bool],[t.Tell,d.Unknown],[t.Truncate,d.None],[t.Writable,d.Bool],[t.Write,d.None],[t.WriteLines,d.None],[t.Main,d.None],[t.Cmp,d.Int],[t.Eq,d.Bool],[t.Ne,d.Bool],[t.Lt,d.Bool],[t.Gt,d.Bool],[t.Le,d.Bool],[t.Ge,d.Bool],[t.Str,d.String],[t.SpecialContains,d.Bool],[t.SpecialLen,d.Int],[t.ZipFunction,d.Unknown],[t.Seed,d.None],[t.GetState,d.Unknown],[t.SetState,d.None],[t.GetRandBits,d.Int],[t.RandRange,d.Int],[t.RandInt,d.Int],[t.Choice,d.Unknown],[t.Choices,d.List],[t.Shuffle,d.Shuffle],[t.Sample,d.List],[t.RandomMethod,d.Float],[t.Uniform,d.Float],[t.Triangular,d.Float],[t.BetaVariate,d.Float],[t.ExpoVariate,d.Float],[t.GammaVariate,d.Float],[t.Gauss,d.Float],[t.LogNormVariate,d.Float],[t.NormalVariate,d.Float],[t.VonMisesVariate,d.Float],[t.ParetoVariate,d.Float],[t.WeibullVariate,d.Float],[t.Acos,d.Float],[t.Acosh,d.Float],[t.Asin,d.Float],[t.Asinh,d.Float],[t.Atan,d.Float],[t.Atan2,d.Float],[t.Atanh,d.Float],[t.Ceil,d.Int],[t.Comb,d.Int],[t.CopySign,d.Float],[t.Cos,d.Float],[t.Cosh,d.Float],[t.Degrees,d.Float],[t.Dist,d.Float],[t.Erf,d.Float],[t.Erfc,d.Float],[t.Exp,d.Float],[t.Expm1,d.Float],[t.Fabs,d.Float],[t.Factorial,d.Int],[t.Floor,d.Int],[t.Fmod,d.Float],[t.Frexp,d.Tuple],[t.Fsum,d.Float],[t.Gamma,d.Float],[t.Gcd,d.Int],[t.Hypot,d.Float],[t.IsClose,d.Bool],[t.IsFinite,d.Bool],[t.IsInf,d.Bool],[t.IsNaN,d.Bool],[t.ISqrt,d.Int],[t.Ldexp,d.Float],[t.LGamma,d.Float],[t.Log,d.Float],[t.Log10,d.Float],[t.Log1P,d.Float],[t.Log2,d.Float],[t.Perm,d.Int],[t.Pow,d.Float],[t.Prod,d.Float],[t.Radians,d.Float],[t.Remainder,d.Float],[t.Sin,d.Float],[t.Sinh,d.Float],[t.Sqrt,d.Float],[t.Tan,d.Float],[t.Tanh,d.Float],[t.Trunc,d.Int],[t.E,d.Float],[t.Inf,d.Float],[t.Nan,d.Float],[t.Pi,d.Float],[t.Tau,d.Float],[t.AsciiLetters,d.String],[t.AsciiLowercase,d.String],[t.AsciiUppercase,d.String],[t.Digits,d.String],[t.Hexdigits,d.String],[t.Octdigits,d.String],[t.Punctuation,d.String],[t.Printable,d.String],[t.Whitespace,d.String],[t.Formatter,d.String],[t.Template,d.String],[t.Capwords,d.String],[t.ReA,d.Unknown],[t.ReASCII,d.Unknown],[t.ReDebug,d.Unknown],[t.ReI,d.Unknown],[t.ReIGNORECASE,d.Unknown],[t.ReL,d.Unknown],[t.ReLOCALE,d.Unknown],[t.ReM,d.Unknown],[t.ReMULTILINE,d.Unknown],[t.ReS,d.Unknown],[t.ReDOTALL,d.Unknown],[t.ReX,d.Unknown],[t.ReVERBOSE,d.Unknown],[t.Compile,d.Pattern],[t.Search,d.Unknown],[t.Match,d.Unknown],[t.FullMatch,d.Unknown],[t.FindAll,d.List],[t.FindIter,d.Unknown],[t.Sub,d.String],[t.SubN,d.Tuple],[t.Escape,d.String],[t.Purge,d.None],[t.AddAuditHook,d.None],[t.Audit,d.None],[t.CallTracing,d.Unknown],[t.ClearTypeCache,d.None],[t.CurrentFrames,d.Dict],[t.CurrentExceptions,d.Dict],[t.BreakpointHook,d.None],[t.DebugMallocStats,d.None],[t.DisplayHook,d.None],[t.ExceptHook,d.None],[t.ExcInfo,d.Tuple],[t.SysExit,d.None],[t.GetAllocatedBlocks,d.Int],[t.GetAndroidApiLevel,d.Int],[t.GetDefaultEncoding,d.String],[t.GetDLOpenFlags,d.Int],[t.GetFileSystemEncoding,d.String],[t.GetFileSystemEncodeErrors,d.String],[t.GetRefCount,d.Int],[t.GetRecursionLimit,d.Int],[t.GetSizeOf,d.Int],[t.GetSwitchInterval,d.Float],[t.GetFrame,d.Unknown],[t.GetProfile,d.None],[t.GetTrace,d.None],[t.GetWindowsVersion,d.Tuple],[t.GetAsyncGenHooks,d.Unknown],[t.GetCoroutineOriginTrackingDepth,d.Int],[t.Intern,d.Unknown],[t.IsFinalizing,d.Bool],[t.SetDLOpenFlags,d.None],[t.SetProfile,d.Unknown],[t.SetRecursionLimit,d.None],[t.SetSwitchInterval,d.None],[t.SetTrace,d.None],[t.SetAsyncgenHooks,d.None],[t.EnableLegacyWindowsFSEncoding,d.None],[t.ABIFlags,d.String],[t.Argv,d.List],[t.BaseExecPrefix,d.String],[t.BasePrefix,d.String],[t.ByteOrder,d.String],[t.BuiltInModuleNames,d.Tuple],[t.Copyright,d.String],[t.DllHandle,d.Int],[t.DontWriteBytecode,d.Bool],[t.PycachePrefix,d.Unknown],[t.ExecPrefix,d.String],[t.Executable,d.String],[t.Flags,d.Unknown],[t.FloatInfo,d.Unknown],[t.FloatReprStyle,d.String],[t.HashInfo,d.Unknown],[t.HexVersion,d.Int],[t.Implementation,d.Unknown],[t.IntInfo,d.Unknown],[t.LastType,d.Unknown],[t.LastValue,d.Unknown],[t.LastTraceback,d.Unknown],[t.MaxSize,d.Int],[t.MaxUnicode,d.Int],[t.MetaPath,d.List],[t.Modules,d.Dict],[t.OrigArgv,d.List],[t.Path,d.List],[t.PathHooks,d.List],[t.PathImporterCache,d.Dict],[t.Platform,d.String],[t.Prefix,d.String],[t.PS1,d.String],[t.PS2,d.String],[t.StdIn,d.Unknown],[t.StdOut,d.Unknown],[t.StdErr,d.Unknown],[t.StdLibModuleNames,d.Unknown],[t.ThreadInfo,d.Unknown],[t.TracebackLimit,d.Unknown],[t.Version,d.String],[t.ApiVersion,d.Int],[t.VersionInfo,d.Tuple],[t.WarnOptions,d.List],[t.WinVer,d.Int],[t.XOptions,d.Dict]]),gc=new Set([t.Add,t.Append,t.Clear,t.DifferenceUpdate,t.Discard,t.Extend,t.Insert,t.IntersectionUpdate,t.Pop,t.PopItem,t.Remove,t.Reverse,t.SetDefault,t.Sort,t.SymmetricDifferenceUpdate,t.Update]),br=new Set([t.Capitalize,t.Casefold,t.Center,t.Encode,t.ExpandTabs,t.Format,t.FormatMap,t.LJust,t.Lower,t.LStrip,t.Replace,t.RJust,t.RStrip,t.Strip,t.SwapCase,t.Title,t.Translate,t.Upper,t.ZFill]),yr=new Map([[t.Seed,t.RandomModule],[t.GetState,t.RandomModule],[t.SetState,t.RandomModule],[t.GetRandBits,t.RandomModule],[t.RandRange,t.RandomModule],[t.RandInt,t.RandomModule],[t.Choice,t.RandomModule],[t.Choices,t.RandomModule],[t.Shuffle,t.RandomModule],[t.Sample,t.RandomModule],[t.RandomMethod,t.RandomModule],[t.Uniform,t.RandomModule],[t.Triangular,t.RandomModule],[t.BetaVariate,t.RandomModule],[t.ExpoVariate,t.RandomModule],[t.GammaVariate,t.RandomModule],[t.Gauss,t.RandomModule],[t.LogNormVariate,t.RandomModule],[t.NormalVariate,t.RandomModule],[t.VonMisesVariate,t.RandomModule],[t.ParetoVariate,t.RandomModule],[t.WeibullVariate,t.RandomModule],[t.Acos,t.MathModule],[t.Acosh,t.MathModule],[t.Asin,t.MathModule],[t.Asinh,t.MathModule],[t.Atan,t.MathModule],[t.Atan2,t.MathModule],[t.Atanh,t.MathModule],[t.Ceil,t.MathModule],[t.Comb,t.MathModule],[t.CopySign,t.MathModule],[t.Cos,t.MathModule],[t.Cosh,t.MathModule],[t.Degrees,t.MathModule],[t.Dist,t.MathModule],[t.Erf,t.MathModule],[t.Erfc,t.MathModule],[t.Exp,t.MathModule],[t.Expm1,t.MathModule],[t.Fabs,t.MathModule],[t.Factorial,t.MathModule],[t.Floor,t.MathModule],[t.Fmod,t.MathModule],[t.Frexp,t.MathModule],[t.Fsum,t.MathModule],[t.Gamma,t.MathModule],[t.Gcd,t.MathModule],[t.Hypot,t.MathModule],[t.IsClose,t.MathModule],[t.IsFinite,t.MathModule],[t.IsInf,t.MathModule],[t.IsNaN,t.MathModule],[t.ISqrt,t.MathModule],[t.Ldexp,t.MathModule],[t.LGamma,t.MathModule],[t.Log,t.MathModule],[t.Log10,t.MathModule],[t.Log1P,t.MathModule],[t.Log2,t.MathModule],[t.Perm,t.MathModule],[t.Pow,t.MathModule],[t.Prod,t.MathModule],[t.Radians,t.MathModule],[t.Remainder,t.MathModule],[t.Sin,t.MathModule],[t.Sinh,t.MathModule],[t.Sqrt,t.MathModule],[t.Tan,t.MathModule],[t.Tanh,t.MathModule],[t.Trunc,t.MathModule],[t.E,t.MathModule],[t.Inf,t.MathModule],[t.Nan,t.MathModule],[t.Pi,t.MathModule],[t.Tau,t.MathModule],[t.AsciiLetters,t.StringModule],[t.AsciiLowercase,t.StringModule],[t.AsciiUppercase,t.StringModule],[t.Digits,t.StringModule],[t.Hexdigits,t.StringModule],[t.Octdigits,t.StringModule],[t.Punctuation,t.StringModule],[t.Printable,t.StringModule],[t.Whitespace,t.StringModule],[t.Formatter,t.StringModule],[t.Template,t.StringModule],[t.Capwords,t.StringModule],[t.Pattern,t.ReModule],[t.Match,t.ReModule],[t.ReA,t.ReModule],[t.ReASCII,t.ReModule],[t.ReDebug,t.ReModule],[t.ReI,t.ReModule],[t.ReIGNORECASE,t.ReModule],[t.ReL,t.ReModule],[t.ReLOCALE,t.ReModule],[t.ReM,t.ReModule],[t.ReMULTILINE,t.ReModule],[t.ReS,t.ReModule],[t.ReDOTALL,t.ReModule],[t.ReX,t.ReModule],[t.ReVERBOSE,t.ReModule],[t.Compile,t.ReModule],[t.Search,t.ReModule],[t.Match,t.ReModule],[t.FullMatch,t.ReModule],[t.FindAll,t.ReModule],[t.FindIter,t.ReModule],[t.Sub,t.ReModule],[t.SubN,t.ReModule],[t.Escape,t.ReModule],[t.Purge,t.ReModule],[t.Split,t.ReModule],[t.AddAuditHook,t.Sys],[t.Audit,t.Sys],[t.CallTracing,t.Sys],[t.ClearTypeCache,t.Sys],[t.CurrentFrames,t.Sys],[t.CurrentExceptions,t.Sys],[t.BreakpointHook,t.Sys],[t.DebugMallocStats,t.Sys],[t.DisplayHook,t.Sys],[t.ExceptHook,t.Sys],[t.ExcInfo,t.Sys],[t.SysExit,t.Sys],[t.GetAllocatedBlocks,t.Sys],[t.GetAndroidApiLevel,t.Sys],[t.GetDefaultEncoding,t.Sys],[t.GetDLOpenFlags,t.Sys],[t.GetFileSystemEncoding,t.Sys],[t.GetFileSystemEncodeErrors,t.Sys],[t.GetRefCount,t.Sys],[t.GetRecursionLimit,t.Sys],[t.GetSizeOf,t.Sys],[t.GetSwitchInterval,t.Sys],[t.GetFrame,t.Sys],[t.GetProfile,t.Sys],[t.GetTrace,t.Sys],[t.GetWindowsVersion,t.Sys],[t.GetAsyncGenHooks,t.Sys],[t.GetCoroutineOriginTrackingDepth,t.Sys],[t.Intern,t.Sys],[t.IsFinalizing,t.Sys],[t.SetDLOpenFlags,t.Sys],[t.SetProfile,t.Sys],[t.SetRecursionLimit,t.Sys],[t.SetSwitchInterval,t.Sys],[t.SetTrace,t.Sys],[t.SetAsyncgenHooks,t.Sys],[t.EnableLegacyWindowsFSEncoding,t.Sys],[t.ABIFlags,t.Sys],[t.Argv,t.Sys],[t.BaseExecPrefix,t.Sys],[t.BasePrefix,t.Sys],[t.ByteOrder,t.Sys],[t.BuiltInModuleNames,t.Sys],[t.Copyright,t.Sys],[t.DllHandle,t.Sys],[t.DontWriteBytecode,t.Sys],[t.PycachePrefix,t.Sys],[t.ExecPrefix,t.Sys],[t.Executable,t.Sys],[t.Flags,t.Sys],[t.FloatInfo,t.Sys],[t.FloatReprStyle,t.Sys],[t.HashInfo,t.Sys],[t.HexVersion,t.Sys],[t.Implementation,t.Sys],[t.IntInfo,t.Sys],[t.LastType,t.Sys],[t.LastValue,t.Sys],[t.LastTraceback,t.Sys],[t.MaxSize,t.Sys],[t.MaxUnicode,t.Sys],[t.MetaPath,t.Sys],[t.Modules,t.Sys],[t.OrigArgv,t.Sys],[t.Path,t.Sys],[t.PathHooks,t.Sys],[t.PathImporterCache,t.Sys],[t.Platform,t.Sys],[t.Prefix,t.Sys],[t.PS1,t.Sys],[t.PS2,t.Sys],[t.StdIn,t.Sys],[t.StdOut,t.Sys],[t.StdErr,t.Sys],[t.StdLibModuleNames,t.Sys],[t.ThreadInfo,t.Sys],[t.TracebackLimit,t.Sys],[t.Version,t.Sys],[t.ApiVersion,t.Sys],[t.VersionInfo,t.Sys],[t.WarnOptions,t.Sys],[t.WinVer,t.Sys],[t.XOptions,t.Sys]]),ci={assert:{entity:t.AssertFunction,category:a.BuiltInFunctions},random:{entity:t.RandomMethod,category:a.BuiltInMethods},exit:{entity:t.SysExit,category:a.ModuleFunctions}},ui=new Map([[d.String,new Set([t.Capitalize,t.Casefold,t.Center,t.Count,t.Encode,t.ExpandTabs,t.Find,t.Format,t.Index,t.IsAlnum,t.IsAlpha,t.IsAscii,t.IsDecimal,t.IsDigit,t.IsIdentifier,t.IsLower,t.IsNumeric,t.IsPrintable,t.IsSpace,t.IsTitle,t.IsUpper,t.Join,t.LJust,t.Lower,t.LStrip,t.MakeTrans,t.Partition,t.Replace,t.RFind,t.RIndex,t.RJust,t.RPartition,t.RSplit,t.RStrip,t.Split,t.SplitLines,t.StartsWith,t.Strip,t.SwapCase,t.Title,t.Translate,t.Upper,t.ZFill])],[d.List,new Set([t.Append,t.Clear,t.Copy,t.Count,t.Extend,t.Index,t.Insert,t.Pop,t.Remove,t.Reverse,t.Sort,a.MagicMethods])],[d.Tuple,new Set([t.Count,t.Index])],[d.Set,new Set([t.Add,t.Clear,t.Copy,t.Difference,t.DifferenceUpdate,t.Discard,t.Intersection,t.IntersectionUpdate,t.IsDisjoint,t.IsSubset,t.IsSuperset,t.Pop,t.Remove,t.SymmetricDifference,t.SymmetricDifferenceUpdate,t.Union,t.Update])],[d.Dict,new Set([t.Clear,t.Copy,t.FromKeys,t.Get,t.Items,t.Keys,t.Pop,t.PopItem,t.SetDefault,t.Update,t.Values])],[d.File,new Set([t.Close,t.FileNo,t.Flush,t.IsAtty,t.Read,t.Readable,t.ReadLine,t.ReadLines,t.Seek,t.Seekable,t.Tell,t.Truncate,t.Writable,t.Write,t.WriteLines])],[d.Random,new Set([t.Seed,t.GetState,t.SetState,t.GetRandBits,t.RandRange,t.RandInt,t.Choice,t.Choices,t.Shuffle,t.Sample,t.RandomMethod,t.Uniform,t.Triangular,t.BetaVariate,t.ExpoVariate,t.GammaVariate,t.Gauss,t.LogNormVariate,t.NormalVariate,t.VonMisesVariate,t.ParetoVariate,t.WeibullVariate,a.MagicMethods])],[d.Math,new Set([t.Acos,t.Acosh,t.Asin,t.Asinh,t.Atan,t.Atan2,t.Atanh,t.Ceil,t.Comb,t.CopySign,t.Cos,t.Cosh,t.Degrees,t.Dist,t.Erf,t.Erfc,t.Exp,t.Expm1,t.Fabs,t.Factorial,t.Floor,t.Fmod,t.Frexp,t.Fsum,t.Gamma,t.Gcd,t.Hypot,t.IsClose,t.IsFinite,t.IsInf,t.IsNaN,t.ISqrt,t.Ldexp,t.LGamma,t.Log,t.Log10,t.Log1P,t.Log2,t.Perm,t.Pow,t.Prod,t.Radians,t.Remainder,t.Sin,t.Sinh,t.Sqrt,t.Tan,t.Tanh,t.Trunc])],[d.StringModule,new Set([t.Formatter,t.Template,t.Capwords])],[d.Re,new Set([t.Compile,t.Search,t.Match,t.FullMatch,t.FindAll,t.FindIter,t.Sub,t.SubN,t.Escape,t.Purge,t.Split])],[d.Sys,new Set([t.AddAuditHook,t.Audit,t.CallTracing,t.ClearTypeCache,t.CurrentFrames,t.CurrentExceptions,t.BreakpointHook,t.DebugMallocStats,t.DisplayHook,t.ExceptHook,t.ExcInfo,t.SysExit,t.GetAllocatedBlocks,t.GetAndroidApiLevel,t.GetDefaultEncoding,t.GetDLOpenFlags,t.GetFileSystemEncoding,t.GetFileSystemEncodeErrors,t.GetRefCount,t.GetRecursionLimit,t.GetSizeOf,t.GetSwitchInterval,t.GetFrame,t.GetProfile,t.GetTrace,t.GetWindowsVersion,t.GetAsyncGenHooks,t.GetCoroutineOriginTrackingDepth,t.Intern,t.IsFinalizing,t.SetDLOpenFlags,t.SetProfile,t.SetRecursionLimit,t.SetSwitchInterval,t.SetTrace,t.SetAsyncgenHooks,t.EnableLegacyWindowsFSEncoding])]]);class H{constructor(i,e,n,s,o,u="",f={}){I(this,xt);I(this,Dt);I(this,Bt);I(this,At);I(this,kt);I(this,_t);I(this,en);y(this,xt,i),y(this,Dt,e),y(this,en,n),y(this,Bt,s),y(this,At,o),y(this,kt,u),y(this,_t,f)}getID(){return c(this,xt)}getLineNumber(){return c(this,Dt)}getBlock(){return c(this,en)}getDocIndex(){return c(this,Bt)}getLineIndex(){return c(this,At)}getAffectedText(){return c(this,kt)}getAdditionalInfo(){return c(this,_t)}toString(){return`{line: ${c(this,Dt)}, type: ${c(this,xt)}, text: ${c(this,kt)}, docIndex: ${c(this,Bt)}, lineIndex: ${c(this,At)}, additionalInfo: ${c(this,_t)}`}toJSON(){return{line:c(this,Dt),type:c(this,xt),text:c(this,kt),block:c(this,en),docIndex:c(this,Bt),lineIndex:c(this,At)}}}xt=new WeakMap,Dt=new WeakMap,Bt=new WeakMap,At=new WeakMap,kt=new WeakMap,_t=new WeakMap,en=new WeakMap;class pc extends H{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("parentText")&&(i.parentText=e.parentText),i}}class mc extends H{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();if(e.hasOwnProperty("expression")){let n=e.expression.getCategory().name;e.expression.getEntity()===t.VariableName?n=Zl:e.expression.is(t.UserDefinedFunctionCall)?n=zt:e.expression.is(t.BuiltInFunctionCall)&&(n=Qt),i.expressionNoValue={type:n,value:e.expression.getTextValue()}}return e.hasOwnProperty("usage")&&(i.usage=e.usage),e.hasOwnProperty("target")&&(i.target=e.target),i}}class wc extends H{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("assignedVariables")&&(i.assignedVariables=e.assignedVariables),i}}class Sc extends H{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("boolValue")&&(i.boolValue=e.boolValue),e.hasOwnProperty("operator")&&(i.operator=e.operator),e.hasOwnProperty("boolLiteral")&&(i.boolLiteral=e.boolLiteral),e.hasOwnProperty("usedIn")&&(i.usedIn=e.usedIn),i}}class Ic extends H{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("definitionType")&&(i.boolValue=e.definitionType),e.hasOwnProperty("reservedWord")&&(i.reservedWord=e.reservedWord),i}}class bc extends H{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("definitionText")&&(i.definitionText=e.definitionText),e.hasOwnProperty("loopVarTypeAtDefinition")&&(i.loopVarTypeAtDefinition=e.loopVarTypeAtDefinition),e.hasOwnProperty("modificationText")&&(i.modificationText=e.modificationText),i}}class yc extends H{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("printLines")&&(i.printLines=e.printLines),e.hasOwnProperty("functionReturns")&&(i.functionReturns=e.functionReturns),i}}class Fc extends H{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("loopType")&&(i.loopType=e.loopType),e.hasOwnProperty("exitLevel")&&(i.exitLevel=e.exitLevel),e.hasOwnProperty("exitTypes")&&(i.exitTypes=e.exitTypes),i}}class Tc extends H{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("modifiedIn")&&(i.modifiedIn=e.modifiedIn),i}}class Nc extends H{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("unmodifiedVars")&&(i.unmodifiedVars=e.unmodifiedVars),e.hasOwnProperty("loopText")&&(i.loopText=e.loopText),i}}class Cc extends H{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("form")&&(i.form=e.form),e.hasOwnProperty("leftSideType")&&(i.leftSideType=e.leftSideType.name),e.hasOwnProperty("leftSideText")&&(i.leftSideText=e.leftSideText),e.hasOwnProperty("leftSideEntity")&&(i.leftSideEntity=e.leftSideEntity.name),e.hasOwnProperty("operator")&&(i.operator=e.operator),e.hasOwnProperty("rightSideType")&&(i.rightSideType=e.rightSideType.name),e.hasOwnProperty("rightSideText")&&(i.rightSideText=e.rightSideText),e.hasOwnProperty("rightSideEntity")&&(i.rightSideEntity=e.rightSideEntity.name),e.hasOwnProperty("parentText")&&(i.parentText=e.parentText),e.hasOwnProperty("parentEntity")&&(i.parentEntity=e.parentEntity.name),e.hasOwnProperty("completeBooleanExpression")&&(i.completeBooleanExpression=e.completeBooleanExpression),i}}class Oc extends H{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("form")&&(i.form=e.form),e.hasOwnProperty("variableAssigned")&&(i.variableAssigned=e.variableAssigned),e.hasOwnProperty("condition")&&(i.condition=e.condition),i}}class Mc extends H{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("isParameter")&&(i.isParameter=e.isParameter),e.hasOwnProperty("prevUsageIsDefinition")&&(i.prevUsageIsDefinition=e.prevUsageIsDefinition),e.hasOwnProperty("overwriteType")&&(i.overwriteType=e.overwriteType),e.hasOwnProperty("overwriteValue")&&(i.overwriteValue=e.overwriteValue),e.hasOwnProperty("overwrittenVar")&&(i.overwrittenVar=e.overwrittenVar),e.hasOwnProperty("functionBlock")&&(i.functionBlock=e.functionBlock),e.hasOwnProperty("usageText")&&(i.usageText=e.usageText),i}}class xc extends H{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("contents")&&(i.contents=e.contents),e.hasOwnProperty("textInParentheses")&&(i.textInParentheses=e.textInParentheses),i}}class Dc extends H{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("branchMatches")&&(i.branchMatches=e.branchMatches),i}}class Bc extends H{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("isUndefined")&&(i.isUndefined=e.isUndefined),e.hasOwnProperty("subscriptedType")&&(i.subscriptedType=e.subscriptedType.name),e.hasOwnProperty("varName")&&(i.varName=e.varName),i}}class Ac extends H{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("boolValue")&&(i.boolValue=e.boolValue),e.hasOwnProperty("boolLiteralIfTrue")&&(i.boolLiteralIfTrue=e.boolLiteralIfTrue),e.hasOwnProperty("boolLiteralIfFalse")&&(i.boolLiteralIfFalse=e.boolLiteralIfFalse),e.hasOwnProperty("parentText")&&(i.parentText=e.parentText),e.hasOwnProperty("parentEntity")&&(i.parentEntity=e.parentEntity),i}}class kc extends H{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("parts")&&(i.parts=e.parts),i}}class Pc extends H{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("convertedValue")&&(i.convertedValue=e.convertedValue),e.hasOwnProperty("argType")&&(i.argType=e.argType),e.hasOwnProperty("convertedType")&&(i.convertedType=e.convertedType),i}}class Lc extends H{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("variable")&&(i.variable=e.variable.toJSON()),e.hasOwnProperty("localVariables")&&(i.localVariables=e.localVariables),i}}class Vc extends H{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("before")&&(i.before=e.before),e.hasOwnProperty("after")&&(i.after=e.after),i}}class vc extends H{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("objectType")&&(i.objectType=e.objectType),i}}class Rc extends H{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("exitKeyword")&&(i.exitKeyword=e.exitKeyword),i}}class Uc extends H{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("infiniteLoopLine")&&(i.infiniteLoopLine=e.infiniteLoopLine),i}}class Ec extends H{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();if(e.hasOwnProperty("expression")){let n=e.expression.getCategory().name;e.expression.getEntity()===t.FunctionName?n=zt:e.expression.getCategory()===a.BuiltInFunctions&&(n=Qt),i.unusedFunc={type:n,value:e.expression.getTextValue(),returnType:e.expression.getDataType().name.replace(" (int or float)","")}}return i}}class Gc extends H{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("funcType")&&(i.funcType=e.funcType),e.hasOwnProperty("numArgsExpected")&&(i.numArgsExpected=e.numArgsExpected),e.hasOwnProperty("varIsParameter")&&(i.varIsParameter=e.varIsParameter),i}}class $c extends H{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("expectedMinArgs")&&(i.expectedMinArgs=e.expectedMinArgs),e.hasOwnProperty("expectedMaxArgs")&&(i.expectedMinArgs=e.expectedMaxArgs),e.hasOwnProperty("receivedArgs")&&(i.receivedArgs=e.receivedArgs),i}}class M{static createStatementSymptom(i,e,n,s,o={},u="",f=!1){const g=e[n].getStartLineNumber(),w=u===""?e[n].getBlockId():u,S=e[n].getDocumentStartIndex(),F=e[n].getIndexOnLine(),T=oe(e.slice(n,s+1),f);switch(i){case b.AssignmentInBoolean:return new pc(i.name,g,w,S,F,T,o);case b.AssignedNone:return new mc(i.name,g,w,S,F,T,o);case b.AssignmentInReturn:return new wc(i.name,g,w,S,F,T,o);case b.CompareBoolLiteral:return new Sc(i.name,g,w,S,F,T,o);case b.DefinitionFollowedByReservedWord:return new Ic(i.name,g,w,S,F,T,o);case b.FunctionPrints:return new yc(i.name,g,w,S,F,T,o);case b.ForLoopIteratorModified:return new bc(i.name,g,w,S,F,T,o);case b.LoopReturn:return new Fc(i.name,g,w,S,F,T,o);case b.LoopVarModifiedInChildLoop:return new Tc(i.name,g,w,S,F,T,o);case b.LoopVarNotModified:return new Nc(i.name,g,w,S,F,T,o);case b.NaturalLanguageBoolean:return new Cc(i.name,g,w,S,F,T,o);case b.OneLineConditional:return new Oc(i.name,g,w,S,F,T,o);case b.OverwrittenVariable:return new Mc(i.name,g,w,S,F,T,o);case b.ReturnInParentheses:return new xc(i.name,g,w,S,F,T,o);case b.SequentialIfs:return new Dc(i.name,g,w,S,F,T,o);case b.SubscriptedNonSubscriptable:return new Bc(i.name,g,w,S,F,T,o);case b.TernaryReturnsBool:return new Ac(i.name,g,w,S,F,T,o);case b.TypeErrorInvalid:return new kc(i.name,g,w,S,F,T,o);case b.TypeUnnecessary:return new Pc(i.name,g,w,S,F,T,o);case b.UndefinedVariable:return new Lc(i.name,g,w,S,F,T,o);case b.UnexpectedColon:return new Vc(i.name,g,w,S,F,T,o);case b.UnknownMethod:return new vc(i.name,g,w,S,F,T,o);case b.UnreachableExit:return new Rc(i.name,g,w,S,F,T,o);case b.UnreachableInfiniteLoop:return new Uc(i.name,g,w,S,F,T,o);case b.UnusedReturn:return new Ec(i.name,g,w,S,F,T,o);case b.VariableWithSameNameAsFunction:return new Gc(i.name,g,w,S,F,T,o);case b.WrongArgNumber:return new $c(i.name,g,w,S,F,T,o);default:return new H(i.name,g,w,S,F,T,o)}}static checkBooleanCompare(i){const e=i.getParent();e!==void 0&&(e.is(t.AssignmentStatement)||e.isOneOf([t.BooleanExpression,t.UserDefinedFunctionCall,t.BuiltInFunctionCall,t.IfDefinitionStatement,t.ElifDefinitionStatement,t.WhileDefinitionStatement,t.ReturnStatement,t.AssertStatement,t.ComparisonExpression,t.GroupStatement,t.TernaryStatement,t.BuiltInMethodCall,t.UserDefinedMethodCall]))}}l(M,"symptoms",[]),l(M,"constructs",[]),l(M,"text","");class As{constructor(){I(this,tn,[]);I(this,nn,[])}checkRules(i){for(const e of c(this,tn))M.symptoms.push(...e(i))}checkForConstructs(i){for(const e of c(this,nn))M.constructs.push(...e(i))}addRule(i){c(this,tn).push(i)}addConstructRule(i){c(this,nn).push(i)}addRules(i){c(this,tn).push(...i)}addConstructRules(i){c(this,nn).push(...i)}}tn=new WeakMap,nn=new WeakMap;class ks extends As{constructor(){super();l(this,"observers");this.observers=new Set}addObserver(e,n=void 0){this.observers.add(e),e instanceof ks&&n!==void 0&&e.typeUpdateReceived(n)}getObservers(){return this.observers}removeObserver(e){this.observers.delete(e)}sendUpdate(e){for(let n of this.observers)n instanceof ks&&n.typeUpdateReceived(e)}typeUpdateReceived(e){}}class Fr extends As{constructor(e,n,s){super();I(this,De);I(this,Pt);I(this,Ve,[]);I(this,ct);I(this,st);I(this,sn,!1);I(this,Jn,[]);I(this,Kn,[]);if(!e.getVariable().isOneOf([t.VariableName,t.PropertyName]))throw new Error("First expression of variable is not a variable.");y(this,Pt,e.getVariable().getTextValue()),c(this,Ve).push(e);const o=n.getExpressions();o.length>0&&o[0].is(t.FunctionDefinitionStatement)&&y(this,sn,!0),y(this,ct,s),y(this,st,s.getScope()),this.addRules([m(this,De,Wr),m(this,De,Jr)])}getName(){return c(this,Pt)}getUsages(){return c(this,Ve)}addUsages(e){for(let n of e)this.addUsage(n)}insertUsages(e){const n=[...c(this,Ve)];y(this,Ve,e),this.addUsages(n)}addUsage(e){const n=e.getVariable();if(c(this,Ve).length>0){let s=c(this,Ve).length-1,o=!1;const u=new Set,f=[];for(;s>=0&&!o;){const g=c(this,Ve)[s],w=g.getVariable();if(g.isInConditionalDefinition()){const S=g.getBodyOfConditional();if(u.has(S)){s--;continue}}if(e.isInSameBlock(g)||g.isInParentBlock(e)||m(this,De,$r).call(this,w,n))n.addLastUsage(w),o=!0;else if(!e.isInAlternateBranch(g)&&!u.has(g.getBlock())){n.addLastUsage(w);const S=g.getBlock();u.add(S),S.isBranchBlock()&&S.isBranchOfConditional()&&(S.getBlockEntity()===t.ElseDefinition||S.getBlockEntity()===t.ExceptDefinition?f.push(new Set([...S.getSiblingConditionalBranches()])):S.isBranchOfExhaustiveConditional()&&(o=m(this,De,Di).call(this,S,e.getBlock(),f,u)))}s--}if(!o&&!n.isAssignedOrChanged()){const g=new Yt("Undefined Variable",t.VariableName,a.Identifiers,-1,-1,-1);g.setDataType(d.Undefined),n.addLastUsage(g)}}n.isProxy()||c(this,Ve).push(e)}checkAndAdjustUndefined(){const e=this.getUsages();e[0].getVariable().isProxy()&&(e[0].getVariable().setDataType(d.Undefined),e.shift())}getDefinedInBlock(){return c(this,ct)}setDefinedInBlock(e){y(this,ct,e),e.isScopeBlock()||y(this,st,e.getScope())}isSameVariable(e){return c(this,Pt)===e.getName()&&c(this,ct).getId()===e.getDefinedInBlock().getId()&&c(this,st).hasChild(e.getScope()||e.getScope().hasChild(c(this,st)))}getScope(){return c(this,st)}isParameter(){return c(this,sn)}getChildScopesWithUsages(){return c(this,Jn)}addChildScopeWithUsages(e){c(this,Jn).push(e)}addChildScopeVariable(e){c(this,Kn).push(e)}getChildScopeVariables(){return c(this,Kn)}toJSON(){return{name:c(this,Pt),definitionBlock:c(this,ct).getId(),scopeBlock:c(this,st).getId(),isParameter:c(this,sn),usages:c(this,Ve).map(e=>e.toJSON())}}}Pt=new WeakMap,Ve=new WeakMap,ct=new WeakMap,st=new WeakMap,sn=new WeakMap,Jn=new WeakMap,Kn=new WeakMap,De=new WeakSet,$r=function(e,n){return e.is(t.VariableName)||n.is(t.VariableName)?!1:e.getOwnerType().name===n.getOwnerType().name},Di=function(e,n,s,o){for(const u of s)if(u.has(e)&&(u.delete(e),u.size===0)){if(e.getParentBlock().hasChild(n))return!0;o.add(e.getParentBlock());const f=e.getParentBlock();if(f.isBranchBlock()){if(f.getBlockEntity()===t.ElseDefinition||f.getBlockEntity()===t.ExceptDefinition)s.push(new Set([...f.getSiblingConditionalBranches()]));else if(f.isBranchOfExhaustiveConditional())return m(this,De,Di).call(this,f,n,s,o)}}return!1},Jr=function(e){var o;const n=[],s=e.getUsages();if(s.length===1){const f=s[0].getVariable(),g=f.getParent()&&f.getParent().is(t.MethodDefinitionStatement)&&f.getParent().getClassVar().getTextValue()===f.getTextValue();s.length===1&&f.isAssignedOrChanged()&&!g&&!m(o=e,De,Kr).call(o,f)&&f.getDataType()!==d.Undefined&&n.push(M.createStatementSymptom(b.UnusedVariable,[s[0].getVariable()],0,0))}return n},Kr=function(e){if(e.getParent()===void 0)return!1;if(e.getParent().is(t.AssignmentStatement)){const n=e.getParent().getParent();return n===void 0?!1:n.isOneOf([a.FunctionCall,a.MethodCall])}return!1},Wr=function(e){const n=[],s=e.getUsages();let o;for(const u of s)if(!u.isPrecededByGlobal()){o=u;break}return o!==void 0&&s.length>0&&o.getVariable().getDataType()===d.Undefined&&(n.push(M.createStatementSymptom(b.UndefinedVariable,[o.getVariable()],0,0,{variable:e})),We(o.getVariable().getTextValue()).category===a.BuiltInFunctions&&n.push(M.createStatementSymptom(b.VariableWithSameNameAsFunction,[o.getVariable()],0,0,{funcType:Qt,varIsParameter:o.getVariable().isParameter()}))),n};class Tr{constructor(i,e,n=!1){I(this,dt);I(this,ut);I(this,Fe);I(this,rn,!1);I(this,Wn);y(this,ut,i),y(this,Wn,n);const s=e.getStatements();e.isBranchBlock()&&e.getBlockEntity()!==t.ForDefinition&&e.getBlockEntity()!==t.WhileDefinition&&s.length>0?s[0].getDefinitionStatement().containsExpression(i)?(y(this,Fe,e.getParentBlock()),y(this,rn,!0)):y(this,Fe,e):(y(this,Fe,e),s.length>0&&s[s.length-1].isBlockStatement()&&s[s.length-1].containsExpression(i)&&y(this,rn,!0))}getVariable(){return c(this,ut)}getBlock(){return c(this,Fe)}isInConditionalDefinition(){return c(this,rn)}getBodyOfConditional(){const i=c(this,Fe).getChildBlocks(),e=this.getVariable().getStartLineNumber();for(const n of i)if(n.isBranchBlock()&&n.isBranchOfConditional()&&n.getStatements()[0].getLineNumbers().has(e))return n;return c(this,Fe)}isInSameBlock(i){return c(this,Fe)===i.getBlock()}isInParentBlock(i){return!this.isInSameBlock(i)&&c(this,Fe).hasChild(i.getBlock())}isInAlternateBranch(i){if(c(this,Fe).getBlockEntity()===t.ExceptDefinition&&i.getBlock().getBlockEntity()===t.TryDefinition&&c(this,Fe).getParentBlock()===i.getBlock().getParentBlock())return!1;const e=this.isInConditionalDefinition(),n=i.isInConditionalDefinition();let s=c(this,Fe);e&&!n&&(s=this.getBodyOfConditional());let o=m(this,dt,_s).call(this,s);const u=m(this,dt,_s).call(this,i.getBlock());return o!==void 0&&u!==void 0?m(this,dt,qr).call(this,o,u,i.getBlock()):o!==void 0&&u===void 0||o===void 0&&u!==void 0?!1:!s.hasChild(i.getBlock())&&!i.getBlock().hasChild(s)}isPrecededByGlobal(){return c(this,Wn)}toJSON(){return{line:c(this,ut).getStartLineNumber(),docIndex:c(this,ut).getDocumentStartIndex(),type:c(this,ut).getDataType().name}}}ut=new WeakMap,Fe=new WeakMap,rn=new WeakMap,Wn=new WeakMap,dt=new WeakSet,qr=function(i,e,n){for(;i!==void 0&&e!==void 0&&i!==e;){const s=i.getSiblingConditionalBranches();for(let o of s)if(o.hasChild(n))return!0;i=m(this,dt,_s).call(this,i.getParentBlock())}return!1},_s=function(i){return i!==void 0&&i.isBranchBlock()&&i.isBranchOfConditional()?i:i.getNearestParentOfAny([t.IfDefinition,t.ElifDefinition,t.ElseDefinition])};class Jc{constructor(i,e,n=i){I(this,qn);I(this,jn);I(this,on);I(this,it);I(this,Lt);y(this,qn,i),y(this,jn,e),y(this,on,n),y(this,it,new Map),y(this,Lt,!1)}getName(){return c(this,qn)}getEntity(){return c(this,jn)}getAlias(){return c(this,on)}setAlias(i){y(this,on,i)}addDirectImport(i,e){c(this,it).set(i,e)}hasDirectImport(i){return c(this,it).has(i)}getDirectImport(i){return c(this,it).get(i)}getDirectImports(){return c(this,it)}setImportAll(){y(this,Lt,!0)}didImportAll(){return c(this,Lt)}hasDirectImports(){return c(this,Lt)||c(this,it).size>0}}qn=new WeakMap,jn=new WeakMap,on=new WeakMap,it=new WeakMap,Lt=new WeakMap;const Kc=(p,i)=>({entity:p,category:i});class Nr{constructor(i){I(this,an);I(this,ht,0);I(this,ft,0);y(this,an,i);for(let e=0;e<i.length;e++)i.charAt(e)==="	"?Ys(this,ft)._++:Ys(this,ht)._++}getText(){return c(this,an)}getSpaceCount(){return c(this,ht)}getTabCount(){return c(this,ft)}noIndentation(){return c(this,an).length===0}isAllSpaces(){return c(this,ht)>0&&c(this,ft)===0}isAllTabs(){return c(this,ft)>0&&c(this,ht)===0}isMixed(){return c(this,ft)>0&&c(this,ht)>0}}an=new WeakMap,ht=new WeakMap,ft=new WeakMap;class Cr extends As{constructor(e=t.DocumentDefinition,n=void 0,s=0){super();I(this,W);I(this,ve);I(this,gt);I(this,ae);I(this,Hn);I(this,Q);y(this,ve,e),y(this,gt,n),y(this,ae,[]),y(this,Hn,s),y(this,Q,[]),this.addRules([m(this,W,Xr),m(this,W,Qr),m(this,W,zr),m(this,W,jr)])}getBlockEntity(){return c(this,ve)}getId(){return`${c(this,ve)===t.DocumentDefinition?0:c(this,Q).length>0?c(this,Q)[0].getFirstLineNumber():-1}-${c(this,ve).name}`}getParentBlock(){return c(this,gt)}setParentBlock(e){y(this,gt,e)}getRootBlock(){return c(this,gt)===void 0?this:c(this,gt).getRootBlock()}getChildBlocks(){return c(this,ae)}getChildBlocksOfKind(e){let n=[];for(const s of c(this,ae))n=n.concat(s.getChildBlocksOfKind(e));return c(this,ve)===e&&n.push(this),n}addChildBlock(e){c(this,ae).push(e),e.setParentBlock(this)}hasParentOfEntity(e){return this.stepsToParentBlockOfEntity(e)>=0}stepsToParentBlockOfEntity(e){if(c(this,ve)===e)return 0;let n=this.getParentBlock(),s=1;for(;n!==void 0;){if(n.getBlockEntity()===e)return s;n=n.getParentBlock(),s++}return-1}getNearestParentOfAny(e){if(e.includes(c(this,ve)))return this;let n=this.getParentBlock();for(;n!==void 0;){if(e.includes(n.getBlockEntity()))return n;n=n.getParentBlock()}}getNearestParentChildOf(e){if(this===e||!e.hasChild(this))return;let n=this.getParentBlock();for(;n!==void 0&&n.getParentBlock()!==e;)n=n.getParentBlock();return n}getIndentation(){return c(this,Hn)}getStartLine(){return c(this,ve)===t.DocumentDefinition?0:c(this,Q).length>0?c(this,Q)[0].getFirstLineNumber():-1}isScopeBlock(){return!1}isBranchBlock(){return!1}getScope(){if(this.isScopeBlock())return this;let e=this.getParentBlock();for(;e!==void 0&&!e.isScopeBlock();)e=e.getParentBlock();if(e!==void 0)return e;throw new Error("Could not find a scope block...block structure must be incorrect")}addStatement(e){c(this,Q).push(e);for(const n of e.getExpressions())n.setBlockId(this.getId()),n.setScopeId(this.getScope().getId());K.makeGraphConnections(c(this,Q))}getLastStatement(){if(c(this,Q).length===0)throw new Error("No statements in the block. Could not get the last statement.");return c(this,Q)[c(this,Q).length-1]}replaceLastStatement(e){if(c(this,Q).length===0)throw new Error("No statements in block. Cannot replace last statement.");c(this,Q)[c(this,Q).length-1]=e}updateLastStatement(e){const n=this.getLastStatement();if(!n.isBlockStatement())throw new Error("The last statement is not a block statement.");for(const s of e.getExpressions())s.setBlockId(this.getId()),s.setScopeId(this.getScope().getId());n.addStatement(e)}getStatements(){return c(this,Q)}hasChild(e){if(this===e)return!0;{let n=e.getParentBlock();for(;n!==void 0;){if(n===this)return!0;n=n.getParentBlock()}return!1}}getBlockContainingLineNumber(e){if(c(this,Q).length===0&&console.log("stop"),!(c(this,Q)[0].getFirstLineNumber()>e||this.getLastStatement().getLastLineNumber()<e)){for(let n of c(this,ae))if(n.getBlockContainingLineNumber()!==void 0)return n;return this}}getLastExecutedStatements(){let e=[];for(let n of c(this,ae))n.isScopeBlock()||(e=e.concat(n.getLastExecutedStatements()));for(let n=0;n<c(this,Q).length;n++)if(!c(this,Q)[n].isBlockStatement()){if(n===c(this,Q).length-1)e.push(c(this,Q)[n]);else if(!c(this,Q)[n].isBlank()&&c(this,Q)[n].getFirstExpression().isOneOf([t.ReturnStatement,t.BreakKeyword])){e.push(c(this,Q)[n]);break}}return e}alwaysReturnsAValue(){if(c(this,ve)===t.DocumentDefinition)return!1;if(c(this,ae).length===0){const e=this.getLastExecutedStatements();return e.length===1&&!e[0].isBlank()&&e[0].getFirstExpression().is(t.ReturnStatement)}else{if(this.hasTopLevelReturn())return!0;let e=!1,n=c(this,ae).length-1;for(;n>=0;){if(c(this,ae)[n].getBlockEntity()===t.ElseDefinition&&c(this,ae)[n].alwaysReturnsAValue())e=!0;else if(e&&c(this,ae)[n].getBlockEntity()===t.ElifDefinition&&c(this,ae)[n].alwaysReturnsAValue())e=!0;else{if(e&&c(this,ae)[n].getBlockEntity()===t.IfDefinition&&c(this,ae)[n].alwaysReturnsAValue())return!0;e=!1}n--}return!1}}hasTopLevelReturn(){for(let e of c(this,Q))if(!e.isBlockStatement()&&!e.isBlank()&&e.getFirstExpression().is(t.ReturnStatement))return!0;return!1}checkRules(e){super.checkRules(e);for(const n of e.getChildBlocks())n.checkRules(n)}toJSON(){return{id:this.getId(),startLine:this.getStartLine(),children:c(this,ae).map(e=>e.toJSON())}}toTree(){return{id:this.getId(),statements:c(this,Q).map(e=>e.toJSON()),children:c(this,ae).map(e=>e.toTree())}}static blockFactory(e=t.DocumentDefinition,n=void 0,s=0){switch(e){case t.DocumentDefinition:case t.FunctionDefinition:case t.ClassDefinition:case t.ListComprehension:return new En(e,n,s);default:return new Or(e,n,s)}}}ve=new WeakMap,gt=new WeakMap,ae=new WeakMap,Hn=new WeakMap,Q=new WeakMap,W=new WeakSet,jr=function(e){var o;const n=[];let s=e.getStatements();s.length===1&&s[0].isBlockStatement()&&s[0].getFirstExpression().getBlockId()===e.getId()&&(s=s[0].getStatements().slice(1));for(let u=0;u<s.length;u++){const f=s[u].getFirstExpression();if(f.is(t.WhileDefinitionStatement)&&m(o=e,W,Hr).call(o,s[u])){const g=s[u].getDefinitionStatement().getFirstExpression();if(n.push(M.createStatementSymptom(b.InfiniteLoop,[g],0,0)),u<s.length-1){const w=Bs(s.slice(u+1));n.push(M.createStatementSymptom(b.UnreachableInfiniteLoop,w,0,w.length-1,{infiniteLoopLine:f.getStartLineNumber()}))}}if(Xt(f)&&u<s.length-1){const g=s.slice(u+1),w=Bs(g),S=f.getFirstExpressionOf([t.ReturnKeyword,t.BreakKeyword,t.ExitFunction,t.SysExit,t.QuitFunction]);n.push(M.createStatementSymptom(b.UnreachableExit,w,0,w.length-1,{exitKeyword:S!==void 0?S.getTextValue():"undefined"}))}}return n},Hr=function(e){const o=e.getDefinitionStatement().getFirstExpression().getVariableExpressions();for(const u of e.getStatements()){const f=u.getExpressions();for(const g of f){if(Xt(g))return!1;const w=g.getVariableExpressions().filter(F=>F.isAssignedOrChanged()),S=new Set(w.map(F=>F.getTextValue()));for(const F of o)if(S.has(F.getTextValue()))return!1}}return!0},zr=function(e){const n=[];for(const s of e.getChildBlocks())if(s.getBlockEntity()===t.IfDefinition&&s.isBranchOfExhaustiveConditional()&&s.hasTopLevelExit()){const o=s.getSiblingConditionalBranches();let u=!0,f=-1;for(const g of o){if(!g.hasTopLevelExit()){u=!1;break}g.getBlockEntity()===t.ElseDefinition&&(f=g.getStartLine())}if(u&&f>0){const g=e.getStatements().filter(w=>w.getFirstLineNumber()>f);if(g.length>0){const w=Bs(g);n.push(M.createStatementSymptom(b.UnreachableExhaustiveConditional,w,0,w.length-1))}}}return n},Qr=function(e){var u,f,g,w;const n=[];let s=e.getStatements();s.length===1&&s[0].isBlockStatement()&&(s=s[0].getStatements().slice(1));let o=[];for(let S=0;S<s.length-1;S++){const F=s[S].getFirstExpression(),T=s[S+1].getFirstExpression();if(F.is(t.IfDefinitionStatement)&&T.is(t.IfDefinitionStatement)&&!m(u=e,W,Bi).call(u,s[S])&&!m(f=e,W,Bi).call(f,s[S+1]))o.length===0&&o.push(s[S]),o.push(s[S+1]);else if(o.length>0){const R=m(g=e,W,Ai).call(g,o);R!==void 0&&n.push(R),o=[]}}if(o.length>0){const S=m(w=e,W,Ai).call(w,o);S!==void 0&&n.push(S)}return n},Bi=function(e){const n=e.getStatements().slice(1);for(const s of n)if(!s.isBlockStatement()&&Xt(s.getFirstExpression()))return!0;return!1},Ai=function(e){if(e.length===0)return;const n=[];let s=[];for(let u=0;u<e.length-1;u++){let f=e[u].getFirstExpression().getCondition();f=f.length===1&&f[0].is(t.GroupStatement)?f[0].getContents():f;let g=e[u+1].getFirstExpression().getCondition();g=g.length===1&&g[0].is(t.GroupStatement)?g[0].getContents():g,m(this,W,ki).call(this,f,g)&&m(this,W,ki).call(this,g,f)?((s.length===0||s[s.length-1].docIndex!==e[u].getFirstExpression().getDocumentStartIndex())&&s.push({lineNum:e[u].getFirstExpression().getStartLineNumber(),docIndex:e[u].getFirstExpression().getDocumentStartIndex()}),s.push({lineNum:e[u+1].getFirstExpression().getStartLineNumber(),docIndex:e[u+1].getFirstExpression().getDocumentStartIndex()})):s.length>0&&(n.push(s),s=[])}s.length>0&&(n.push(s),s=[]);const o=Bs(e);return M.createStatementSymptom(b.SequentialIfs,o,0,o.length-1,{branchMatches:n})},ki=function(e,n){if(e.length!==n.length)return!1;for(const s of e){let o=!1;for(const u of n)if(s.matchesPattern(u)){o=!0;break}if(!o)return!1}return!0},Xr=function(e){var u,f,g,w;const n=S=>{try{const T=S.getFirstExpression().getCondition();if(T.length>0)return T.map(R=>R.getTextValue()).join(" ")}catch{return""}},s=[];let o=e.getStatements();o.length===1&&o[0].isBlockStatement()&&o[0].getFirstExpression().getBlockId()===e.getId()&&(o=o[0].getStatements().slice(1));for(let S=0;S<o.length-1;S++){let F={};const T=o[S].getFirstExpression(),R=o[S+1].getFirstExpression();if(T.is(t.IfDefinitionStatement)){const k=o[S].getStatements();if(R.is(t.ElseDefinitionStatement)){const O=o[S+1].getStatements();if(k.length===2&&O.length===2&&m(u=e,W,Li).call(u,k[1],O[1])){const qt=n(k[0]);F={form:si,condition:qt}}else if(k.length===2&&O.length===2&&m(f=e,W,Pi).call(f,k[1],O[1])){const qt=n(k[0]);F={form:ii,variableAssigned:k[1].getFirstExpression().getTargetVariables()[0].getTextValue(),condition:qt}}}else if(k.length===2&&m(g=e,W,Li).call(g,k[1],o[S+1])){const O=n(k[0]);F={form:si,condition:O}}else if(k.length===2&&m(w=e,W,Pi).call(w,k[1],o[S+1])){const O=n(k[0]);F={form:ii,variableAssigned:k[1].getFirstExpression().getTargetVariables()[0].getTextValue(),condition:O}}if(F.hasOwnProperty("form")){const O=[...o[S].getExpressions(),...o[S+1].getExpressions()];s.push(M.createStatementSymptom(b.OneLineConditional,O,0,O.length-1,F))}}}return s},Pi=function(e,n){const s=e.getFirstExpression(),o=n.getFirstExpression();if(s.getDataType()===d.Bool&&o.getDataType()===d.Bool&&s.is(t.AssignmentStatement)&&o.is(t.AssignmentStatement)){const u=m(this,W,Cs).call(this,s.getAssignedValues()),f=m(this,W,Cs).call(this,o.getAssignedValues()),g=s.getTargetVariables(),w=o.getTargetVariables();return u.length!==1||f.length!==1||g.length!==1||w.length!==1?!1:g[0].getTextValue()===w[0].getTextValue()&&m(this,W,Vi).call(this,u[0],f[0])}return!1},Li=function(e,n){const s=e.getFirstExpression(),o=n.getFirstExpression();if(s.getDataType()===d.Bool&&o.getDataType()===d.Bool&&s.is(t.ReturnStatement)&&o.is(t.ReturnStatement)){const u=m(this,W,Cs).call(this,s.getReturnedValue()),f=m(this,W,Cs).call(this,o.getReturnedValue());return u.length!==1||f.length!==1?!1:m(this,W,Vi).call(this,u[0],f[0])}return!1},Vi=function(e,n){return e.is(t.TrueType)&&n.is(t.FalseType)||e.is(t.FalseType)&&n.is(t.TrueType)},Cs=function(e){return e.length!==1?e:e[0].is(t.GroupStatement)?e[0].getContents():e};class En extends Cr{constructor(e=t.DocumentDefinition,n=void 0,s=0){if(e!==t.DocumentDefinition&&e!==t.FunctionDefinition&&e!==t.ClassDefinition&&e!==t.ListComprehension)throw new Error(`${e.name} is not a scope block`);super(e,n,s);l(this,"variableMap",new Map);l(this,"globalVars",new Set);l(this,"moduleMap",new Map);l(this,"userDefinedFunctionMap",new Map);l(this,"unconnectedFunctionCalls",new Map);l(this,"userDefinedClassMap",new Map);l(this,"unconnectedMethodCalls",new Map);I(this,yi);I(this,Fi)}isScopeBlock(){return!0}getScope(){return this}addStatement(e){super.addStatement(e),K.connectVariableUsages(e,this);const n=this.getParentBlock()!==void 0&&this.getBlockEntity()!==t.ListComprehension?this.getParentBlock().getScope():this;K.connectUserDefinedFunctions(e,n!==void 0?n:this),K.connectUserDefinedMethods(e,n!==void 0?n:this)}getVariableMap(){return this.variableMap}getModuleMap(){return this.moduleMap}getStatementToUpdate(e,n){if(this.getStatements().length>0&&this.getLastStatement().isBlockStatement())return this.getLastStatement().getLastLineNumber()!==n?this.getLastStatement().getBlockStatementForIndent(e):this.getLastStatement().getLastBlockStatement()}addUserDefinedFunction(e){if(e!==void 0){const n=e.getTextValue();if(this.userDefinedFunctionMap.set(n,e),this.unconnectedFunctionCalls.has(n)){for(let s of this.unconnectedFunctionCalls.get(n))e.addObserver(s);this.unconnectedFunctionCalls.delete(n)}}}addUserDefinedClass(e){this.userDefinedClassMap.set(e.name,e)}getUserDefinedFunctions(){return this.userDefinedFunctionMap}getUserDefinedClasses(){return this.userDefinedClassMap}getUnconnectedFunctionCalls(){return this.unconnectedFunctionCalls}getUnconnectedMethodCalls(){return this.unconnectedMethodCalls}addUnconnectedFunctionCall(e){const n=e.getFunctionName();this.unconnectedFunctionCalls.has(n)||this.unconnectedFunctionCalls.set(n,[]),this.unconnectedFunctionCalls.get(n).push(e)}addUnconnectedMethodCall(e){const n=e.getMethodName();this.unconnectedMethodCalls.has(n)||this.unconnectedMethodCalls.set(n,[]),this.unconnectedMethodCalls.get(n).push(e)}addGlobalVar(e){this.globalVars.add(e)}getGlobalVars(){return this.globalVars}findAllFunctions(){const e=new Map(this.getUserDefinedFunctions());let n=this.getParentBlock();for(;n!==void 0&&n.getScope()!==void 0;){n=n.getScope();const s=n.getUserDefinedFunctions();for(const[o,u]of s)e.set(o,u);n=n.getParentBlock()}return e}findAllModules(){const e=new Map(this.getModuleMap());let n=this.getParentBlock();for(;n!==void 0&&n.getScope()!==void 0;){n=n.getScope();const s=n.getModuleMap();for(const[o,u]of s)e.set(o,u);n=n.getParentBlock()}return e}}yi=new WeakMap,Fi=new WeakMap;class Wc extends En{constructor(e,n){super(t.ClassDefinition,e,n.getIndentation());I(this,ln);y(this,ln,n.getFirstExpression().getDataType()),e.getScope().addUserDefinedClass(c(this,ln)),this.addStatement(n)}getClassType(){return c(this,ln)}toTree(){const e=this.getStatements();return{id:this.getId(),definition:e.length>0?e[0].toJSON():{},statements:e.slice(1).map(n=>n.toJSON())}}}ln=new WeakMap;const Es=class Es extends En{constructor(e,n){super(t.FunctionDefinition,e,n.getIndentation());I(this,Us);I(this,Ti);I(this,zn);const s=n.getFirstExpression(),o=s.getEntity()===t.FunctionDefinitionStatement?s.getFunctionNameExpression():s.getMethodNameExpression();if(y(this,zn,o!==void 0?o.getTextValue():"not parsed"),e.getScope().addUserDefinedFunction(o),s.is(t.MethodDefinitionStatement)&&s.getClassVar()&&e.getBlockEntity()===t.ClassDefinition){const f=e.getStatements()[0].getFirstExpression().getDataType();s.getClassVar().setDataType(f)}this.addStatement(n),this.addRules([m(this,Us,Zr)])}getReturnType(){const n=this.getLastExecutedStatements().filter(s=>!s.isBlank()&&s.getFirstExpression().is(t.ReturnStatement)).map(s=>s.getFirstExpression().getDataType());return this.alwaysReturnsAValue()||n.push(d.None),Nt(n)}getFunctionName(){return c(this,zn)}getFunctionExpression(){const e=this.getStatements();if(e.length>0&&e[0].getFirstExpression().is(t.FunctionDefinitionStatement))return e[0].getFirstExpression().getFunctionNameExpression()}toTree(){const e=this.getStatements();return{id:this.getId(),definition:e.length>0?e[0].toJSON():{},statements:e.slice(1).map(n=>n.toJSON())}}};Ti=new WeakMap,zn=new WeakMap,Us=new WeakSet,Zr=function(e){var o;const n=[],s=e.getFunctionExpression();if(s!==void 0){const u=e.getStatements(),f=m(o=Es,Qn,vi).call(o,u);f.length>0&&n.push(M.createStatementSymptom(b.FunctionPrints,[s],0,0,{printLines:f,functionReturns:s.getReturnType()!==d.None}))}return n},Qn=new WeakSet,vi=function(e){let n=[];for(let s=0;s<e.length;s++)if(e[s].isBlockStatement())n=n.concat(m(this,Qn,vi).call(this,e[s].getStatements()));else{const o=e[s].getFirstExpression();o.is(t.BuiltInFunctionCall)&&o.getFunctionEntity()===t.PrintFunction?n.push({lineNumber:o.getStartLineNumber(),followsReturn:s>0&&e[s].getFirstExpression().is(t.ReturnStatement),precedesReturn:s<e.length-1&&e[s+1].getFirstExpression().is(t.ReturnStatement),isReturned:!1,isEndOfExitBranch:s===e.length-1,blockId:o.getBlockId()}):o.is(t.ReturnStatement)&&o.getExpressionsOfKind(t.PrintFunction).length>0&&n.push({lineNumber:o.getStartLineNumber(),followsReturn:!1,precedesReturn:!1,isReturned:!0,isEndOfExitBranch:s===e.length-1,blockId:o.getBlockId()})}return n},I(Es,Qn);let di=Es;class qc extends En{constructor(i,e){super(t.ListComprehension,i);const n=new Mt(e.getTextValue(),e.getStartLineNumber(),new Nr(""),[e]);this.addStatement(n)}getId(){const i=this.getStatements();return`${super.getId()}-${i.length>0&&!i[0].isBlank()?i[0].getFirstExpression().getDocumentStartIndex():"-1"}`}}class Or extends Cr{constructor(e,n){const s=n.getFirstExpression().getBlockEntity();if(s===t.DocumentDefinition||s===t.FunctionDefinition||s===t.ClassDefinition||s===t.ListComprehension)throw new Error(`${s.name} is a scope block`);super(s,e,n.getIndentation());I(this,q);l(this,"conditionalSiblings",new Set);this.addStatement(n),this.addRules([m(this,q,eo),m(this,q,no),m(this,q,_r),m(this,q,to)])}isScopeBlock(){return!1}isBranchBlock(){return!0}getLastExecutedStatements(){let e=[];for(let s of this.getChildBlocks())e=e.concat(s.getLastExecutedStatements());const n=m(this,q,tt).call(this);for(let s=0;s<n.length;s++)if(!n[s].isBlockStatement()){if(s===n.length-1&&this.isBranchOfExhaustiveConditional())e.push(n[s]);else if(!n[s].isBlank()&&n[s].getFirstExpression().isOneOf([t.ReturnStatement,t.BreakKeyword])){e.push(n[s]);break}}return e}hasTopLevelReturn(){const e=m(this,q,tt).call(this);for(let n of e)if(!n.isBlockStatement()&&!n.isBlank()&&n.getFirstExpression().is(t.ReturnStatement))return!0;return!1}hasTopLevelExit(){const e=m(this,q,tt).call(this);for(let n of e)if(!n.isBlockStatement()&&!n.isBlank()&&n.getExpressions().filter(s=>Xt(s)).length>0)return!0;return!1}isBranchOfConditional(){return this.getBlockEntity()===t.IfDefinition||this.getBlockEntity()===t.ElifDefinition||this.getBlockEntity()===t.ElseDefinition||this.getBlockEntity()===t.TryDefinition||this.getBlockEntity()===t.ExceptDefinition||this.getBlockEntity()===t.FinallyDefinition}isBranchOfExhaustiveConditional(){if(this.getBlockEntity()===t.ElseDefinition)return m(this,q,Os).call(this,t.IfDefinition);if(this.getBlockEntity()===t.ElifDefinition){let e=!1,n=!1;for(const s of this.conditionalSiblings)if(s.getBlockEntity()===t.IfDefinition?e=!0:s.getBlockEntity()===t.ElseDefinition&&(n=!0),e&&n)return!0}else{if(this.getBlockEntity()===t.IfDefinition)return m(this,q,Os).call(this,t.ElseDefinition);if(this.getBlockEntity()===t.TryDefinition)return m(this,q,Os).call(this,t.ExceptDefinition);if(this.getBlockEntity()===t.ExceptDefinition)return m(this,q,Os).call(this,t.TryDefinition)}return!1}getSiblingConditionalBranches(){return this.conditionalSiblings}addSibling(e){if(!this.isBranchOfConditional())throw new Error("Cannot add a sibling to a branch that is not a conditional");if(!e.isBranchOfConditional())throw new Error("Trying to add a non-conditional branch as a sibling.");this.conditionalSiblings.add(e)}}q=new WeakSet,tt=function(){const e=this.getStatements();return e.length,e[0].getStatements()},Os=function(e){for(const n of this.conditionalSiblings)if(n.getBlockEntity()===e)return!0;return!1},Yr=function(){const e=m(this,q,tt).call(this).flatMap(s=>s.getExpressions());return oe(e,!0)},_r=function(e){return[]},eo=function(e){var s;const n=[];if(e.getBlockEntity()===t.ForDefinition||e.getBlockEntity()===t.WhileDefinition&&e.hasTopLevelExit())for(const o of m(s=e,q,tt).call(s))!o.isBlockStatement()&&!o.isBlank()&&Xt(o.getFirstExpression())&&n.push(M.createStatementSymptom(b.LoopReturn,[o.getFirstExpression()],0,0,{loopType:e.getBlockEntity().name,exitLevel:oc,exitTypes:[o.getFirstExpression().isOneOf([t.ReturnKeyword,t.ReturnStatement])?"return":o.getFirstExpression().getTextValue()]},e.getId()));else if(e.isBranchOfExhaustiveConditional()&&e.getBlockEntity()===t.IfDefinition&&e.hasTopLevelExit()&&(e.getParentBlock()!==void 0&&e.getParentBlock().getBlockEntity()===t.ForDefinition||e.getParentBlock().getBlockEntity()===t.WhileDefinition)){for(const g of e.getSiblingConditionalBranches())if(!g.hasTopLevelExit())return n;const u=e.getParentBlock().getStatements()[0].getExpressions(),f=u.flatMap(g=>g.getExpressionsOfKind(t.ReturnKeyword).concat(g.getExpressionsOfKind(t.BreakKeyword),g.getExpressionsOfKind(t.ExitFunction),g.getExpressionsOfKind(t.SysExit),g.getExpressionsOfKind(t.QuitFunction))).map(g=>g.getTextValue());n.push(M.createStatementSymptom(b.LoopReturn,[u[0]],0,0,{loopType:e.getParentBlock().getBlockEntity().name,exitLevel:ac,exitTypes:f},e.getParentBlock().getId()))}return n},to=function(e){var s,o;const n=[];if(e.getBlockEntity()===t.WhileDefinition){const u=m(s=e,q,tt).call(s)[0].getFirstExpression(),f=new Set(u.getVariableExpressions().map(F=>F.getTextValue())),g=m(o=e,q,tt).call(o).slice(1),w=new Map,S=new Map;for(const F of f)w.set(F,!1),S.set(F,[]);for(const F of g)for(const T of F.getExpressions()){const R=T.getExpressionsOfKind(t.ChangeStatement).flatMap(O=>O.getTargetVariables()).filter(O=>f.has(O.getTextValue())),k=T.getExpressionsOfKind(t.AssignmentStatement).flatMap(O=>O.getTargetVariables()).filter(O=>f.has(O.getTextValue()));for(const O of R)w.has(O.getTextValue())&&w.set(O.getTextValue(),!0);for(const O of k)S.has(O.getTextValue())&&S.get(O.getTextValue()).push(O)}for(const F of f)if(!w.get(F)&&S.get(F).length>0){let T=[],R=!1;for(const k of S.get(F)){const O=k.getParent().getAssignedValues();if(O.length===1&&O[0].is(t.IntLiteral))T.push(k);else{R=!0;break}}if(!R)for(const k of T)n.push(M.createStatementSymptom(b.WhileLoopVarAssignedIntLiteral,[k],0,0))}}return n},no=function(e){var s,o,u;const n=[];if(e.getBlockEntity()===t.WhileDefinition){const f=m(s=e,q,tt).call(s)[0].getFirstExpression(),g=new Set(f.getVariableExpressions());if(g.size>0){const w=m(o=e,q,Ri).call(o,g),S=new Set,F=new Map;for(const T of g){const R=w.get(T);for(const k of R){k===e&&S.add(T);const O=k.getNearestParentOfAny([t.WhileDefinition,t.ForDefinition]);O!==void 0&&O!==e&&e.hasChild(O)?(F.has(T)||F.set(T,new Set),F.get(T).add(O)):O!==void 0&&O===e&&S.add(T)}}S.size===0&&n.push(M.createStatementSymptom(b.LoopVarNotModified,[f],0,0,{unmodifiedVars:Array.from(g).map(T=>T.getTextValue()),loopText:m(u=e,q,Yr).call(u)},e.getId()));for(const[T,R]of F){const k=M.createStatementSymptom(b.LoopVarModifiedInChildLoop,[T],0,0,{modifiedIn:[],varDataType:[]},e.getId());for(const O of R)k.getAdditionalInfo().modifiedIn.push({loopType:O.getBlockEntity().name,startLine:O.getStatements()[0].getFirstLineNumber(),varDataType:T.getDataType().name});n.push(k)}}}return n},Ri=function(e){var o;const n=m(this,q,tt).call(this).filter(u=>!u.isBlockStatement()),s=new Map;for(const u of e)s.set(u,new Set);for(const u of n){const f=u.getExpressions();for(const g of f){const w=g.getVariableExpressions().filter(F=>F.isAssignedOrChanged()),S=new Set(w.map(F=>F.getTextValue()));for(const F of e)S.has(F.getTextValue())&&s.get(F).add(this)}}for(const u of this.getChildBlocks().filter(f=>f.isBranchBlock())){const f=m(o=u,q,Ri).call(o,e);for(const g of e)f.get(g).size>0&&s.get(g).add(...f.get(g))}return s};class Gn{constructor(i,e,n,{multilineCommentDelimiter:s=void 0,stringLiteralDelimiter:o=void 0,groupCharCounts:u={"(":0,"[":0,"{":0},lastLineExpressions:f=[],startFrom:g=0,moduleNames:w=[],varsWithTypeNames:S=[],classDefinitionInProgress:F=!1}={}){I(this,N);I(this,ee,[]);I(this,Vt,[]);I(this,Xn,!1);I(this,cn,!1);I(this,qe);I(this,Te);I(this,G);I(this,vt);I(this,Zn);I(this,Be);I(this,Re);I(this,ge);I(this,pt);I(this,Ni,[]);y(this,G,i),y(this,pt,c(this,G).length-1),y(this,Be,e),y(this,Re,n),y(this,qe,s),y(this,Te,o),y(this,ge,u),y(this,vt,m(this,N,io).call(this,i)),y(this,Zn,new Nr(i.substring(0,c(this,vt)))),y(this,Vt,f),c(this,G).length>0?m(this,N,so).call(this,g>0?g:c(this,vt),S,w,F):m(this,N,Ui).call(this)}getText(){return c(this,G)}getLineNumber(){return c(this,Be)}getExpressions(){return c(this,ee)}getDocumentStartIndex(){return c(this,Re)}getLineEndIndex(){return c(this,pt)}getIndentation(){return c(this,vt)}getIndent(){return c(this,Zn)}continuesOnNextLine(){return c(this,Xn)}followedBySeparateStatement(){return c(this,cn)}hasOpenComment(){return c(this,qe)!==void 0}getCommentDelimiter(){if(!this.hasOpenComment())throw new Error("This line of source code does not have an open multiline comment delimiter. Line",c(this,Be));return c(this,qe)}hasOpenString(){return c(this,Te)!==void 0}getStringLiteralDelimiter(){if(!this.hasOpenString())throw new Error("This line of source code does not have an open string literal delimiter. Line",c(this,Be));return c(this,Te)}hasOpenGroupChars(){return Object.entries(c(this,ge)).filter(([i,e])=>e>0).length>0}getOpenGroupChars(){return c(this,ge)}}ee=new WeakMap,Vt=new WeakMap,Xn=new WeakMap,cn=new WeakMap,qe=new WeakMap,Te=new WeakMap,G=new WeakMap,vt=new WeakMap,Zn=new WeakMap,Be=new WeakMap,Re=new WeakMap,ge=new WeakMap,pt=new WeakMap,Ni=new WeakMap,N=new WeakSet,so=function(i,e,n,s){c(this,qe)!==void 0?i=m(this,N,Ei).call(this,c(this,qe),0)+1:c(this,Te)!==void 0&&(i=m(this,N,Gi).call(this,B.getCategory(c(this,Te).charCodeAt(0)),0)+1);for(let o=i;o<c(this,G).length;o++){const u=B.getCategory(c(this,G).charCodeAt(o));if(u===B.Hash)o=c(this,G).length-1;else if(u.isQuote())o=m(this,N,oo).call(this,u,o);else if(m(this,N,uo).call(this,u))o=m(this,N,ho).call(this,o,e,n,s);else if(m(this,N,bo).call(this,u,o,o===0||B.getCategory(c(this,G).charCodeAt(o-1))===B.Space))o=m(this,N,Fo).call(this,o);else if(m(this,N,To).call(this,u))o=m(this,N,No).call(this,o);else if(m(this,N,Co).call(this,u)&&(m(this,N,Oo).call(this,o),o<c(this,pt)&&m(this,N,Mo).call(this,u))){y(this,pt,o),m(this,N,ro).call(this);break}}m(this,N,Ui).call(this)},io=function(i){return Math.max(i.search(/\S/),0)},Ui=function(){(c(this,qe)!==void 0||c(this,Te)!==void 0||this.hasOpenGroupChars()||m(this,N,ze).call(this)&&m(this,N,xe).call(this).isOneOf([t.ContinuationLine,t.AddOperator,t.Comma]))&&y(this,Xn,!0)},ro=function(){const i=c(this,G).substring(c(this,pt)+1).trim();i.length===0||B.getCategory(i.charCodeAt(0))===B.Hash?y(this,cn,!1):y(this,cn,!0)},jt=function(i){for(let e of c(this,ee))if(e.is(i))return!0;return!1},ze=function(){return c(this,ee).length>0},xe=function(){if(c(this,ee).length===0)throw new Error("Attempted to get last expression when there are no expressions.");return c(this,ee)[c(this,ee).length-1]},oo=function(i,e){return m(this,N,co).call(this,i,e)?m(this,N,ao).call(this,e):m(this,N,Gi).call(this,i,e)},ao=function(i){const e=c(this,G).substring(i,i+3);let n=i+3;return m(this,N,Ei).call(this,e,n)},Ei=function(i,e){if(e<c(this,G).length){const s=m(this,N,$i).call(this,c(this,G)).substring(e).indexOf(i);if(s>-1)return y(this,qe,void 0),e+s+2}return y(this,qe,i),c(this,G).length-1},Gi=function(i,e){const n=m(this,N,$i).call(this,c(this,G)),s=c(this,Te)===void 0?m(this,N,lo).call(this,i,e,n):c(this,Te);let o=c(this,Te)===void 0?e+s.length:e,u=o+n.substring(o).indexOf(s);u===-1||u<o?(y(this,Te,s),u=c(this,G).length):y(this,Te,void 0);const f=Math.min(c(this,G).length-1,u+s.length-1),g=c(this,G).substring(e,f+1),w=new Dr(g,c(this,Be),c(this,Re)+e,e,c(this,Re)+f);if(m(this,N,ze).call(this)&&m(this,N,xe).call(this).is(t.F)){const S=[m(this,N,xe).call(this),w],F=new tu(oe(S),S);c(this,ee)[c(this,ee).length-1]=F}else c(this,ee).push(w);return f},lo=function(i,e,n){const s=i===B.SingleQuote?"'":'"';return e<n.length-2&&B.getCategory(n.charCodeAt(e))===i&&B.getCategory(n.charCodeAt(e+1))===i&&B.getCategory(n.charCodeAt(e+2))===i?s+s+s:s},$i=function(i){return i.replace(/\\.{1}/g,"  ")},co=function(i,e){return m(this,N,ze).call(this)&&m(this,N,xe).call(this).is(t.AssignmentOperator)||c(this,ge)["("]>0||c(this,ge)["["]>0||c(this,ge)["{"]>0?!1:i.isQuote()&&c(this,G).length>e+2&&B.getCategory(c(this,G).charCodeAt(e))===i&&B.getCategory(c(this,G).charCodeAt(e+1))===i&&B.getCategory(c(this,G).charCodeAt(e+2))===i},uo=function(i){return i===B.Underscore||i===B.Letter},ho=function(i,e,n,s){let o=m(this,N,fo).call(this,i),u=m(this,N,go).call(this,o,m(this,N,Io).call(this,i+o.length),e,n,s);const f=$n(o,u,c(this,Be),c(this,Re)+i,i);return m(this,N,ze).call(this)&&(u.entity===t.InKeyword&&m(this,N,xe).call(this).is(t.NotOperator)||u.entity===t.NotOperator&&m(this,N,xe).call(this).is(t.IsKeyword))?(o=oe([m(this,N,xe).call(this),f]),u=new Z(u.entity===t.InKeyword?t.NotInKeyword:t.IsNotKeyword,a.ComparisonOperators),i=m(this,N,xe).call(this).getDocumentStartIndex()-c(this,Re),c(this,ee)[c(this,ee).length-1]=$n(o,u,c(this,Be),m(this,N,xe).call(this).getDocumentStartIndex())):c(this,ee).push(f),i+o.length-1},fo=function(i){let e=i;for(let n=i+1;n<c(this,G).length;n++){const s=B.getCategory(c(this,G).charCodeAt(n));if(s===B.Underscore||s===B.Letter||s===B.Digit)e=n;else break}return c(this,G).substring(i,e+1)},go=function(i,e,n,s,o){const u=We(i);if(m(this,N,ze).call(this)){const f=m(this,N,xe).call(this);if(f.is(t.FunctionDefinition))return o?new Z(t.MethodName,a.Identifiers):new Z(t.FunctionName,a.Identifiers);if(f.is(t.ClassDefinition))return new Z(t.ClassName,a.Identifiers);if(f.is(t.FromKeyword)||m(this,N,jt).call(this,t.ImportKeyword)&&!m(this,N,jt).call(this,t.FromKeyword))if(f.is(t.AsKeyword)&&c(this,ee).length>1){const g=c(this,ee)[c(this,ee).length-2];return new Z(g.getEntity(),g.getCategory())}else return u.entity===t.Unknown?new Z(t.ModuleName,a.Identifiers):u;else{if(m(this,N,vn).call(this)&&e!=="(")return u.category===a.Unknown?new Z(t.PropertyName,a.ModuleProperties):u;if(m(this,N,jt).call(this,t.FromKeyword)&&m(this,N,jt).call(this,t.ImportKeyword))return m(this,N,So).call(this,i);if((i==="sep"||i==="end")&&!(f.is(t.Comma)&&e==="="))return new Z(t.VariableName,a.Identifiers);if(u.entity!==t.VariableName&&uc(i)&&m(this,N,jt).call(this,t.FunctionDefinition)&&f.isOneOf([t.OpenParenthesis,t.Comma]))return new Z(t.VariableName,a.Identifiers)}}else if(i==="sep"||i==="end")return new Z(t.VariableName,a.Identifiers);return e===t.OpenParenthesis.name?m(this,N,po).call(this,u,i):(u.entity===t.R||u.entity===t.F)&&e!=="'"&&e!=='"'?new Z(t.VariableName,a.Identifiers):u.category===a.Types&&n.includes(i)?new Z(t.VariableName,a.Identifiers):u.category===a.BuiltInModules&&!s.includes(i)?new Z(t.VariableName,a.Identifiers):u.category===a.BuiltInFunctions&&Ir(i).entity!==t.Unknown&&e!=="="?n.includes(i)?new Z(t.VariableName,a.Identifiers):Ir(i):u.category===a.OtherKeywords||u.category===a.BlockDefinitions||u.category===a.LogicalOperators||u.category===a.BuiltInExceptions||u.category===a.BuiltInModules||u.category===a.Types||u.category===a.SpecialVariables||u.category===a.ComparisonOperators?u:u.category===a.Unknown&&s.includes(i)?new Z(t.ModuleName,a.Identifiers):new Z(t.VariableName,a.Identifiers)},po=function(i,e){return m(this,N,mo).call(this,i)||m(this,N,wo).call(this,i)?i:i.entity===t.Format?m(this,N,vn).call(this)?new Z(t.Format,a.BuiltInMethods):new Z(t.FormatFunction,a.BuiltInFunctions):m(this,N,vn).call(this)?e==="exit"?ci[e]:new Z(t.MethodName,a.OtherMethods):ci.hasOwnProperty(e)?ci[e]:i.category!==a.BuiltInFunctions&&i.category!==a.BuiltInMethods&&i.category!==a.Unknown&&i.category!==a.ModuleFunctions?i:new Z(t.FunctionName,a.Identifiers)},mo=function(i){return i.category===a.BuiltInFunctions&&!m(this,N,vn).call(this)},wo=function(i){return(i.category===a.BuiltInMethods||i.category===a.MagicMethods||i.category===a.ModuleFunctions)&&m(this,N,vn).call(this)},vn=function(){return m(this,N,ze).call(this)&&m(this,N,xe).call(this).is(t.Dot)||!m(this,N,ze).call(this)&&c(this,Vt).length>0&&c(this,Vt)[c(this,Vt).length-1].is(t.Dot)},So=function(i){if(c(this,ee).length>=2&&c(this,ee)[1].is(a.BuiltInModules)){let e=We(i);if(e.category===a.ModuleFunctions||e.category===a.ModuleProperties){const n=yr.has(e.entity)?yr.get(e.entity):void 0;return n&&m(this,N,jt).call(this,n)?e:new Z(t.NamedImport,a.Identifiers)}return e.entity===t.Unknown?new Z(t.NamedImport,a.Identifiers):e}return new Z(t.NamedImport,a.Identifiers)},Cd=function(i,e){return new Z(t.ModuleName,a.Identifiers)},Io=function(i){for(;B.getCategory(c(this,G).charCodeAt(i))===B.Space;)i++;return c(this,G).charAt(i)},bo=function(i,e,n){if(i===B.Minus&&m(this,N,ze).call(this)&&!n&&m(this,N,xe).call(this).isOneOf([a.Identifiers,t.CloseBrace,t.CloseParenthesis,t.CloseSquareBracket]))return!1;let s=0,o=0,u=0,f=e;for(;f<c(this,G).length&&(i===B.Digit||i===B.Decimal||i===B.Minus&&f===e);)i===B.Digit?s++:i===B.Decimal?o++:u++,f++,i=B.getCategory(c(this,G).charCodeAt(f));return s>=1&&o<=1&&u<=1},yo=function(i){let e=i;for(let n=i+1;n<c(this,G).length;n++){const s=B.getCategory(c(this,G).charCodeAt(n));if(s===B.Digit||s===B.Decimal)e=n;else break}return c(this,G).substring(i,e+1)},Fo=function(i){const e=m(this,N,yo).call(this,i);return c(this,ee).push(new hi(e,c(this,Be),c(this,Re)+i,i)),i+e.length-1},To=function(i){return i===B.Equals||i===B.Exclamation||i===B.Minus||i===B.Plus||i===B.Asterisk||i===B.ForwardSlash||i===B.Modulo||i===B.GreaterThan||i===B.LessThan},No=function(i){let e=c(this,G).charAt(i),n=e,s=i;for(;(n==="!"||We(n).entity!==t.Unknown)&&s<c(this,G).length;)e=n,s++,n+=c(this,G).charAt(s);let o=We(e);return e==="*"&&m(this,N,ze).call(this)&&m(this,N,xe).call(this).is(t.ImportKeyword)&&(o=new Z(t.ImportAll,a.OtherKeywords)),c(this,ee).push($n(e,o,c(this,Be),c(this,Re)+i,i)),i+e.length-1},Co=function(i){return i!==B.Space&&i!==B.Tab},Oo=function(i){let e=c(this,G).charAt(i);m(this,N,xo).call(this,e);const n=We(e);c(this,ee).push($n(e,n,c(this,Be),c(this,Re)+i,i))},Mo=function(i){return i===B.Semicolon?!0:!!(i===B.Colon&&m(this,N,ze).call(this)&&c(this,ee)[0].isOneOf([t.IfDefinition,t.ElifDefinition,t.ElseDefinition,t.FunctionDefinition,t.ClassDefinition,t.ForDefinition,t.WhileDefinition,t.TryDefinition,t.ExceptDefinition])&&c(this,ge)["{"]<=0&&c(this,ge)["("]<=0&&c(this,ge)["["]<=0)},xo=function(i){c(this,ge).hasOwnProperty(i)?c(this,ge)[i]++:i===")"?c(this,ge)["("]--:i==="]"?c(this,ge)["["]--:i==="}"&&c(this,ge)["{"]--};const Yn=class Yn{static createTree(i){let e=i.filter(n=>!n.is(t.ContinuationLine));return m(this,x,ko).call(this,i)?[m(this,x,Lo).call(this,i)]:(e.length>1&&(e=m(this,x,Ko).call(this,e),e=m(this,x,Jo).call(this,e),e=m(this,x,vo).call(this,e),e=m(this,x,$o).call(this,e),e=m(this,x,Wo).call(this,e),e=m(this,x,qo).call(this,e),e=m(this,x,jo).call(this,e),e=m(this,x,Ho).call(this,e),e=m(this,x,zo).call(this,e),e=m(this,x,Xo).call(this,e)),e)}static split(i,e){return this.splitMultiple(i,[e])}static splitMultiple(i,e){const n=[];let s=0,o=0,u=0,f=0;for(let g=0;g<i.length;g++)if(g===f&&i[g].isOneOf(e))f++;else if(i[g].isOneOf(e)&&g>f||g===i.length-1){if(s===0&&o===0&&u===0||g===i.length-1&&(s===1&&i[g].is(t.CloseParenthesis)||u===1&&i[g].is(t.CloseSquareBracket)||o===1&&i[g].is(t.CloseBrace))){const w=i.slice(f,i[g].isOneOf(e)?g:g+1);n.push(w),f=g+1}}else i[g].is(t.OpenParenthesis)?s++:i[g].is(t.CloseParenthesis)?s--:i[g].is(t.OpenBrace)?o++:i[g].is(t.CloseBrace)?o--:i[g].is(t.OpenSquareBracket)?u++:i[g].is(t.CloseSquareBracket)&&u--;return n}static connectVariableUsages(i,e){var w,S;const n=e.getScope();!i.isBlank()&&i.getFirstExpression().is(t.ImportStatement)&&m(w=Yn,x,Ao).call(w,i,n),i.isBlockStatement()&&!i.isBlank()&&i.getFirstExpression().is(t.ForDefinitionStatement)&&(e=m(S=Yn,x,Bo).call(S,e));const s=i.getVariableUsages(),o=n.getVariableMap(),u=n.findAllModules(),f=new Map(Array.from(u.values()).flatMap(F=>Array.from(F.getDirectImports()))),g=!i.isBlank()&&i.getFirstExpression().is(t.GlobalStatement);for(let[F,T]of s){if(e.getBlockEntity()===t.ClassDefinition&&T.length>0&&(T[0].getParent()===void 0||T[0].getParent().is(t.AssignmentStatement)&&T[0].getParent().getTargetVariables().includes(T[0]))){m(this,x,Ji).call(this,T[0],e.getClassType(),i,e,n);continue}let R=T.map(k=>new Tr(k,e,g));if(g&&n.addGlobalVar(F),o.has(F)){o.get(F).addUsages(R);for(const k of R){const O=k.getVariable().getParent();if(O&&O.is(t.PropertyCallExpression)&&O.getObject().getDataType().isCustom){const qt=O.getObject().getDataType();m(this,x,Ji).call(this,O.getProperty(),qt,i,e,n)}}}else{if(u.has(F))R[0].getVariable().setDataType(xs(u.get(F).getEntity()));else if(f.has(F)){const O=Ot.has(f.get(F).entity)?Ot.get(f.get(F).entity):d.Unknown;R[0].getVariable().setDataType(O)}const k=new Fr(R[0],i,e);if(R.length>1&&k.addUsages(R.slice(1)),m(this,x,Do).call(this,e,F,k.getUsages()[0].getVariable())&&this.checkIfVariableExistsInParent(k,e))continue;o.set(F,k)}}}static makeGraphConnections(i){const e=i.filter(s=>!s.isBlank());if(e.length<=1)return;const n=e[e.length-1];if(!n.isBlank()){let s=e[e.length-2],o;if(s.isBlockStatement()){o=s.getDefinitionStatement().getExpressions();let u=s.getFirstExpression(),f=n.getFirstExpression();if(!(u.isOneOf([t.IfDefinitionStatement,t.ElifDefinitionStatement])&&f.isOneOf([t.ElseDefinitionStatement,t.ElifDefinitionStatement]))){const g=s.getExpressions();g[g.length-1].addConnection(n.getFirstExpression());const w=s.getStatements();w.length>1&&w[w.length-1].isBlockStatement()&&w[w.length-1].getDefinitionStatement().getFirstExpression().addConnection(n.getFirstExpression())}if(!f.isOneOf([t.ElifDefinitionStatement,t.ElseDefinitionStatement,t.ReturnStatement])&&u.isOneOf([t.IfDefinitionStatement,t.ElifDefinitionStatement,t.ElseDefinitionStatement])){const g=[];for(let w=e.length-2;w>=0;w--){const S=e[w].getFirstExpression();if(S.isOneOf([t.IfDefinitionStatement,t.ElifDefinitionStatement,t.ElseDefinitionStatement])&&(g.push(e[w]),S.is(t.IfDefinitionStatement)))break}for(const w of g)try{const S=w.getStatements();S[S.length-1].getFirstExpression().addConnection(n.getFirstExpression())}catch(S){console.log(S),console.log(w)}}}else o=s.getExpressions();o[0].addConnection(n.getFirstExpression())}}static connectUserDefinedFunctions(i,e){const n=e.findAllFunctions(),s=e.getRootBlock().getUserDefinedClasses(),o=i.getExpressions();for(let u of o){const f=u.getExpressionsOfKind(t.UserDefinedFunctionCall);for(let g of f){const w=g.getFunctionName();if(n.has(w)){const S=n.get(w);g.setDataType(S.getDataType()),S.addObserver(g)}else if(s.has(w)){const S=s.get(w);g.setDataType(S)}else e.addUnconnectedFunctionCall(g)}}}static connectUserDefinedMethods(i,e){const n=e.findAllFunctions();for(const[o,u]of n.entries())u.is(t.MethodName)||n.delete(o);const s=i.getExpressions();for(let o of s){const u=o.getExpressionsOfKind(t.UserDefinedMethodCall);for(let f of u){const g=f.getMethodName();if(n.has(g)){const w=n.get(g);f.setDataType(w.getDataType()),w.addObserver(f)}else e.addUnconnectedMethodCall(f)}}}static checkIfVariableExistsInParent(i,e){let n=e.getScope().getParentBlock();const s=i.getUsages()[0].getVariable();if(!i.isParameter()&&(e.getScope().getGlobalVars().has(i.getName())||!s.isAssignedOrChanged()||s.isObjectOfMethodCall()||s.isSubscripted()))for(;n!==void 0&&n.getScope()!==void 0;){const o=n.getScope().getVariableMap();if(o.has(i.getName())){const u=o.get(i.getName());i.setDefinedInBlock(u.getDefinedInBlock());const f=u.getUsages();return i.insertUsages(f),!0}n=n.getScope().getParentBlock()}return!1}static checkForListComp(i){const e=this.split(i,t.Comma);let n=[];for(let s=0;s<e.length;s++)s<e.length-1&&Un(e[s],t.ForDefinition)&&Un(e[s+1],t.InKeyword)?(n.push(e[s].concat(i[n.length+e[s].length],e[s+1])),s++):n.push(e[s]);return n}};x=new WeakSet,Ji=function(i,e,n,s,o){const u=i.getTextValue(),f=new Tr(i,s);if(e.attributes.has(u))e.attributes.get(u).addUsage(f);else{const g=o.getNearestParentOfAny([t.ClassDefinition]),w=new Fr(f,n,s);g&&g.getClassType().name===e.name?e.attributes.set(u,w):console.log("add to unconnected attribute tracking")}},Do=function(i,e,n){let s=i.getScope();for(;s!==void 0;){if(s.getVariableMap().has(e)){if(!n.isAssignedOrChanged()||n.isObjectOfMethodCall()||n.isSubscripted())return!0}else if(s.getGlobalVars().has(e))return!0;s=s.getParentBlock(),s!==void 0&&(s=s.getScope())}return!1},Bo=function(i){const e=i.getChildBlocks();return e.length>0&&e[e.length-1].getBlockEntity()===t.ForDefinition&&(i=e[e.length-1]),i},Ao=function(i,e){const n=i.getRawExpressions(),s=e.getModuleMap(),o=[];let u=!1;for(const f of n)if(f.isOneOf([t.ModuleName,a.BuiltInModules]))if(u)for(const g of o)g.getEntity()===f.getEntity()&&g.setAlias(f.getTextValue());else{const g=new Jc(f.getTextValue(),f.getEntity());o.push(g)}else if(f.is(t.AsKeyword))u=f;else if(f.isOneOf([a.ModuleProperties,t.NamedImport]))for(const g of o)g.addDirectImport(f.getTextValue(),Kc(f.getEntity(),f.getCategory()));else if(f.is(t.ImportAll))for(const g of o)g.setImportAll();for(const f of o)s.set(f.getAlias(),f)},ko=function(i){return i.length>0&&i[0].is(a.BlockDefinitions)&&!m(this,x,Po).call(this,i)},Po=function(i){if(i.length===1)return!1;const e=Zt(i,t.AssignmentOperator);return e===-1?!1:e===1?!0:!!(i[1].is(t.Comma)&&e%2===1)},Lo=function(i){const e=oe(i);switch(i[0].getEntity()){case t.FunctionDefinition:return m(this,x,Vo).call(this,e,i);case t.IfDefinition:return new nt(e,i,t.IfDefinitionStatement);case t.ElifDefinition:return new nt(e,i,t.ElifDefinitionStatement);case t.WhileDefinition:return new nt(e,i,t.WhileDefinitionStatement);case t.ForDefinition:return new nt(e,i,t.ForDefinitionStatement);case t.ExceptDefinition:return new nt(e,i,t.ExceptDefinitionStatement);case t.ElseDefinition:return new nt(e,i,t.ElseDefinitionStatement);case t.TryDefinition:return new nt(e,i,t.TryDefinitionStatement);case t.FinallyDefinition:return new nt(e,i,t.FinallyDefinitionStatement);case t.ClassDefinition:return new zc(e,i);case t.LambdaDefinition:return new du(e,i);case t.WithKeyword:return new nt(e,i,t.WithDefinitionStatement);default:return i}},Vo=function(i,e){return e.length<2||e[1].is(t.FunctionName)?new jc(i,e):new Hc(i,e)},vo=function(i){let e=m(this,x,Ki).call(this,i);if(e.sort((o,u)=>o[0]-u[0]),e.length===0)return i;let n=i,s;for(;e.length>0&&(s===void 0||e.length!==s.length);){const o=n[e[0][0]];o.is(t.OpenParenthesis)?n=m(this,x,Ro).call(this,e[0],n):o.is(t.OpenSquareBracket)?n=m(this,x,Uo).call(this,e[0],n):n=m(this,x,Go).call(this,e[0],n),s=e,e=m(this,x,Ki).call(this,n),e.sort((u,f)=>u[0]-f[0])}return n},Ki=function(i){let e=[],n=[];for(let s=0;s<i.length;s++)if(Sr(i[s].getEntity()))n.push({openEntity:i[s].getEntity(),closeEntity:fc(i[s].getEntity()),openIndex:s,closeIndex:-1});else if(hc(i[s].getEntity())){let o=n.length-1;for(;o>=0;){if(n[o].closeEntity===i[s].getEntity()){n[o].closeIndex=s,e.push([n[o].openIndex,n[o].closeIndex]),n.splice(o,1);break}o--}}return e},Ro=function(i,e){const n=i[0],s=i[1];if(n>0&&e[n-1].isOneOf([a.BuiltInFunctions,t.FunctionName])){const u=e[n-1].is(a.BuiltInFunctions)?t.BuiltInFunctionCall:t.UserDefinedFunctionCall,f=m(this,x,fe).call(this,e.slice(n-1,s+1),u);return e.slice(0,n-1).concat([f],e.slice(s+1))}else if(n>2&&e[n-1].isOneOf([a.BuiltInMethods,t.MethodName,a.MagicMethods,a.ModuleFunctions])&&e[n-2].is(t.Dot)){const u=e[n-1].is(t.MethodName)?t.UserDefinedMethodCall:t.BuiltInMethodCall,f=m(this,x,fe).call(this,e.slice(n-3,s+1),u);return e.slice(0,n-3).concat([f],e.slice(s+1))}else if(n>0&&e[n-1].is(t.ExceptionName)){const u=m(this,x,fe).call(this,e.slice(n-1,s+1),t.ExceptionCall);return e.slice(0,n-1).concat([u],e.slice(s+1))}else if(s>n+1){const u=e.slice(n+1,s),f=this.split(u,t.Comma);if(f.length>1){const g=m(this,x,fe).call(this,e.slice(n,s+1),t.TupleDefinition,f);return e.slice(0,n).concat([g],e.slice(s+1))}}const o=m(this,x,fe).call(this,e.slice(n,s+1),t.GroupStatement);return e.slice(0,n).concat([o],e.slice(s+1))},Uo=function(i,e){const n=i[0],s=i[1];let o=[],u=[];if(s>n+1&&(u=e.slice(n+1,s),o=this.checkForListComp(u)),n===0||o.length===0||e[n-1].isOneOf([a.ComparisonOperators,a.LogicalOperators,a.MathsOperators,t.OpenParenthesis,t.OpenSquareBracket,t.OpenBrace,t.Comma,t.Colon,t.Separator,a.OtherKeywords,t.ContinuationLine])){const f=m(this,x,fe).call(this,e.slice(n,s+1),t.ListDefinition,o);return e.slice(0,n).concat([f],e.slice(s+1))}else{let f=this.split(u,t.Colon);const g=m(this,x,Eo).call(this,f,e,n,s)?m(this,x,fe).call(this,e.slice(n,s+1),t.Slice,f):m(this,x,fe).call(this,e.slice(n,s+1),t.IndexKey);let w=n-1;for(;w>=0&&!e[w].isOneOf([a.Identifiers,a.BuiltInFunctions,a.CompoundTypes,t.BuiltInFunctionCall,t.BuiltInMethodCall,t.UserDefinedFunctionCall,t.UserDefinedMethodCall,t.SubscriptedExpression,t.PropertyCallExpression]);)w--;w=Math.max(w,0);const S=m(this,x,fe).call(this,[...e.slice(w,n),g],t.SubscriptedExpression);return e.slice(0,w).concat([S],e.slice(s+1))}},Eo=function(i,e,n,s){return i.length>1||e[n+1].is(t.Colon)||e[s-1].is(t.Colon)},Go=function(i,e){const n=i[0],s=i[1];let o;if(s===n+1)o=m(this,x,fe).call(this,e.slice(n,s+1),t.DictDefinition);else{const u=e.slice(n+1,s),f=this.split(u,t.Comma),g=[];for(let w of f){const S=this.split(w,t.Colon);S.length===2&&g.push(S)}g.length===f.length?o=m(this,x,fe).call(this,e.slice(n,s+1),t.DictDefinition,g):o=m(this,x,fe).call(this,e.slice(n,s+1),t.SetDefinition,f)}return e.slice(0,n).concat([o],e.slice(s+1))},fe=function(i,e,n=[]){const s=oe(i);switch(e){case t.BuiltInFunctionCall:return new Qc(s,i);case t.UserDefinedFunctionCall:return new Xc(s,i);case t.BuiltInMethodCall:return new Yc(s,i);case t.UserDefinedMethodCall:return new _c(s,i);case t.ExceptionCall:return new Zc(s,i);case t.TupleDefinition:case t.ListDefinition:case t.SetDefinition:case t.DictDefinition:return new Vs(s,i,e,n);case t.GroupStatement:return new uu(s,i);case t.Slice:return new Vr(s,i,n);case t.IndexKey:return new vr(s,i);case t.SubscriptedExpression:return new vs(s,i);case t.CalculatedExpression:return new Rs(s,i);case t.ComparisonExpression:return new pi(s,i);case t.IteratorExpression:return new wi(s,i);case t.BooleanExpression:return new mi(s,i);default:throw new Error("Unknown multipart expression type")}},$o=function(i){let e=m(this,x,Wi).call(this,i);for(;e>-1;){const n=e>0&&!i[e-1].isOneOf([a.MathsOperators,a.LogicalOperators,a.ComparisonOperators,a.OtherKeywords])?e-1:e,s=m(this,x,fe).call(this,i.slice(n,e+2),t.CalculatedExpression);i=i.slice(0,n).concat([s],i.slice(e+2)),e=m(this,x,Wi).call(this,i)}return i},Jo=function(i){if(i.length<3)return i;let e=1;for(;e<i.length-1;)if(i[e].is(t.Dot)&&i[e+1].isOneOf([t.PropertyName,a.ModuleProperties])){const n=oe([i[e-1],i[e],i[e+1]]),s=new xr(n,[i[e-1],i[e],i[e+1]],t.PropertyCallExpression,a.MultipartValue);i=i.slice(0,e-1).concat([s],i.slice(e+2)),e--}else if(i[e].is(t.Dot)&&!i[e+1].isOneOf([t.PropertyName,a.ModuleProperties])&&(e+2>=i.length||!i[e+2].isOneOf([t.OpenParenthesis]))){const n=oe([i[e-1],i[e],i[e+1]]),s=new xr(n,[i[e-1],i[e],i[e+1]],t.PropertyCallExpression,a.MultipartValue);i=i.slice(0,e-1).concat([s],i.slice(e+2)),e--}else e++;return i},Ko=function(i){if(i.length<2)return i;let e=0;for(;e<i.length-1;)if(i[e].isStringLiteral()&&i[e+1].isStringLiteral()){const n=oe([i[e],i[e+1]]),s=new nu(n,[i[e],i[e+1]]);i=i.slice(0,e).concat([s],i.slice(e+2))}else e++;return i},Wi=function(i){const e=[],n=[];for(let s=0;s<i.length;s++){if(i[s].is(t.ExponentOperator))return s;i[s].isOneOf([t.MultiplyOperator,t.DivideOperator,t.IntDivideOperator,t.ModulusOperator])?e.push(s):i[s].isOneOf([t.AddOperator,t.SubtractOperator])&&n.push(s)}return e.length>0?e[0]:n.length>0?n[0]:-1},Wo=function(i){let e=m(this,x,qi).call(this,i);for(;e>0;){let n=e-1,s;i[e].is(t.InKeyword)&&n>1&&i[n-1].is(t.Comma)?(n=n-2,s=m(this,x,fe).call(this,i.slice(n,e+2),t.IteratorExpression)):i[e].is(t.InKeyword)&&e===1&&e+1<i.length&&i[e+1].is(t.BuiltInFunctionCall)&&i[e+1].getFunctionExpression().isOneOf([t.EnumerateFunction])?(n=0,s=m(this,x,fe).call(this,i.slice(n,e+2),t.IteratorExpression)):s=m(this,x,fe).call(this,i.slice(n,e+2),t.ComparisonExpression),i=i.slice(0,n).concat([s],i.slice(e+2)),e=m(this,x,qi).call(this,i)}return i},qi=function(i){for(let e=0;e<i.length;e++)if(i[e].is(a.ComparisonOperators))return e;return-1},qo=function(i){let e=m(this,x,ji).call(this,i);for(;e>-1;){const s=(i[e].is(t.NotOperator)?2:3)===2?e:e-1,o=s>=0?i.slice(s,e+2):i.slice(e,e+2),u=m(this,x,fe).call(this,o,t.BooleanExpression);i=s>=0?i.slice(0,s).concat([u],i.slice(e+2)):i.slice(0,e).concat([u],i.slice(e+2)),e=m(this,x,ji).call(this,i)}return i},ji=function(i){let e=[],n=[];for(let s=0;s<i.length;s++){if(i[s].is(t.NotOperator))return s;i[s].is(t.AndOperator)?e.push(s):i[s].is(t.OrOperator)&&n.push(s)}return e.length>0?e[0]:n.length>0?n[0]:-1},jo=function(i){let e=Zt(i,t.IfDefinition);for(;e>-1&&i.length>=e+3&&i[e+2].is(t.ElseDefinition);){const s=i.slice(e-1,e+4),o=oe(s),u=new Si(o,s);i=i.slice(0,e-1).concat([u],i.slice(e+4)),e=Zt(i,t.IfDefinition)}return i},Ho=function(i){for(;i.length>=3&&i[1].is(t.ForDefinition);){const e=i.length>=5&&i[3].is(t.IfDefinition),n=i.slice(0,e?5:3),s=oe(n);n[2].is(t.ComparisonExpression)&&(n[2]=i[2].convertToIterator()),i=[new Ii(s,n)].concat(i.slice(e?5:3))}return i},zo=function(i){let e=m(this,x,Hi).call(this,i);for(;e>-1;){const n=m(this,x,Qo).call(this,i,e-1),s=i.slice(n),o=oe(s),u=i[e].is(t.AssignmentOperator)?new Lr(o,s):new cu(o,s);i=i.slice(0,n).concat([u]),e=m(this,x,Hi).call(this,i)}return i},Qo=function(i,e){let n=-1;for(let s=e;s>=0&&!(i[s].isChangeOperator()||i[s].isOneOf([a.OtherKeywords,a.BlockDefinitions]));s--)n=s;return Math.max(n,0)},Hi=function(i){for(let e=i.length-1;e>0;e--)if(i[e].isChangeOperator())return e;return-1},Xo=function(i){return i.length>0&&(i[0].is(t.ReturnKeyword)?i=[new hu(oe(i),i)]:i[0].isOneOf([t.ImportKeyword,t.FromKeyword])?i=[new fu(oe(i),i)]:i[0].isOneOf([t.GlobalKeyword,t.AssertKeyword,t.RaiseKeyword])&&(i=[new gu(oe(i),i)])),i},I(Yn,x);let K=Yn;function $n(p,i,e,n,s,o=n+p.length,u=e){switch(i.entity){case t.ExceptionName:return new au(p,i.entity,i.category,e,n,s);case t.VariableName:return new Yt(p,i.entity,i.category,e,n,s);case t.FunctionName:return new Pr(p,i.entity,i.category,e,n,s);case t.MethodName:return new su(p,i.entity,i.category,e,n,s);case t.ClassName:return new lu(p,i.entity,i.category,e,n,s);case t.PropertyName:return new fi(p,i.entity,i.category,e,n,s);case t.ModuleName:return new Ar(p,i.entity,i.category,e,n,s);case t.StringLiteral:return new Dr(p,e,n,s,o,u);case t.TrueType:case t.FalseType:case t.NoneType:return new ru(p,i.entity,i.category,e,n,s);case t.ListDefinition:case t.TupleDefinition:case t.SetDefinition:case t.DictDefinition:return new Vs(p,[],i.entity,[]);case t.IndexKey:return new vr(p,[]);case t.Slice:return new Vr(p,[],[]);case t.NamedImport:return new fi(p,i.entity,i.category,e,n,s)}switch(i.category){case a.BuiltInFunctions:case a.BuiltInMethods:case a.ModuleFunctions:case a.MagicMethods:return new iu(p,i.entity,i.category,e,n,s);case a.BuiltInModules:return new Ar(p,i.entity,i.category,e,n,s);case a.Types:return new ou(p,i.entity,i.category,e,n,s);case a.SpecialVariables:return new Yt(p,i.entity,i.category,e,n,s);case a.ModuleProperties:return new fi(p,i.entity,i.category,e,n,s);case a.LogicalOperators:case a.MathsOperators:case a.ComparisonOperators:case a.OtherKeywords:case a.BlockDefinitions:case a.Other:case a.TypeHint:return new Br(p,i.entity,i.category,e,n,s);default:return new Qe(p,i.entity,i.category,e,n,s,d.Unknown)}}class Qe extends ks{constructor(e,n,s,o,u,f,g=d.NotParsed,w=u+e.length-1,S=o){super();I(this,mt);I(this,wt);I(this,St);I(this,rt);I(this,un);I(this,dn);I(this,hn);I(this,_n);I(this,fn);I(this,Se);I(this,Rt,"unknown");I(this,gn,"unknown");I(this,es,[]);if(w<u)throw new Error("Could not create expression: end index cannot be less than start index");y(this,mt,e),y(this,wt,n),y(this,St,s),y(this,un,o),y(this,hn,u),y(this,_n,f),y(this,fn,w),y(this,dn,S),y(this,Se,g)}getTextValue(){return c(this,mt)}setTextValue(e){y(this,mt,e)}getEntity(){return c(this,wt)}setEntity(e){y(this,wt,e)}getCategory(){return c(this,St)}setCategory(e){y(this,St,e)}getStartLineNumber(){return c(this,un)}getEndLineNumber(){return c(this,dn)}setEndLineNumber(e){y(this,dn,e)}getDocumentStartIndex(){return c(this,hn)}getIndexOnLine(){return c(this,_n)}getDocumentEndIndex(){return c(this,fn)}setDocumentEndIndex(e){y(this,fn,e)}getDataType(){return c(this,Se)}setDataType(e){e!==c(this,Se)&&(y(this,Se,e),super.sendUpdate(e))}setBlockId(e){c(this,Rt)!==e&&y(this,Rt,e)}getBlockId(){return c(this,Rt)==="unknown"&&c(this,rt)!==void 0?c(this,rt).getBlockId():c(this,Rt)}setScopeId(e){c(this,gn)==="unknown"&&y(this,gn,e)}getScopeId(){return c(this,gn)}typeUpdateReceived(e){this.setDataType(e)}getParent(){return c(this,rt)}setParent(e){y(this,rt,e)}hasParentOfKind(e){let n=this.getParent();for(;n!==void 0;)if(n.is(e))return!0;return!1}getContextOfUse(){return c(this,rt)===void 0?"none":c(this,rt).getEntity().name}contains(e){return this===e}is(e){return c(this,wt)===e||c(this,St)===e||c(this,mt)===e}isOneOf(e){try{for(let n of e)if(this.is(n))return!0}catch{try{return this.is(e)}catch{return!1}}return!1}isSubscriptable(){return!1}isNumeric(){return c(this,Se)===d.Int||c(this,Se)===d.Float||c(this,Se)===d.Number||c(this,Se)===d.Bool}isIntLike(){return c(this,Se)===d.Int||c(this,Se)===d.Bool}isNonFloatNumeric(){return this.isIntLike()||c(this,Se)===d.Number}isChangeOperator(){return this.isOneOf([t.AssignmentOperator,t.IncrementOperator,t.DecrementOperator,t.MultiplyAssignOperator,t.DivideAssignOperator,t.ExponentAssignOperator,t.IntDivideAssignOperator,t.RemainderAssignOperator])}matchesPattern(e){return this.getTextValue()===e.getTextValue()&&this.getEntity()===e.getEntity()}isStringLiteral(){return!1}hasChildExpressions(){return!1}getExpressionsOfKind(e){const n=[];return this.is(e)&&n.push(this),n}getFirstExpressionOf(e){if(this.isOneOf(e))return this}getVariableExpressions(){return[]}getAllNestedExpressions(){return[this]}checkForSymptoms(){this.checkRules(this)}getConnectedTo(){return c(this,es)}addConnection(e){c(this,es).push(e)}toJSON(){return{entity:c(this,wt).name,category:c(this,St).name,textValue:c(this,mt),dataType:c(this,Se).name,lineNumber:c(this,un),docIndex:c(this,hn)}}}mt=new WeakMap,wt=new WeakMap,St=new WeakMap,rt=new WeakMap,un=new WeakMap,dn=new WeakMap,hn=new WeakMap,_n=new WeakMap,fn=new WeakMap,Se=new WeakMap,Rt=new WeakMap,gn=new WeakMap,es=new WeakMap;class Y extends Qe{constructor(e,n,s,o,u=d.NotParsed){super(e,s,o,n.length>0?n[0].getStartLineNumber():-1,n.length>0?n[0].getDocumentStartIndex():-1,n.length>0?n[0].getIndexOnLine():-1,u,n.length>0?n[n.length-1].getDocumentEndIndex():-1,n.length>0?n[n.length-1].getEndLineNumber():-1);I(this,Gs);I(this,Ae);y(this,Ae,n),m(this,Gs,Zo).call(this,c(this,Ae))}isSubscriptable(){return Ds(this.getDataType())}hasChildExpressions(){return c(this,Ae).length>0}getVariableExpressions(){let e=[];for(let n of c(this,Ae))n.getTextValue()!=="Placeholder"&&(e=e.concat(n.getVariableExpressions()));return e}matchesPattern(e){return this.getEntity()===e.getEntity()}getExpressionsOfKind(e){let n=super.getExpressionsOfKind(e);for(let s of c(this,Ae))s.is(e)?n.push(s):n=n.concat(s.getExpressionsOfKind(e));return n}getFirstExpressionOf(e){let n=super.getFirstExpressionOf(e);if(n===void 0)for(const s of c(this,Ae)){if(s.isOneOf(e))return s;if(n=s.getFirstExpressionOf(e),n!==void 0)return n}return n}contains(e){if(super.contains(e))return!0;for(let n of c(this,Ae))if(n.contains(e))return!0;return!1}checkForSymptoms(){this.checkRules(this);for(const e of this.getChildren())e.checkForSymptoms()}checkForConstructs(e){super.checkForConstructs(this);for(const n of this.getChildren())n.checkForConstructs(n)}setBlockId(e){super.setBlockId(e);for(const n of this.getChildren())n.setBlockId(e)}setScopeId(e){super.setScopeId(e);for(const n of this.getChildren())n.setScopeId(e)}getChildren(){return c(this,Ae)}setChildren(e){y(this,Ae,e)}addChild(e){c(this,Ae).push(e)}isComplete(){return this.hasChildExpressions()}}Ae=new WeakMap,Gs=new WeakSet,Zo=function(e){for(const n of e)n.setParent(this)};const ns=class ns extends Y{constructor(e,n,s){var g;const o=m(g=ns,mn,ea).call(g,n);super(e,o,s,a.BlockDefinitionStatement,d.NA);I(this,pn);I(this,pe);I(this,ts,0);const u=3,f=o.length-3;if(f<u)y(this,pe,[]);else{const w=o.slice(u,f+1);y(this,pe,K.split(w,t.Comma)),m(this,pn,ta).call(this)}this.addRule(m(this,pn,Yo))}isComplete(){const e=this.getChildren();return e.length>=5&&e[0].is(t.FunctionDefinition)&&e[1].isOneOf([t.FunctionName,t.MethodName])&&e[2].is(t.OpenParenthesis)&&e[e.length-2].is(t.CloseParenthesis)&&e[e.length-1].is(t.Colon)&&li(e,t.OpenParenthesis,t.CloseParenthesis)}getVariableExpressions(){let e=[];for(let n of c(this,pe))for(let s of n)s.is(t.VariableName)?e.push(s):e=e.concat(s.getVariableExpressions());return e}getExpressionsOfKind(e){let n=super.getExpressionsOfKind(e);for(let s of c(this,pe))for(const o of s)o.is(e)?n.push(o):n=n.concat(o.getExpressionsOfKind(e));return n}getFirstExpressionOf(e){let n=super.getFirstExpressionOf(e);if(n===void 0)for(const s of c(this,pe)){if(s.isOneOf(e))return s;if(n=s.getFirstExpressionOf(e),n!==void 0)return n}return n}checkForSymptoms(){this.checkRules(this);for(const e of c(this,pe))for(const n of e)n.checkForSymptoms()}getParameters(){return c(this,pe)}getOptionalParameterCount(){return c(this,ts)}};pe=new WeakMap,ts=new WeakMap,pn=new WeakSet,Yo=function(e){const n=[],s=e.getChildren();if(s.length>1){const o=We(s[1].getTextValue()).category;(o===a.BlockDefinitions||o===a.LogicalOperators||o===a.Types||o===a.OtherKeywords)&&n.push(M.createStatementSymptom(b.DefinitionFollowedByReservedWord,s,0,1,{definitionType:s[0].getTextValue(),reservedWord:s[1].getTextValue()}))}return n},mn=new WeakSet,_o=function(e){let n=-1,s=-1,o=0;for(let u=0;u<e.length;u++)if(e[u].is(t.OpenParenthesis))o++,n===-1&&(n=u);else if(e[u].is(t.CloseParenthesis)&&(o--,o===0)){s=u;break}return[n,s]},ea=function(e){var u;let s=m(u=ns,mn,_o).call(u,e)[1]+1,o=-1;for(;s<e.length;){if(e[s].is(t.Colon)){o>=0&&e.splice(o,s-o);break}else e[s].is(t.TypeHintReturn)&&(o=s);s++}return e},ta=function(){for(let e=0;e<c(this,pe).length;e++){if(c(this,pe)[e]=K.createTree(c(this,pe)[e]),c(this,pe)[e].length>1){const n=K.split(c(this,pe)[e],t.Colon);c(this,pe)[e]=n[0]}for(let n of c(this,pe)[e])if(n.is(t.VariableName))n.setDataType(d.Unknown),n.setAssignedOrChanged(),n.setIsParameter();else if(n.is(t.AssignmentStatement)){const s=n.getVariableExpressions();Ys(this,ts)._++;for(let o of s)o.setDataType(d.Unknown),o.setAssignedOrChanged(),o.setIsParameter()}}},I(ns,mn);let Ps=ns;class jc extends Ps{constructor(i,e){if(super(i,e,t.FunctionDefinitionStatement,a.BlockDefinitionStatement,d.NA),this.addConnection(this.getFunctionNameExpression()),this.getFunctionNameExpression()!==void 0){this.getFunctionNameExpression().addConnection(this);for(const n of this.getParameters())for(const s of n)this.getFunctionNameExpression().addConnection(s)}}isComplete(){return super.isComplete()&&this.getChildren()[1].is(t.FunctionName)}getFunctionNameExpression(){return this.getChildren()[1]}getConnectedTo(){return this.getFunctionNameExpression().getConnectedTo()}addConnection(i){this.getFunctionNameExpression()!==void 0&&this.getFunctionNameExpression().addConnection(i)}getAllNestedExpressions(){try{return[...super.getAllNestedExpressions(),...this.getFunctionNameExpression().getAllNestedExpressions(),...this.getParameters().flatMap(e=>e.flatMap(n=>n.getAllNestedExpressions()))]}catch{return[]}}toJSON(){const i=super.toJSON();return i.functionName=this.getFunctionNameExpression().getTextValue(),i.parameters=this.getParameters().map(e=>e.map(n=>n.toJSON())),i}}class Hc extends Ps{constructor(e,n){super(e,n,t.MethodDefinitionStatement,a.BlockDefinitionStatement,d.NA);I(this,ss);const s=super.getParameters();s.length>0&&y(this,ss,s[0][0]),this.addConnection(this.getMethodNameExpression()),this.getMethodNameExpression().addConnection(this);for(const o of this.getParameters())for(const u of o)this.getMethodNameExpression().addConnection(u)}isComplete(){return super.isComplete()&&this.getChildren()[1].is(t.MethodName)}getMethodNameExpression(){return this.getChildren()[1]}getParameters(){return super.getParameters().slice(1)}getClassVar(){return c(this,ss)}getConnectedTo(){return this.getMethodNameExpression().getConnectedTo()}addConnection(e){this.getMethodNameExpression().addConnection(e)}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...this.getMethodNameExpression().getAllNestedExpressions(),...this.getParameters().flatMap(n=>n.flatMap(s=>s.getAllNestedExpressions()))]}toJSON(){const e=super.toJSON();return e.methodName=this.getMethodNameExpression().getTextValue(),e.parameters=this.getParameters().map(n=>n.map(s=>s.toJSON())),e}}ss=new WeakMap;class zc extends Y{constructor(i,e){super(i,e,t.ClassDefinitionStatement,a.BlockDefinitionStatement,e.length>=2&&e[1].is(t.ClassName)?d.createCustomType(e[1].getTextValue()):d.Class)}isComplete(){return super.isComplete()&&this.getChildren()[1].is(t.ClassName)}getAllNestedExpressions(){return super.getAllNestedExpressions()+[this.getChildren()[1]]}getClassNameExpression(){return this.getChildren()[1]}toJSON(){const i=super.toJSON();return i.className=this.getClassNameExpression().getTextValue(),i}}const $s=class $s extends Y{constructor(e,n,s,o){super(e,n,s,o);I(this,Ne);I(this,ue);if(m(this,Ne,ei).call(this),this.isComplete()){const f=n.length-2;if(f<2)y(this,ue,[]);else{const g=n.slice(2,f+1);y(this,ue,K.checkForListComp(g));for(let w=0;w<c(this,ue).length;w++)c(this,ue)[w].length>1&&(c(this,ue)[w]=K.createTree(c(this,ue)[w]))}}else y(this,ue,[]);m(this,Ne,sa).call(this),this.addRules([m(this,Ne,ra),m(this,Ne,ia)]),m(this,Ne,na).call(this)}isComplete(){const e=this.getChildren();return e.length>=3&&e[0].isOneOf([a.BuiltInFunctions,t.FunctionName])&&e[1].is(t.OpenParenthesis)&&e[e.length-1].is(t.CloseParenthesis)&&li(e,t.OpenParenthesis,t.CloseParenthesis)}addChild(e){super.addChild(e),m(this,Ne,ei).call(this)}setChildren(e){super.setChildren(e),m(this,Ne,ei).call(this)}getVariableExpressions(){let e=[];for(let n of c(this,ue))for(let s of n)s.is(t.VariableName)?e.push(s):e=e.concat(s.getVariableExpressions());return e}getExpressionsOfKind(e){let n=super.getExpressionsOfKind(e);if(this.getChildren()[0].is(e))return[this.getChildren()[0]];for(let s of c(this,ue))for(let o of s)o.is(e)?n.push(o):n=n.concat(o.getExpressionsOfKind(e));return n}getFirstExpressionOf(e){let n=super.getFirstExpressionOf(e);if(this.getChildren()[0].isOneOf(e))return this.getChildren()[0];if(n===void 0)for(const s of c(this,ue)){if(s.isOneOf(e))return s;if(n=s.getFirstExpressionOf(e),n!==void 0)return n}return n}checkForSymptoms(){this.checkRules(this);for(const e of c(this,ue))for(const n of e)n.checkForSymptoms()}matchesPattern(e){return super.matchesPattern(e)&&this.getFunctionName()===e.getFunctionName()&&this.getTextValue()===e.getTextValue()}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...this.getFunctionExpression().getAllNestedExpressions(),...c(this,ue).flatMap(n=>n.flatMap(s=>s.getAllNestedExpressions()))]}toJSON(){const e=super.toJSON();return e.functionName=this.getFunctionName(),e.arguments=this.getArguments().map(n=>n.map(s=>s.toJSON())),e}getFunctionEntity(){const e=this.getChildren();if(e.length<1)throw new Error("No function expression available");return e[0].getEntity()}getFunctionName(){const e=this.getChildren();if(e.length<1)throw new Error("No function expression available");return e[0].getTextValue()}getFunctionExpression(){const e=this.getChildren();if(e.length<1)throw new Error("No function expression available");return e[0]}getArguments(){return c(this,ue)}};ue=new WeakMap,Ne=new WeakSet,na=function(){for(const e of c(this,ue))for(const n of e)n.addConnection(this);this.addConnection(this.getFunctionExpression())},sa=function(){for(const e of c(this,ue))for(const n of e)n.setParent(this)},ei=function(){this.getChildren()[0].addObserver(this),this.isComplete()?xi($s.prototype,this,"setDataType").call(this,this.getChildren()[0].getDataType()):xi($s.prototype,this,"setDataType").call(this,d.NotParsed)},ia=function(e){const n=[];return e.getDataType()!==d.None&&(e.getParent()===void 0||e.getParent().is(t.GroupStatement)&&e.getParent().getParent()===void 0)&&(e.is(t.BuiltInFunctionCall)||e.getFunctionExpression().getReturnStatements().length>0)&&n.push(M.createStatementSymptom(b.UnusedReturn,[e],0,0,{expression:e.getFunctionExpression()})),n},ra=function(e){const n=[],s=e.getArguments();for(const o of s){const f=o.flatMap(g=>g.is(t.GroupStatement)?g.getContents():g).filter(g=>Ct(g)||g.getDataType()===d.None&&!g.isOneOf([t.NoneType,t.VariableName]));f.length>0&&n.push(...f.map(g=>M.createStatementSymptom(b.AssignedNone,[g],0,0,{expression:g,usage:e.getFunctionEntity()===t.PrintFunction?"print":wr})))}return n};let Ls=$s;class Qc extends Ls{constructor(e,n){super(e,n,t.BuiltInFunctionCall,a.FunctionCall);I(this,Js);n.length>0&&n[0].isOneOf([t.StrFunction,t.IntFunction,t.FloatFunction,t.BoolFunction,t.ListFunction,t.TupleFunction,t.SetFunction,t.DictFunction])&&this.addRule(m(this,Js,oa))}isComplete(){return super.isComplete()&&this.getChildren()[0].is(a.BuiltInFunctions)}convertToUserDefinedFunction(e){this.setEntity(t.UserDefinedFunctionCall);const n=this.getChildren()[0];n.setEntity(t.FunctionName),n.setCategory(a.Identifiers),n.setDataType(e.getReturnType()),n.addReturns=(s,o=!1)=>e.addReturns(s,o),n.getReturnType=()=>e.getReturnType(),n.getReturnStatements=()=>e.getReturnStatements()}}Js=new WeakSet,oa=function(e){const n=[],s=e.getDataType(),o=e.getArguments(),u=e.getChildren();return o.length===1&&o[0].length===1&&(o[0][0].getDataType()===s||s===d.List&&o[0][0].getDataType()===d.String)&&n.push(M.createStatementSymptom(b.TypeUnnecessary,u,0,u.length-1,{convertedValue:o[0][0].getTextValue(),argType:o[0][0].getDataType().name,convertedType:s.name})),n};class Xc extends Ls{constructor(i,e){super(i,e,t.UserDefinedFunctionCall,a.FunctionCall);const n=this.getFunctionExpression(),s=this.getArguments();if(s.length>0&&n.getParent().is(a.FunctionCall)&&s.length<=n.getParent().getArguments().length){const o=n.getParent().getArguments();for(let u=0;u<s.length;u++)s[u][0].addConnection(o[u][0])}}isComplete(){return super.isComplete()&&this.getChildren()[0].is(t.FunctionName)}convertToImportedFunction(){this.setEntity(t.BuiltInFunctionCall);const i=this.getChildren()[0];i.setEntity(t.Unknown),i.setCategory(a.ModuleFunctions),i.setDataType(d.Unknown)}}class Zc extends Y{constructor(i,e){super(i,e,t.ExceptionCall,a.ExceptionCall,d.Exception)}isComplete(){return super.isComplete()&&this.getChildren()[0].is(a.BuiltInExceptions)}getAllNestedExpressions(){return this.getChildren()[0].getAllNestedExpressions()}}class Mr extends Y{constructor(e,n,s,o){super(e,n,s,o);I(this,Ce);I(this,de);if(m(this,Ce,ti).call(this),this.isComplete()){const f=n.length-2;if(f<4)y(this,de,[]);else{let g=n.slice(4,f+1);y(this,de,K.checkForListComp(g));for(let w=0;w<c(this,de).length;w++)c(this,de)[w].length>1&&(c(this,de)[w]=K.createTree(c(this,de)[w]))}}else y(this,de,[]);m(this,Ce,la).call(this),m(this,Ce,aa).call(this),this.addRules([m(this,Ce,ua),m(this,Ce,ca)])}isComplete(){const e=this.getChildren();return e.length>=5&&e[1].is(t.Dot)&&e[3].is(t.OpenParenthesis)&&e[e.length-1].is(t.CloseParenthesis)&&li(e,t.OpenParenthesis,t.CloseParenthesis)}addChild(e){super.addChild(e),m(this,Ce,ti).call(this)}setChildren(e){super.setChildren(e),m(this,Ce,ti).call(this)}getVariableExpressions(){let e=[];for(let n of this.getChildren()){if(n.is(t.Dot))break;n.is(t.VariableName)?e.push(n):e=e.concat(n.getVariableExpressions())}for(let n of c(this,de))for(let s of n)s.is(t.VariableName)?e.push(s):e=e.concat(s.getVariableExpressions());return e}getExpressionsOfKind(e){let n=super.getExpressionsOfKind(e);for(let s of c(this,de))for(let o of s)o.is(e)?n.push(o):n=n.concat(o.getExpressionsOfKind(e));return n}getFirstExpressionOf(e){let n=super.getFirstExpressionOf(e);if(n===void 0)for(const s of c(this,de)){if(s.isOneOf(e))return s;if(n=s.getFirstExpressionOf(e),n!==void 0)return n}return n}checkForSymptoms(){this.checkRules(this),this.isComplete()&&this.getChildren()[0].checkForSymptoms();for(const e of c(this,de))for(const n of e)n.checkForSymptoms()}matchesPattern(e){return super.matchesPattern(e)&&this.getMethodName()===e.getMethodName()}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),this.getMethodExpression(),...c(this,de).flatMap(n=>n.flatMap(s=>s.getAllNestedExpressions()))]}toJSON(){const e=super.toJSON();return e.methodName=this.getMethodName(),e.arguments=this.getArguments().map(n=>n.map(s=>s.toJSON())),e.object=this.getObject().toJSON(),e}getMethodEntity(){const e=this.getChildren();if(e.length<3)throw new Error("No method expression available");return e[2].getEntity()}getMethodExpression(){const e=this.getChildren();if(e.length<3)throw new Error("No method expression available");return e[2]}getMethodName(){const e=this.getChildren();if(e.length<3)throw new Error("No method expression available");return e[2].getTextValue()}getMethod(){const e=this.getChildren();if(e.length<3)throw new Error("No method expression available");return e[2]}getObject(){const e=this.getChildren();if(e.length===0)throw new Error("No children");return e[0]}getArguments(){return c(this,de)}}de=new WeakMap,Ce=new WeakSet,aa=function(){for(const e of c(this,de))for(const n of e)n.addConnection(this);this.addConnection(this.getMethodExpression())},la=function(){for(const e of c(this,de))for(const n of e)n.setParent(this)},ti=function(){this.isComplete()?this.setDataType(this.getChildren()[2].getDataType()):this.setDataType(d.NotParsed)},ca=function(e){const n=[];return e.getDataType()!==d.None&&(e.getParent()===void 0||e.getParent().is(t.GroupStatement)&&e.getParent().getParent()===void 0)&&n.push(M.createStatementSymptom(b.UnusedReturn,[e],0,0,{expression:e.getMethodExpression()})),n},ua=function(e){const n=[],s=e.getArguments();for(const o of s){const f=o.flatMap(g=>g.is(t.GroupStatement)?g.getContents():g).filter(g=>Ct(g)||g.getDataType()===d.None&&!g.isOneOf([t.NoneType,t.VariableName]));f.length>0&&n.push(...f.map(g=>M.createStatementSymptom(b.AssignedNone,[g],0,0,{expression:g,usage:wr})))}return n};class Yc extends Mr{constructor(e,n){super(e,n,t.BuiltInMethodCall,a.MethodCall);I(this,wn);m(this,wn,da).call(this),this.addRule(m(this,wn,ha))}isComplete(){return super.isComplete()&&this.getChildren()[2].isOneOf([a.BuiltInMethods,a.MagicMethods,a.ModuleFunctions])}isStringLiteral(){return this.getMethodEntity()===t.Format}}wn=new WeakSet,da=function(){if(gc.has(this.getMethodEntity())){const e=this.getObject();e.is(t.VariableName)?e.setAssignedOrChanged():e.is(t.SubscriptedExpression)&&e.getChildren()[0].is(t.VariableName)&&e.getChildren()[0].setAssignedOrChanged()}},ha=function(e){const n=[],o=e.getObject().getDataType(),u=e.getMethod();let f=!0;switch(o){case d.Number:case d.Int:case d.Float:case d.Bool:case d.None:f=!1}if(f&&ui.has(o)&&(f=ui.get(o).has(u.getEntity())||u.is(a.MagicMethods)),!f){const g=e.getChildren();n.push(M.createStatementSymptom(b.UnknownMethod,g,0,g.length-1,{objectType:o.name}))}return n};class _c extends Mr{constructor(e,n){super(e,n,t.UserDefinedMethodCall,a.MethodCall);I(this,Ks);this.addRule(m(this,Ks,fa))}isComplete(){return super.isComplete()&&this.getChildren()[2].is(t.MethodName)}}Ks=new WeakSet,fa=function(e){const n=[],o=e.getObject().getDataType();if(ui.has(o)){const u=e.getChildren();n.push(M.createStatementSymptom(b.UnknownMethod,u,0,u.length-1,{objectType:o.name}))}return n};class xr extends Y{constructor(e,n,s,o){super(e,n,s,o);I(this,Sn);I(this,Xe);I(this,Ie);this.isComplete()&&(y(this,Xe,n[0]),y(this,Ie,n[2])),m(this,Sn,pa).call(this),this.addRule(m(this,Sn,ga))}isComplete(){const e=this.getChildren();return e.length==3&&e[1].is(t.Dot)}getVariableExpressions(){let e=[];return c(this,Xe).is(t.VariableName)?e.push(c(this,Xe)):e=e.concat(c(this,Xe).getVariableExpressions()),e}getExpressionsOfKind(e){let n=super.getExpressionsOfKind(e);for(let s of this.getChildren())s.is(e)?n.push(s):n=n.concat(s.getExpressionsOfKind(e));return n}getFirstExpressionOf(e){let n=super.getFirstExpressionOf(e);if(n===void 0)for(const s of this.getChildren()){if(s.isOneOf(e))return s;if(n=s.getFirstExpressionOf(e),n!==void 0)return n}return n}matchesPattern(e){return super.matchesPattern(e)&&this.getTextValue()===e.getTextValue()}setDataType(e){if((e!==this.getDataType()||e!==c(this,Ie).getDataType())&&(super.setDataType(e),!c(this,Ie).is(a.ModuleProperties)))try{c(this,Ie).setDataType(e)}catch{console.log("Couldn't set property type of",c(this,Ie).getEntity().name,". Expected a property.")}}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...c(this,Xe).getAllNestedExpressions(),...c(this,Ie).getAllNestedExpressions()]}toJSON(){const e=super.toJSON();return e.object=c(this,Xe).toJSON(),e.propertyName=c(this,Ie).getTextValue(),e}getObject(){return c(this,Xe)}getProperty(){return c(this,Ie)}}Xe=new WeakMap,Ie=new WeakMap,Sn=new WeakSet,ga=function(e){const n=[];return(e.getParent()===void 0||e.getParent().is(t.GroupStatement)&&e.getParent().getParent()===void 0)&&n.push(M.createStatementSymptom(b.UnusedValue,[e],0,0)),n},pa=function(){if(this.isComplete())if(c(this,Ie).getCategory()===a.ModuleProperties){const e=Ot.get(c(this,Ie).getEntity());this.setDataType(e||c(this,Ie).getDataType())}else this.setDataType(d.Unknown);else this.setDataType(d.NotParsed);c(this,Ie).addObserver(this)};class eu extends Qe{isSubscriptable(){return!0}}class Dr extends eu{constructor(e,n,s,o,u=s+e.length,f=n){super(e,t.StringLiteral,a.Literals,n,s,o,d.String,u,f);I(this,Ws);this.addRule(m(this,Ws,ma))}isStringLiteral(){return!0}matchesPattern(e){return e.getEntity()===t.StringLiteral||e.getEntity()===t.CombinedStringLiteral||e.getEntity()===t.FString}setDataType(e){throw new Error(`Cannot change the data type of a String literal. Attempted to change the type to: ${e.name}.`)}update(e,n,s){this.setEndLineNumber(e),this.documentEndIndex(n),this.setTextValue(this.getTextValue+s)}}Ws=new WeakSet,ma=function(e){const n=[];return(e.getParent()===void 0||e.getParent().is(t.GroupStatement)&&e.getParent().getParent()===void 0)&&n.push(M.createStatementSymptom(b.UnusedValue,[e],0,0)),n};class hi extends Qe{constructor(e,n,s,o){const u=e.indexOf(".")>=0?t.FloatLiteral:t.IntLiteral;super(e,u,a.Literals,n,s,o,u===t.FloatLiteral?d.Float:d.Int);I(this,qs);this.addRule(m(this,qs,wa))}setDataType(e){throw new Error(`Cannot change the data type of a bumber literal. Attempted to change the type to: ${e.name}.`)}matchesPattern(e){return e.getEntity()===t.FloatLiteral||e.getEntity()===t.IntLiteral}}qs=new WeakSet,wa=function(e){const n=[];return(e.getParent()===void 0||e.getParent().is(t.GroupStatement)&&e.getParent().getParent()===void 0)&&n.push(M.createStatementSymptom(b.UnusedValue,[e],0,0)),n};class tu extends Y{constructor(e,n){super(e,n,t.FString,a.Literals,d.String);I(this,In);I(this,Ze);y(this,Ze,m(this,In,Sa).call(this));for(const s of c(this,Ze))for(const o of s)o.setParent(this),this.addConnection(o);this.addRule(m(this,In,Ia))}isStringLiteral(){return!0}matchesPattern(e){return e.getEntity()===t.StringLiteral||e.getEntity()===t.CombinedStringLiteral||e.getEntity()===t.FString}getVariableExpressions(){let e=[];for(let n of c(this,Ze))for(let s of n)s.is(t.VariableName)?e.push(s):e=e.concat(s.getVariableExpressions());return e}checkForSymptoms(){this.checkRules(this);for(const e of c(this,Ze))for(const n of e)n.checkForSymptoms()}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...c(this,Ze).flatMap(e=>e.flatMap(n=>n.getAllNestedExpressions()))]}toJSON(){const e=super.toJSON();return e.values=c(this,Ze).map(n=>n.map(s=>s.toJSON())),e}getValues(){return c(this,Ze)}}Ze=new WeakMap,In=new WeakSet,Sa=function(){const e=[];if(this.isComplete()){const n=this.getChildren()[1],s=n.getTextValue();let o=0,u=0,f=-1,g=-1;for(let w=0;w<s.length;w++)if(s.charAt(w)==="{")o===0&&(f=w+1),o++;else if(o>0)if(s.charAt(w)==="}"){if(o--,o===0){const S=g===-1?s.substring(f,w):s.substring(f,g),F=new Gn(S,n.getStartLineNumber(),n.getDocumentStartIndex());e.push(K.createTree(F.getExpressions()))}}else s.charAt(w)==="["?u++:s.charAt(w)==="]"?u--:u===0&&s.charAt(w)===":"&&(g=w)}return e},Ia=function(e){const n=[];return(e.getParent()===void 0||e.getParent().is(t.GroupStatement)&&e.getParent().getParent()===void 0)&&n.push(M.createStatementSymptom(b.UnusedValue,[e],0,0)),n};class nu extends Y{constructor(e,n){super(e,n,t.CombinedStringLiteral,a.Literals,d.String);I(this,js);this.addRule(m(this,js,ba))}isStringLiteral(){return!0}matchesPattern(e){return e.getEntity()===t.StringLiteral||e.getEntity()===t.CombinedStringLiteral||e.getEntity()===t.FString}getVariableExpressions(){let e=[];for(let n of this.getChildren())e=e.concat(n.getVariableExpressions());return e}}js=new WeakSet,ba=function(e){const n=[];return(e.getParent()===void 0||e.getParent().is(t.GroupStatement)&&e.getParent().getParent()===void 0)&&n.push(M.createStatementSymptom(b.UnusedValue,[e],0,0)),n};class Br extends Qe{constructor(i,e,n,s,o,u){super(i,e,n,s,o,u,d.NA)}setDataType(i){throw new Error(`Cannot change the data type of a keyword or operator. Attempted to change the type to: ${i.name}.`)}setTextValue(i){throw new Error(`Cannot change the value of a keyword or operator. Attempted to change the value to ${i}.`)}matchesPattern(i){return this.getEntity()===i.getEntity()?!0:this.isOneOf([a.ComparisonOperators,a.LogicalOperators,a.MathsOperators])?i.getCategory():!1}}class Ar extends Qe{constructor(e,n,s,o,u,f){super(e,n,s,o,u,f,xs(n));I(this,It);y(this,It,e)}hasAlias(){return c(this,It)!==this.getTextValue()}getModuleName(){return c(this,It)}setModuleName(e){y(this,It,e)}setDataType(e){throw new Error(`The data type of a module cannot be changed. Attempted to change the data type to ${e}.`)}setTextValue(e){throw new Error(`The text value of a module cannot be changed. Attempted to change the value to ${e}.`)}matchesPattern(e){return this.getEntity()===e.getEntity()===this.getTextValue()&&e.getTextValue()}toJSON(){const e=super.toJSON();return e.moduleAlias=c(this,It),e}}It=new WeakMap;class Yt extends Qe{constructor(e,n,s,o,u,f,g=!1){var i=(...xd)=>(super(...xd),I(this,re),I(this,bt,[]),I(this,is,!1),I(this,rs),I(this,os,!1),this);if(s===a.Identifiers)i(e,n,s,o,u,f);else if(s===a.SpecialVariables)i(e,n,s,o,u,f,xs(n));else if(s===a.ModuleProperties)i(e,n,s,o,u,f,Ot.has(n)?Ot.get(n):d.Unknown);else throw new Error(`No constructor for VariableExpression with ${n.name}`);y(this,rs,g),this.addRules([m(this,re,Ta),m(this,re,Fa)]),this.addConstructRule(m(this,re,ya))}setTextValue(e){throw new Error(`Cannot change the text value of a variable (its name). Attempted to change the value to ${e}.`)}setIsParameter(){y(this,os,!0)}isParameter(){return c(this,os)}isSubscriptable(){return Ds(this.getDataType())}getVariableExpressions(){return this.is(t.VariableName)?[this]:[]}setDataType(e){(!this.isAssignedOrChanged()||this.isObjectOfMethodCall()||this.isSubscripted())&&c(this,bt).length>0&&(e=m(this,re,ni).call(this)),super.setDataType(e),e.isCustom&&this.getParent()&&this.getParent().is(t.PropertyCallExpression)&&(this.getParent().getProperty().setCategory(a.ClassAttributes),this.getParent().getProperty().setOwnerType(e))}matchesPattern(e){let n=e;return n.is(t.BooleanExpression)&&e.getChildren().length===2&&e.getChildren()[0].is(t.NotOperator)&&e.getChildren()[1].is(t.VariableName)&&(n=e.getChildren()[1]),this.getEntity()===n.getEntity()&&this.getTextValue()===n.getTextValue()}getLastUsages(){return c(this,bt)}addLastUsage(e){c(this,bt).push(e),e.addConnection(this),(!this.isAssignedOrChanged()||this.isObjectOfMethodCall()||this.isSubscripted())&&(this.setDataType(m(this,re,ni).call(this)),e.addObserver(this))}isSubscripted(){const e=this.getParent();return e===void 0?!1:e.is(t.SubscriptedExpression)}isObjectOfMethodCall(){const e=this.getParent();return e===void 0?!1:e.is(t.BuiltInMethodCall)&&e.getChildren()[0].getTextValue()===this.getTextValue()}setLastUsages(e){y(this,bt,e),this.setDataType(m(this,re,ni).call(this));for(let n of e)n.addObserver(this),n.addConnection(this)}isAssignedOrChanged(){return c(this,is)}setAssignedOrChanged(){y(this,is,!0)}isProxy(){return c(this,rs)}compareValues(e,n){const s=e.getParent();if(s===void 0)return Ms;const o=s.is(t.AssignmentStatement)?m(this,re,zi).call(this,e):s.is(t.IteratorExpression)?m(this,re,Oa).call(this,e):void 0,u=m(this,re,Ca).call(this,o,n);return u.size===1?Array.from(u)[0]:Ms}}bt=new WeakMap,is=new WeakMap,rs=new WeakMap,os=new WeakMap,re=new WeakSet,ni=function(){return Nt(c(this,bt).map(e=>e.getDataType()))},ya=function(e){const n=[];return e.getDataType()===d.Bool&&M.checkBooleanCompare(e),n},Fa=function(e){const n=[];return(e.getParent()===void 0||e.getParent().is(t.GroupStatement)&&e.getParent().getParent()===void 0)&&n.push(M.createStatementSymptom(b.UnusedValue,[e],0,0)),n},Ta=function(e){var u;const n=[],s=e.getLastUsages(),o=e.getParent();if(!e.getScopeId().includes("listComprehension")&&!e.isProxy()&&e.isAssignedOrChanged()&&s.length>0&&o!==void 0&&o.isOneOf([t.AssignmentStatement,t.IteratorExpression])){if(o.is(t.AssignmentStatement)&&m(u=e,re,Na).call(u,e.getTextValue(),o))return n;let f=!0;const g=e.getBlockId().split("-")[1];for(const w of s)if(w.getScopeId()===e.getScopeId()&&(!w.isAssignedOrChanged()||g!=="for"&&w.getBlockId()!==e.getBlockId())){f=!1;break}if(f){const w=s.length===1&&s[0].isParameter(),S=o.is(t.IteratorExpression)?o.getParent().getTextValue():o.getTextValue();n.push(M.createStatementSymptom(b.OverwrittenVariable,[e],0,0,{isParameter:w,functionBlock:w?s[0].getBlockId():"",prevUsageIsDefinition:s.length===1&&s[0].getLastUsages().length===0,overwriteType:o.is(t.AssignmentStatement)?oi:ri,overwriteValue:e.compareValues(e,s),usageText:S,overwrittenVar:s.map(F=>({lineNum:F.getStartLineNumber(),block:F.getBlockId(),docIndex:F.getDocumentStartIndex(),forLoopDefinition:F.getParent().is(t.IteratorExpression)&&F.getParent().getLoopVariables().filter(T=>T.getTextValue()===F.getTextValue()).length>0}))}))}}return n},Na=function(e,n){const s=n.getAssignedValues();for(const o of s)if(o.getExpressionsOfKind(e).length>0)return!0;return!1},Ca=function(e,n){const s=new Set;if(e!==void 0&&e.isOneOf([a.Literals,a.Types]))for(const o of n)if(o.getParent()!==void 0&&o.getParent().is(t.AssignmentStatement)){const u=m(this,re,zi).call(this,o);u!==void 0&&u.isOneOf([a.Literals,a.Types])?s.add(e.getTextValue()===u.getTextValue()?ai:mr):s.add(Ms)}else s.add(Ms);return s},Oa=function(e){const n=e.getParent(),s=n.getIterable();if(s.is(t.BuiltInFunctionCall)){const o=s.getFunctionExpression();if(o.is(t.RangeFunction)){const u=s.getArguments();if(u.length===1)return new hi("0",-1,-1,-1);if(u.length>1)return u[0][0]}else if(o.is(t.EnumerateFunction)){const u=n.getLoopVariables();if(u.length===2&&u[0].getTextValue()===e.getTextValue())return new hi("0",-1,-1,-1)}}},zi=function(e){const n=e.getParent();if(n===void 0)return;const s=n.getTargetVariables(),o=n.getAssignedValues();let u=-1;for(let f=0;f<s.length;f++)if(s[f].getTextValue()===e.getTextValue()){u=f;break}if(u>-1&&u<o.length)return o[u]};class fi extends Yt{constructor(e,n,s,o,u,f){super(e,n,s,o,u,f);I(this,as)}setDataType(e){if(this.is(t.PropertyName))super.setDataType(e);else throw new Error(`Cannot change the data type of an attribute of a built-in module. Attempted to change the data type to ${e.name}.`)}getVariableExpressions(){return[]}getOwnerType(){return c(this,as)}setOwnerType(e){y(this,as,e)}matchesPattern(e){return this.getEntity()===e.getEntity()&&this.getTextValue()===e.getTextValue()}}as=new WeakMap;class kr extends Qe{constructor(i,e,n,s,o,u,f=d.NotParsed){super(i,e,n,s,o,u,f)}setTextValue(i){throw new Error(`Cannot change the name of a function node. Attempted to change the name to ${i}.`)}isSubscriptable(){return Ds(this.getDataType())}matchesPattern(i){return this.getEntity()===i.getEntity()&&this.getTextValue()===i.getTextValue()}}class Pr extends kr{constructor(e,n,s,o,u,f){super(e,n,s,o,u,f,d.NotParsed);I(this,ls);I(this,Ye,[])}setDataType(e){const n=c(this,Ye).map(s=>s.getDataType());super.setDataType(Nt(n))}toJSON(){const e=this.getReturnStatements(),n=this.getParent(),s=n!==void 0&&n.isOneOf([t.FunctionDefinitionStatement,t.MethodDefinitionStatement])?n.getParameters().length:-1,o=n!==void 0&&n.isOneOf([t.FunctionDefinitionStatement,t.MethodDefinitionStatement])?n.getOptionalParameterCount():-1;return{name:this.getTextValue(),block:this.getBlockId(),callLineNumbers:Array.from(this.getObservers()).filter(u=>u.is(t.UserDefinedFunctionCall)).map(u=>u.getStartLineNumber()),hasReturn:e.length>0,hasBranchWithoutReturn:c(this,Ye).length>e.length,numOptionalParameters:o,parameters:s>-1?n.getParameters().flatMap(u=>u).map(u=>u.getTextValue()):[],returnDetail:e.map(u=>({line:u.getStartLineNumber(),dataType:u.getDataType().name})),returnTypes:e.length>0?Array.from(new Set(e.map(u=>u.getDataType().name))):["none"]}}addReturns(e,n=!1){for(const s of e)if(s.getFirstExpression().is(t.ReturnStatement)){const o=s.getFirstExpression();c(this,Ye).push(o);for(const u of this.getObservers())u.is(t.UserDefinedFunctionCall)&&(c(u.getFunctionExpression(),Ye).push(o),o.addConnection(u));o.addObserver(this)}else m(this,ls,Qi).call(this);n&&m(this,ls,Qi).call(this),this.setDataType()}getReturnType(){const e=c(this,Ye).map(n=>n.getDataType());return Nt(e)}getReturnStatements(){return c(this,Ye).filter(e=>e.is(t.ReturnStatement))}}Ye=new WeakMap,ls=new WeakSet,Qi=function(){const e=new Yt("proxy",t.VariableName,a.Identifiers,-1,-1,-1,!0);e.setDataType(d.None),c(this,Ye).push(e)};class su extends Pr{constructor(){super(...arguments);I(this,bn,d.Class)}getContainingClass(){return c(this,bn)}setContainingClass(e){y(this,bn,e)}toJSON(){const e=super.toJSON();return e.containingClass=c(this,bn).name,this.getTextValue()==="__init__"&&(e.hasReturn=!0,e.hasBranchWithoutReturn=!1,e.returnTypes=[e.containingClass]),e}}bn=new WeakMap;class iu extends kr{constructor(i,e,n,s,o,u){super(i,e,n,s,o,u,Ot.get(e))}setDataType(i){if(this.getEntity()!==t.FunctionName)throw new Error(`Cannot set the data type of a built-in function. Attempted to set the data type to ${i}`);super.setDataType(i)}}class ru extends Qe{constructor(e,n,s,o,u,f){var i=(...Dd)=>(super(...Dd),I(this,Hs),this);if(n===t.TrueType||n===t.FalseType)i(e,n,s,o,u,f,d.Bool);else if(n===t.NoneType)i(e,n,s,o,u,f,d.None);else throw new Error(`Not a valid type value: ${n.name}`);this.addRule(m(this,Hs,Ma))}setTextValue(e){throw new Error(`The text value of a built-in function cannot be changed. Attempted to change the value to ${e}.`)}setDataType(e){throw new Error(`Cannot set the data type of a built-in function. Attempted to set the data type to ${e}`)}matchesPattern(e){return e.getEntity()===t.TrueType||e.getEntity()===t.FalseType||e.getEntity()===t.NoneType}}Hs=new WeakSet,Ma=function(e){const n=[];return(e.getParent()===void 0||e.getParent().is(t.GroupStatement)&&e.getParent().getParent()===void 0)&&n.push(M.createStatementSymptom(b.UnusedValue,[e],0,0)),n};class gi extends Qe{constructor(i,e,n,s,o,u,f){super(i,e,n,s,o,u,f)}setTextValue(i){throw new Error(`The text value of a class or type cannot be changed. Attempted to change the value to ${i}.`)}matchesPattern(i){return this.getEntity()===i.getEntity()&&this.getTextValue()===i.getTextValue()}}class ou extends gi{constructor(i,e,n,s,o,u){super(i,e,n,s,o,u,d.Unknown)}setDataType(i){throw new Error(`Cannot change the data type of a built-in type. Attempted to set the data type to ${i}.`)}}class au extends gi{constructor(i,e,n,s,o,u){super(i,e,n,s,o,u,d.Exception)}setDataType(i){throw new Error(`Cannot change the data type of a built-in type. Attempted to set the data type to ${i}.`)}}class lu extends gi{constructor(i,e,n,s,o,u){super(i,e,n,s,o,u,d.Class)}matchesPattern(i){return this.getEntity()===i.getEntity()&&this.getTextValue()===i.getTextValue()}}class Vs extends Y{constructor(e,n,s,o){const u=xs(s);super(e,n,s,a.CompoundTypes,u);I(this,zs);I(this,te);y(this,te,o);for(let f=0;f<c(this,te).length;f++)if(s!==t.DictDefinition){c(this,te)[f].length>1&&(c(this,te)[f]=K.createTree(c(this,te)[f]));for(const g of c(this,te)[f])g.setParent(this),this.addConnection(g)}else for(let g=0;g<c(this,te)[f].length;g++){c(this,te)[f][g].length>1&&(c(this,te)[f][g]=K.createTree(c(this,te)[f][g]));for(const w of c(this,te)[f][g])w.setParent(this),this.addConnection(w)}this.addRule(m(this,zs,xa))}isComplete(){this.getChildren().length>1}getVariableExpressions(){let e=[];for(let n of c(this,te))for(let s of n)if(this.getEntity()!==t.DictDefinition)s.is(t.VariableName)?e.push(s):e=e.concat(s.getVariableExpressions());else for(let o of s)o.is(t.VariableName)?e.push(o):e=e.concat(o.getVariableExpressions());return e}contains(e){if(super.contains(e))return!0;for(let n of c(this,te))for(let s of n)if(this.getEntity()!==t.DictDefinition){if(s.contains(e))return!0}else for(let o of s)if(o.contains(e))return!0;return!1}getExpressionsOfKind(e){let n=super.getExpressionsOfKind(e);for(let s of c(this,te))for(let o of s)if(this.getEntity()!==t.DictDefinition)o.is(e)?n.push(o):n=n.concat(o.getExpressionsOfKind(e));else for(let u of o)u.is(e)?n.push(u):n=n.concat(u.getExpressionsOfKind(e));return n}getFirstExpressionOf(e){let n=super.getFirstExpressionOf(e);if(n===void 0)for(const s of c(this,te))for(const o of s)if(this.getEntity()!==t.DictDefinition){if(o.isOneOf(e))return o;if(n=o.getFirstExpressionOf(e),n!==void 0)return n}else for(const u of o){if(u.isOneOf(e))return u;if(n=u.getFirstExpressionOf(e),n!==void 0)return n}return n}setDataType(e){throw new Error("Can't update the type of a compound expression")}checkForSymptoms(){this.checkRules(this);for(const e of c(this,te))for(const n of e)if(this.getEntity()!==t.DictDefinition)n.checkForSymptoms();else for(const s of n)s.checkForSymptoms()}matchesPattern(e){return this.getEntity()===e.getEntity()}getAllNestedExpressions(){return this.getEntity()!==t.DictDefinition?[...super.getAllNestedExpressions(),...c(this,te).flatMap(e=>e.flatMap(n=>n.getAllNestedExpressions()))]:[...super.getAllNestedExpressions(),...c(this,te).flatMap(e=>e.flatMap(n=>n.flatMap(s=>s.getAllNestedExpressions())))]}toJSON(){const e=super.toJSON();try{e.elements=c(this,te).map(n=>n.map(s=>s.toJSON()))}catch{e.elements=c(this,te).map(s=>s.map(o=>o.map(u=>u.toJSON())))}return e}getElements(){return c(this,te)}}te=new WeakMap,zs=new WeakSet,xa=function(e){const n=[];return(e.getParent()===void 0||e.getParent().is(t.GroupStatement)&&e.getParent().getParent()===void 0)&&n.push(M.createStatementSymptom(b.UnusedValue,[e],0,0)),n};class nt extends Y{constructor(e,n,s){super(e,n,s,a.BlockDefinitionStatement,d.NA);I(this,yn);I(this,le,[]);if(n.length>1){const o=m(this,yn,Da).call(this);let u=K.createTree(n.slice(1,o));if(s===t.ForDefinitionStatement&&u.length>0)if(u[0].is(t.IteratorExpression))y(this,le,u);else if(u[0].is(t.ComparisonExpression)){u[0]=u[0].convertToIterator(),y(this,le,[u[0]]);const f=u.slice(1).filter(g=>!g.is(t.Colon));f.length>0&&y(this,le,c(this,le).concat(f))}else u=[new wi(e,u)],y(this,le,u);else s===t.WithDefinitionStatement||s===t.ExceptDefinitionStatement?u.length===3&&u[1].is(t.AsKeyword)&&u[2].is(t.VariableName)&&y(this,le,[new Lr(e,u)]):y(this,le,u);for(const f of u)f.setParent(this),this.addConnection(f)}s===t.WhileDefinitionStatement&&this.addRule(m(this,yn,Ba))}isComplete(){const e=this.getChildren();return e.length>=2?e[0].is(a.BlockDefinitions)&&e[e.length-1].is(t.Colon):!1}setDataType(e){throw new Error("Can't update the type of a block definition")}getVariableExpressions(){let e=[];for(let n of c(this,le))n.is(t.VariableName)?e.push(n):e=e.concat(n.getVariableExpressions());return e}getExpressionsOfKind(e){let n=super.getExpressionsOfKind(e);for(let s of c(this,le))s.is(e)?n.push(s):n=n.concat(s.getExpressionsOfKind(e));return n}getFirstExpressionOf(e){let n=super.getFirstExpressionOf(e);if(n===void 0)for(const s of c(this,le)){if(s.isOneOf(e))return s;if(n=s.getFirstExpressionOf(e),n!==void 0)return n}return n}checkForSymptoms(){this.checkRules(this);for(const e of c(this,le))e.checkForSymptoms()}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...c(this,le).flatMap(n=>n.getAllNestedExpressions())]}getCondition(){return c(this,le)}toJSON(){const e=super.toJSON();return e.keyword=this.getChildren()[0].getTextValue(),e.condition=c(this,le).map(n=>n.toJSON()),e}getCondition(){return c(this,le)}getBlockEntity(){return this.getChildren()[0].getEntity()}}le=new WeakMap,yn=new WeakSet,Da=function(){const e=this.getChildren();for(let n=e.length-1;n>=0;n--)if(e[n].is(t.Colon))return n;return e.length},Ba=function(e){const n=[],s=e.getChildren();if(e.is(t.WhileDefinitionStatement)){const o=c(e,le);oe(s,!0),o.length===1&&(o[0].is(t.TrueType)||o[0].is(t.GroupStatement)&&o[0].getContents().length===1&&o[0].getContents()[0].is(t.TrueType))&&n.push(M.createStatementSymptom(b.WhileTrue,s,0,s.length-1))}return n};class Lr extends Y{constructor(e,n){super(e,n,t.AssignmentStatement,a.Assignment,d.NotParsed);I(this,_);I(this,X,[]);I(this,we,[]);m(this,_,Aa).call(this),this.addRules([m(this,_,Ra),m(this,_,Va),m(this,_,va)])}getVariableExpressions(){let e=[];for(let n of c(this,we))e=e.concat(n.getVariableExpressions());for(let n of c(this,X))e=e.concat(n.getVariableExpressions());return e}setDataType(e){e=Nt(c(this,X).map(n=>n.getDataType())),super.setDataType(e)}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...c(this,X).flatMap(n=>n.getAllNestedExpressions()),...c(this,we).flatMap(n=>n.getAllNestedExpressions())]}toJSON(){const e=super.toJSON();return e.targets=c(this,X).map(n=>n.toJSON()),e.values=c(this,we).map(n=>n.toJSON()),e}getTargetVariables(){return c(this,X)}getAssignedValues(){return c(this,we)}}X=new WeakMap,we=new WeakMap,_=new WeakSet,Aa=function(){const e=this.getChildren();Zt(e,t.AssignmentOperator)>0?m(this,_,Pa).call(this,e):Zt(e,t.AsKeyword)>0&&m(this,_,ka).call(this,e)},ka=function(e){const n=K.split(e,t.AsKeyword),s=[];for(let o=0;o<n.length;o++)s.push(K.split(n[o],t.Comma));if(n.length===2&&s.length===2){for(let o of s[1])o[0].is(t.VariableName)?o[0].setAssignedOrChanged():o[0].is(t.PropertyCallExpression)&&o[0].getProperty().is(t.PropertyName)&&o[0].getProperty().setAssignedOrChanged(),c(this,X).push(o[0]);for(let o of s[0])c(this,we).push(o[0])}c(this,X).length===c(this,we).length?m(this,_,Xi).call(this):c(this,X).length>c(this,we).length?m(this,_,Zi).call(this):m(this,_,Yi).call(this)},Pa=function(e){const n=K.split(e,t.AssignmentOperator),s=[];for(let o=0;o<n.length;o++){const u=K.split(n[o],t.Comma);s.push(u)}if(n.length===2&&s.length===2){for(let o of s[0])o[0].is(t.VariableName)?o[0].setAssignedOrChanged():o[0].is(t.SubscriptedExpression)&&o[0].getChildren()[0].is(t.VariableName)?o[0].getChildren()[0].setAssignedOrChanged():o[0].is(t.PropertyCallExpression)&&o[0].getProperty().is(t.PropertyName)&&o[0].getProperty().setAssignedOrChanged(),c(this,X).push(o[0]);for(let o of s[1])c(this,we).push(o[0])}c(this,X).length===c(this,we).length?m(this,_,Xi).call(this):c(this,X).length>c(this,we).length?m(this,_,Zi).call(this):m(this,_,Yi).call(this);for(const o of c(this,X))o.addObserver(this),this.addConnection(o);this.setDataType(Nt(c(this,X).map(o=>o.getDataType())))},Xi=function(){for(let e=0;e<c(this,X).length;e++)c(this,X)[e].isOneOf([t.VariableName,t.SubscriptedExpression,t.PropertyCallExpression])?(c(this,X)[e].setDataType(c(this,we)[e].getDataType()),c(this,we)[e].addObserver(c(this,X)[e]),c(this,we)[e].addConnection(c(this,X)[e])):c(this,X)[e].is(t.TupleDefinition)?m(this,_,La).call(this,c(this,X)[e]):c(this,X)[e].is(a.SpecialVariables)||this.setDataType(d.Invalid)},La=function(e){for(let n of e.getElements())n[0].isOneOf([t.VariableName,t.SubscriptedExpression])&&n[0].setDataType(d.Unknown)},Zi=function(){for(let e of c(this,X))e.isOneOf([t.VariableName,t.SubscriptedExpression])?e.setDataType(d.Unknown):console.log("stop")},Yi=function(){for(let e of c(this,X))e.isOneOf([t.VariableName,t.SubscriptedExpression])?e.setDataType(d.Tuple):console.log("stop")},Va=function(e){const n=[];for(const s of e.getTargetVariables()){const o=We(s.getTextValue()).category;s.is(t.VariableName)&&s.getLastUsages().length===0&&o===a.BuiltInFunctions?n.push(M.createStatementSymptom(b.VariableWithSameNameAsFunction,[s],0,0,{funcType:Qt,varIsParameter:s.isParameter()})):(o===a.BlockDefinitions||o===a.LogicalOperators||o===a.Types||o===a.OtherKeywords)&&s.getTextValue()!=="f"&&s.getTextValue()!=="r"&&n.push(M.createStatementSymptom(b.ReservedWordAssigned,[s],0,0))}return n},va=function(e){const n=[],s=e.getAssignedValues();for(let o=0;o<s.length;o++)s[o].is(t.Colon)&&n.push(M.createStatementSymptom(b.UnexpectedColon,s,0,s.length-1,{before:o>0?s[o-1].getTextValue():ce,after:o<s.length-1?s[o+1].getTextValue():ce}));return n},Ra=function(e){const n=[],u=e.getAssignedValues().flatMap(f=>f.is(t.GroupStatement)?f.getContents():f).filter(f=>Ct(f)||f.getDataType()===d.None&&!f.isOneOf([t.NoneType,t.VariableName]));return u.length>0&&n.push(...u.map(f=>M.createStatementSymptom(b.AssignedNone,[f],0,0,{expression:f,usage:oi,target:c(e,X)[0].getTextValue()}))),n};class cu extends Y{constructor(e,n){super(e,n,t.ChangeStatement,a.Assignment,d.NA);I(this,Ee);I(this,Ue,[]);I(this,ke,-1);I(this,Fn,[]);I(this,ot);m(this,Ee,Ua).call(this),this.addRule(m(this,Ee,Ja))}getVariableExpressions(){let e=[];for(let n of c(this,Fn))e=e.concat(n.getVariableExpressions());for(let n of c(this,Ue))e=e.concat(n.getVariableExpressions());return e}getAssignedValue(){return c(this,ot)}getTargetVariables(){return c(this,Ue)}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...c(this,Ue).flatMap(n=>n.getAllNestedExpressions()),...c(this,ot).getAllNestedExpressions()]}toJSON(){const e=super.toJSON();return e.target=c(this,Ue)[0].toJSON(),e.operator=this.getChildren()[c(this,ke)].toJSON(),e.changeValue=c(this,ot).toJSON(),e}}Ue=new WeakMap,ke=new WeakMap,Fn=new WeakMap,ot=new WeakMap,Ee=new WeakSet,Ua=function(){m(this,Ee,$a).call(this);const e=this.getChildren();if(c(this,ke)===1&&e.length===3)e[0].is(t.VariableName)?e[0].setAssignedOrChanged():e[0].is(t.SubscriptedExpression)&&e[0].getChildren()[0].is(t.VariableName)?e[0].getChildren()[0].setAssignedOrChanged():e[0].is(t.PropertyCallExpression)&&e[0].getProperty().is(t.PropertyName)&&e[0].getProperty().setAssignedOrChanged(),c(this,Ue).push(e[0]),y(this,ot,e[2]),this.addConnection(e[0]),e[2].addConnection(e[0]),e[0].isOneOf([t.VariableName,t.SubscriptedExpression])?m(this,Ee,Ea).call(this):this.setDataType(d.Invalid);else if(c(this,ke)===1&&e.length>3&&Un(e,t.Comma)){this.setDataType(d.Tuple);const n=e.slice(2),s=K.split(n,t.Comma),o=new Vs(oe(n),n,t.TupleDefinition,s);for(o.setParent(this);e.length>2;)e.pop();e.push(o),c(this,Ue).push(e[0]),y(this,ot,e[2])}else this.setDataType(d.Invalid),y(this,ot,e[c(this,ke)-1]),y(this,Ue,c(this,ke)>-1?e.slice(0,c(this,ke)):[]),y(this,Fn,c(this,ke)>-1?e.slice(c(this,ke)+1):[])},Ea=function(){const e=m(this,Ee,Ga).call(this),n=c(this,Ue)[0],s=[new Br(e.entity.name,e.entity,e.category,-1,-1),this.getChildren()[2]];if(n.is(t.VariableName)){const u=new Yt(n.getTextValue(),n.getEntity(),n.getCategory(),-1,-1,-1,!0);s.unshift(u)}else{const u=n.getChildren(),f=new vs("Placeholder",[u[0],u[1]]);s.unshift(f)}const o=new Rs("Placeholder",s);c(this,Fn).push(o),n.setDataType(o.getDataType()),o.addObserver(n)},Ga=function(){const n=this.getChildren()[c(this,ke)].getTextValue().replace("=","");return We(n)},$a=function(){const e=this.getChildren();for(let n=0;n<e.length;n++)if(e[n].isChangeOperator()){y(this,ke,n);break}},Ja=function(e){const n=[],s=e.getAssignedValue();return(s.getDataType()===d.None&&!s.isOneOf([t.NoneType,t.VariableName])||Ct(s))&&n.push(M.createStatementSymptom(b.AssignedNone,[s],0,0,{expression:s,usage:oi,target:c(e,Ue)[0].getTextValue()})),n};class uu extends Y{constructor(e,n){super(e,n,t.GroupStatement,a.Group,d.NotParsed);I(this,Tn);I(this,ne);if(n.length>2){const s=n.slice(1,n.length-1);s.length>1?y(this,ne,K.createTree(n.slice(1,n.length-1))):y(this,ne,[s[0]])}else y(this,ne,[]);m(this,Tn,Ka).call(this),this.setDataType(c(this,ne).length===1?c(this,ne)[0].getDataType():d.Unknown),c(this,ne).length===1?c(this,ne)[0].addObserver(this):this.setDataType(d.Invalid),this.addRule(m(this,Tn,Wa))}getContents(){return c(this,ne)}getVariableExpressions(){let e=[];for(let n of c(this,ne))e=e.concat(n.getVariableExpressions());return e}getExpressionsOfKind(e){let n=super.getExpressionsOfKind(e);for(let s of c(this,ne))s.is(e)?n.push(s):n=n.concat(s.getExpressionsOfKind(e));return n}getFirstExpressionOf(e){let n=super.getFirstExpressionOf(e);if(n===void 0)for(const s of c(this,ne)){if(s.isOneOf(e))return s;if(n=s.getFirstExpressionOf(e),n!==void 0)return n}return n}checkForSymptoms(){this.checkRules(this);for(const e of c(this,ne))e.checkForSymptoms()}matchesPattern(e){const n=this.getContents();for(const s of n)if(!s.matchesPattern(e))return!1;return!0}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...c(this,ne).flatMap(n=>n.getAllNestedExpressions())]}toJSON(){const e=super.toJSON();return e.contents=c(this,ne).map(n=>n.toJSON()),e}}ne=new WeakMap,Tn=new WeakSet,Ka=function(){for(let e=0;e<c(this,ne).length;e++)e<c(this,ne).length-1&&c(this,ne)[e].addConnection(c(this,ne)[e+1]),c(this,ne)[e].setParent(this),this.addConnection(c(this,ne)[e])},Wa=function(e){const n=[],s=e.getContents();for(let o=0;o<s.length;o++)s[o].is(t.Colon)&&n.push(M.createStatementSymptom(b.UnexpectedColon,s,0,s.length-1,{before:o>0?s[o-1].getTextValue():ce,after:o<s.length-1?s[o+1].getTextValue():ce}));return n};class Vr extends Y{constructor(e,n,s=[]){super(e,n,t.Slice,a.Other,d.NA);I(this,Oe);y(this,Oe,s);for(let o=0;o<c(this,Oe).length;o++){c(this,Oe)[o].length>1&&(c(this,Oe)[o]=K.createTree(c(this,Oe)[o]));for(const u of c(this,Oe)[o])u.setParent(this),this.addConnection(u)}}isComplete(){const e=this.getChildren();return e.length>=4&&e[0].is(t.OpenSquareBracket)&&e[e.length-1].is(t.CloseSquareBracket)&&Un(e,t.Colon)}getVariableExpressions(){let e=[];for(let n of c(this,Oe))for(let s of n)e=e.concat(s.getVariableExpressions());return e}checkForSymptoms(){this.checkRules(this);for(const e of c(this,Oe))for(const n of e)n.checkForSymptoms()}matchesPattern(e){return this.getEntity()===e.getEntity()}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...c(this,Oe).flatMap(n=>n.flatMap(s=>s.getAllNestedExpressions()))]}toJSON(){const e=super.toJSON();return e.indices=c(this,Oe).map(n=>n.map(s=>s.toJSON())),e}getIndices(){return c(this,Oe)}}Oe=new WeakMap;class vr extends Y{constructor(e,n){super(e,n,t.IndexKey,a.Other,d.NA);I(this,at,[]);n.length>2&&y(this,at,K.createTree(n.slice(1,n.length-1)));for(const s of c(this,at))s.setParent(this),this.addConnection(s)}isComplete(){const e=this.getChildren();return e.length>=3&&e[0].is(t.OpenSquareBracket)&&e[e.length-1].is(t.CloseSquareBracket)}getVariableExpressions(){let e=[];for(let n of c(this,at))e=e.concat(n.getVariableExpressions());return e}checkForSymptoms(){this.checkRules(this);for(const e of c(this,at))e.checkForSymptoms()}matchesPattern(e){return this.getEntity()===e.getEntity()}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...c(this,at).flatMap(n=>n.getAllNestedExpressions())]}toJSON(){const e=super.toJSON();return e.index=c(this,at).map(n=>n.toJSON()),e}}at=new WeakMap;const us=class us extends Y{constructor(e,n){var o;let s=m(o=us,cs,_i).call(o,n);super(e,n,t.SubscriptedExpression,a.MultipartValue,s);I(this,Nn);n[0].addObserver(this);for(const u of n)this.addConnection(u);this.addRules([m(this,Nn,ja),m(this,Nn,qa)])}matchesPattern(e){if(this.getEntity()!==e.getEntity())return!1;const n=this.getChildren(),s=e.getChildren();return n.length>0&&s.length>0&&n[0].matchesPattern(s[0])}isComplete(){const e=this.getChildren();return e.length===2&&e[1].isOneOf(t.IndexKey,t.Slice)}setDataType(e){var s;const n=m(s=us,cs,_i).call(s,this.getChildren());super.setDataType(n)}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...this.getChildren().flatMap(n=>n.getAllNestedExpressions())]}toJSON(){const e=super.toJSON();return e.nodes=this.getChildren().map(n=>n.toJSON()),e}};Nn=new WeakSet,qa=function(e){const n=[];return(e.getParent()===void 0||e.getParent().is(t.GroupStatement)&&e.getParent().getParent()===void 0)&&n.push(M.createStatementSymptom(b.UnusedValue,[e],0,0)),n},ja=function(e){const n=[],s=e.getChildren();return s.length>0&&!Ds(s[0].getDataType())&&n.push(M.createStatementSymptom(b.SubscriptedNonSubscriptable,s,0,s.length-1,{isUndefined:s[0].getDataType()===d.Undefined,subscriptedType:s[0].getDataType(),varName:s[0].getTextValue()})),n},cs=new WeakSet,_i=function(e){if(e.length!==2)return d.Unknown;if(e[0].getDataType()===d.String)return d.String;if(e[1].is(t.Slice)){const n=e[0].getDataType();return n===d.NotParsed||n===d.Unknown||n===d.List||n===d.Tuple||n===d.String?n:d.Invalid}return d.Unknown},I(us,cs);let vs=us;const Ut=class Ut extends Y{constructor(e,n){var o,u;let s=n.length===3?m(o=Ut,_e,er).call(o,...n):n.length===2?m(u=Ut,_e,tr).call(u,n[1]):d.Unknown;super(e,n,t.CalculatedExpression,a.MultipartValue,s);I(this,Ge);n.length===3?(n[0]!==void 0&&n[0].addObserver(this),n[2]!==void 0&&n[2].addObserver(this)):n.length>0&&n[1]!==void 0&&n[1].addObserver(this),m(this,Ge,Ha).call(this),this.addRules([m(this,Ge,Ya),m(this,Ge,Za),m(this,Ge,Xa),m(this,Ge,Qa)])}setDataType(e){var s,o;const n=this.getChildren();e=n.length===3?m(s=Ut,_e,er).call(s,...n):m(o=Ut,_e,tr).call(o,n[1]),super.setDataType(e)}matchesPattern(e){if(this.getEntity()!==e.getEntity())return!1;const n=this.getChildren(),s=e.getChildren();if(n.length!==s.length)return!1;const o=new Map;for(const u of n){let f=!1;for(const g of s)if(u.matchesPattern(g)){f=!0;break}if(!f&&!u.is(t.VariableName))return!1;u.is(t.VariableName)&&o.set(u.getTextValue(),f)}return o.size===0?!0:Array.from(o.values()).filter(u=>u===!0).length>0}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...this.getChildren().flatMap(n=>n.getAllNestedExpressions())]}toJSON(){const e=super.toJSON();return e.nodes=this.getChildren().map(n=>n.toJSON()),e}};Ge=new WeakSet,Ha=function(){const e=this.getChildren();for(let n=0;n<e.length;n++)this.addConnection(e[n]),n<e.length-1&&e[n].addConnection(e[n+1])},_e=new WeakSet,er=function(e,n,s){const o=e.getDataType(),u=s.getDataType();return e.is(t.StringLiteral)&&n.is(t.ModulusOperator)?d.String:o===d.NotParsed||u===d.NotParsed?d.NotParsed:o===d.Undefined&&e.is(t.VariableName)&&e.isProxy()||u===d.Undefined&&s.is(t.VariableName)&&s.isProxy()?d.Undefined:o===d.Unknown||u===d.Unknown?d.Unknown:o===d.Invalid||u===d.Invalid||o===d.NA||u===d.NA?d.Invalid:e.isNumeric()&&s.isNumeric()?m(this,_e,za).call(this,e,n,s):n.isOneOf([t.ExponentOperator,t.DivideOperator,t.IntDivideOperator])?d.Invalid:n.is(t.MultiplyOperator)?e.isNonFloatNumeric()&&(u===d.String||u===d.List||u===d.Tuple)?u:s.isNonFloatNumeric()&&(o===d.String||o===d.List||o===d.Tuple)?o:d.Invalid:n.is(t.ModulusOperator)?o===d.String?d.String:d.Invalid:n.is(t.AddOperator)?o===u&&(o===d.String||o===d.List||o===d.Tuple)||o===d.List&&(u===d.String||u===d.Dict||u===d.Set||u===d.Tuple)?o:d.Invalid:n.is(t.SubtractOperator)&&o===d.Set&&o===u?o:d.Invalid},tr=function(e){const n=e.getDataType();return n===d.Float||n===d.Int||n===d.Number||n===d.NotParsed||n===d.Unknown?n:n===d.Bool?d.Int:d.Invalid},za=function(e,n,s){return n.is(t.DivideOperator)?d.Float:e.getDataType()===s.getDataType()&&e.getDataType()!==d.Bool?e.getDataType():e.isIntLike()&&s.isIntLike()?d.Int:e.getDataType()===d.Float||s.getDataType()===d.Float?d.Float:d.Number},Qa=function(e){const n=[];return(e.getParent()===void 0||e.getParent().is(t.GroupStatement)&&e.getParent().getParent()===void 0)&&n.push(M.createStatementSymptom(b.UnusedValue,[e],0,0)),n},Xa=function(e){const n=[],s=e.getChildren();for(let o=0;o<s.length;o++)s[o].is(t.Colon)&&n.push(M.createStatementSymptom(b.UnexpectedColon,s,0,s.length-1,{before:o>0?s[o-1].getTextValue():ce,after:o<s.length-1?s[o+1].getTextValue():ce}));return n},Za=function(e){const n=[],s=e.getChildren();return e.getDataType()===d.Invalid&&s.filter(o=>o.getDataType()===d.Undefined||o.getDataType()===d.Invalid).length===0&&n.push(M.createStatementSymptom(b.TypeErrorInvalid,s,0,s.length-1,{parts:s.map(o=>o.getDataType()===d.NA?o.getTextValue():o.getDataType().name)})),n},Ya=function(e){const n=[],u=e.getChildren().flatMap(f=>f.is(t.GroupStatement)?f.getContents():f).filter(f=>Ct(f)||f.getDataType()===d.None&&!f.isOneOf([t.NoneType,t.VariableName]));return u.length>0&&n.push(...u.map(f=>M.createStatementSymptom(b.AssignedNone,[f],0,0,{expression:f,usage:lc}))),n},I(Ut,_e);let Rs=Ut;const hs=class hs extends Y{constructor(e,n){var o;let s=n.length===3?m(o=hs,ds,nr).call(o,...n):d.Unknown;super(e,n,t.ComparisonExpression,a.MultipartValue,s);I(this,$e);n.length===3&&(n[0].addObserver(this),n[2].addObserver(this)),m(this,$e,_a).call(this),this.addRules([m(this,$e,sl),m(this,$e,nl),m(this,$e,tl),m(this,$e,el)])}setDataType(e){var s;const n=m(s=hs,ds,nr).call(s,...this.getChildren());n!==this.getDataType()&&super.setDataType(n)}matchesPattern(e){if(this.getEntity()!==e.getEntity())return!1;const n=this.getChildren(),s=e.getChildren();if(n.length!==s.length)return!1;const o=new Map;for(let u=0;u<n.length;u++){if(n[u].isOneOf([t.InKeyword,t.NotInKeyword])){const g=n[u].is(t.InKeyword)?t.NotInKeyword:t.InKeyword;for(let w=0;w<s.length;w++)if(s[w].is(g))return u>0&&u<n.length-1&&w>0&&w<s.length-1?n[u-1].matchesPattern(s[w-1])&&n[u+1].matchesPattern(s[w+1]):!1;return!1}let f=!1;for(const g of s)if(n[u].matchesPattern(g)){f=!0;break}if(!f&&!n[u].isOneOf([t.VariableName,t.BuiltInFunctionCall,t.UserDefinedFunctionCall,t.SubscriptedExpression]))return!1;n[u].isOneOf([t.VariableName,t.BuiltInFunctionCall,t.UserDefinedFunctionCall,t.SubscriptedExpression,t.CalculatedExpression])&&o.set(n[u].getTextValue(),f)}return o.size===0?!1:Array.from(o.values()).filter(u=>u===!0).length>0}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...this.getChildren().flatMap(n=>n.getAllNestedExpressions())]}toJSON(){const e=super.toJSON();return e.nodes=this.getChildren().map(n=>n.toJSON()),e}convertToIterator(){const e=this.getChildren();return e.length===3&&(e[0].removeObserver(this),e[2].removeObserver(this)),new wi(this.getTextValue(),e)}};$e=new WeakSet,_a=function(){const e=this.getChildren();for(let n=0;n<e.length;n++)this.addConnection(e[n]),n<e.length-1&&e[n].addConnection(e[n+1])},ds=new WeakSet,nr=function(e,n,s){const o=e.getDataType(),u=s.getDataType();return n.isOneOf([t.EqualOperator,t.NotEqualOperator,t.IsKeyword,t.IsNotKeyword])?d.Bool:n.isOneOf([t.InKeyword,t.NotInKeyword])?u===d.String&&(o===d.String||o===d.Unknown||o===d.NotParsed)||u===d.List||u===d.Tuple||u===d.Set||u===d.Dict||u===d.Unknown?d.Bool:u===d.NotParsed?d.NotParsed:d.Invalid:o===d.NotParsed||u===d.NotParsed?d.NotParsed:o===d.None||u===d.None?d.Invalid:o===d.Unknown||u===d.Unknown||e.isNumeric()&&s.isNumeric()||o===u?d.Bool:d.Invalid},el=function(e){const n=[],s=e.getChildren();return!(s[0]!==void 0&&s[0].is(t.BuiltInFunctionCall)&&s[0].getFunctionExpression().is(t.AssertFunction))&&(e.getParent()===void 0||e.getParent().is(t.GroupStatement)&&e.getParent().getParent()===void 0)&&n.push(M.createStatementSymptom(b.UnusedValue,[e],0,0)),n},tl=function(e){const n=[],s=e.getChildren();for(let o=0;o<s.length;o++)s[o].is(t.Colon)&&n.push(M.createStatementSymptom(b.UnexpectedColon,s,0,s.length-1,{before:o>0?s[o-1].getTextValue():ce,after:o<s.length-1?s[o+1].getTextValue():ce}));return n},nl=function(e){const n=[],s=e.getChildren();return s.length===3&&s[0].getDataType()===d.Bool&&s[1].isOneOf([t.EqualOperator,t.IsKeyword])&&s[2].isOneOf([t.TrueType,t.FalseType])&&n.push(M.createStatementSymptom(b.CompareBoolLiteral,s,0,s.length-1,{boolValue:s[0].getTextValue(),operator:s[1].getTextValue(),boolLiteral:s[2].getTextValue(),usedIn:e.getContextOfUse()})),n},sl=function(e){const n=[],u=e.getChildren().flatMap(f=>f.is(t.GroupStatement)?f.getContents():f).filter(f=>!(f.is(t.BuiltInFunctionCall)&&f.getFunctionExpression().is(t.AssertFunction))&&(Ct(f)||f.getDataType()===d.None&&!f.isOneOf([t.NoneType,t.VariableName])));return u.length>0&&n.push(...u.map(f=>M.createStatementSymptom(b.AssignedNone,[f],0,0,{expression:f,usage:cc}))),n},I(hs,ds);let pi=hs;const gs=class gs extends Y{constructor(e,n){var o;const s=m(o=gs,fs,sr).call(o,n);super(e,n,t.BooleanExpression,a.MultipartValue,s);I(this,je);n.length===3&&n[1].is(a.LogicalOperators)&&(n[0].addObserver(this),n[2].addObserver(this)),m(this,je,il).call(this),this.addRules([m(this,je,al),m(this,je,ol),m(this,je,rl)])}setDataType(e){var s;const n=m(s=gs,fs,sr).call(s,this.getChildren());n!==this.getDataType()&&super.setDataType(n)}matchesPattern(e){const n=this.getChildren();if(this.getEntity()!==e.getEntity())return e.is(t.VariableName)&&n.length===2&&n[0].is(t.NotOperator)&&n[1].is(t.VariableName)?n[1].matchesPattern(e):!1;const s=e.getChildren(),o=new Map;for(const u of n){if(u.is(t.NotOperator))continue;let f=!1;for(const g of s)if(!g.is(t.NotOperator)&&u.matchesPattern(g)){f=!0;break}if(!f&&!u.is(t.VariableName))return!1;u.is(t.VariableName)&&o.set(u.getTextValue(),f)}return o.size===0?!0:Array.from(o.values()).filter(u=>u===!0).length>0}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...this.getChildren().flatMap(n=>n.getAllNestedExpressions())]}toJSON(){const e=super.toJSON();return e.nodes=this.getChildren().map(n=>n.toJSON()),e}};je=new WeakSet,il=function(){const e=this.getChildren();for(let n=0;n<e.length;n++)this.addConnection(e[n]),n<e.length-1&&e[n].addConnection(e[n+1])},fs=new WeakSet,sr=function(e){if(e.length===2&&e[0].is(t.NotOperator))return d.Bool;if(e.length===3&&e[1].is(a.LogicalOperators)){const n=e[0].getDataType(),s=e[2].getDataType();return n===s?n:n===d.NotParsed||s===d.NotParsed?d.NotParsed:d.Unknown}else return d.Invalid},rl=function(e){const n=[];return(e.getParent()===void 0||e.getParent().is(t.GroupStatement)&&e.getParent().getParent()===void 0)&&n.push(M.createStatementSymptom(b.UnusedValue,[e],0,0)),n},ol=function(e){const n=[],s=e.getChildren();for(let o=0;o<s.length;o++)s[o].is(t.Colon)&&n.push(M.createStatementSymptom(b.UnexpectedColon,s,0,s.length-1,{before:o>0?s[o-1].getTextValue():ce,after:o<s.length-1?s[o+1].getTextValue():ce}));return n},Od=function(e,n){const s=e.getDataType(),o=n.getDataType();return s!==d.Bool&&s!==d.Unknown||o!==d.Bool&&o!==d.Unknown},al=function(e){const n=[],s=e.getChildren();if(s.length===3){const o=s[0].getDataType(),u=s[2].getDataType();(o!==d.Bool&&o!==d.Unknown||u!==d.Bool&&u!==d.Unknown)&&n.push(M.createStatementSymptom(b.NaturalLanguageBoolean,s,0,2,{form:ic,leftSideType:s[0].getDataType(),leftSideText:s[0].getTextValue(),leftSideEntity:s[0].getEntity(),operator:s[1].getTextValue(),rightSideType:s[2].getDataType(),rightSideText:s[2].getTextValue(),rightSideEntity:s[2].getEntity(),tempExpression:e}))}return n},I(gs,fs);let mi=gs;class wi extends Y{constructor(e,n){super(e,n,t.IteratorExpression,a.MultipartValue,d.NA);I(this,be);I(this,Cn);I(this,he);I(this,se,[]);m(this,be,cl).call(this),m(this,be,ll).call(this),this.addRules([m(this,be,hl),m(this,be,dl)])}checkForSymptoms(){this.checkRules(this),c(this,he).checkForSymptoms();for(const e of c(this,se))e.checkForSymptoms()}getVariableExpressions(){let e=c(this,he).getVariableExpressions();for(let n of c(this,se))e=e.concat(n.getVariableExpressions());return e}setDataType(e){m(this,be,ir).call(this)}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...c(this,se).flatMap(n=>n.getAllNestedExpressions()),...c(this,he).getAllNestedExpressions()]}toJSON(){const e=super.toJSON();return e.loopVariables=c(this,se).map(n=>n.toJSON()),e.iterable=c(this,he).toJSON(),e}getLoopVariables(){return c(this,se)}getIterable(){return c(this,he)}}Cn=new WeakMap,he=new WeakMap,se=new WeakMap,be=new WeakSet,ll=function(){const e=this.getChildren();for(let n=0;n<e.length;n++)this.addConnection(e[n]),n<e.length-1&&e[n].addConnection(e[n+1])},cl=function(){const e=this.getChildren();y(this,Cn,Zt(e,t.InKeyword)),y(this,he,e[e.length-1]),y(this,se,c(this,Cn)===1&&e[0].is(t.TupleDefinition)?e[0].getElements().filter(n=>n[0].is(t.VariableName)).map(n=>n[0]):e.slice(0,c(this,Cn)).filter(n=>n.is(t.VariableName)));for(let n of c(this,se))n.setAssignedOrChanged();m(this,be,ul).call(this)},ul=function(){if(c(this,he).isOneOf([t.BuiltInFunctionCall,t.BuiltInMethodCall])){const e=c(this,he).is(t.BuiltInMethodCall)?c(this,he).getMethodEntity():c(this,he).getFunctionEntity();if(e===t.EnumerateFunction)if(c(this,se).length===1)c(this,se)[0].setDataType(d.Tuple);else if(c(this,se).length===2){c(this,se)[0].setDataType(d.Int);const n=c(this,he).getArguments(),s=n.length===1&&n[0].length===1&&n[0][0].getDataType()===d.String?d.String:d.Unknown;c(this,se)[1].setDataType(s)}else for(const n of c(this,se))n.setDataType(d.Unknown);else if(e===t.RangeFunction&&c(this,se).length===1)c(this,se)[0].setDataType(d.Int);else if(Ot.get(e)===d.String&&c(this,se).length===1)c(this,se)[0].setDataType(d.String);else for(const n of c(this,se))n.setDataType(d.Unknown)}else c(this,he).addObserver(this),m(this,be,ir).call(this)},ir=function(){const e=c(this,he).getDataType()===d.String||c(this,he).getDataType()===d.File?d.String:d.Unknown;for(let n of c(this,se))n.setDataType(e)},dl=function(e){const n=[],s=c(e,he).getVariableExpressions();for(const o of c(e,se))for(const u of s)if(o.getTextValue()===u.getTextValue()){const f=o.getLastUsages(),g=u.getLastUsages().length>0&&u.getLastUsages()[0].isParameter();n.push(M.createStatementSymptom(b.OverwrittenVariable,[o],0,0,{isParameter:g,functionBlock:g?f[0].getBlockId():"",prevUsageIsDefinition:!1,overwriteType:sc,overwriteValue:o.compareValues(o,[f[f.length-1]]),usageText:e.getParent().getTextValue(),overwrittenVar:[{lineNumber:f[f.length-1].getStartLineNumber(),blockId:f[f.length-1].getBlockId(),docIndex:f[f.length-1].getDocumentStartIndex(),forLoopDefinition:f[f.length-1].getParent().is(t.IteratorExpression)&&f[f.length-1].getParent().getLoopVariables().filter(w=>w.getTextValue()===f[f.length-1].getTextValue()).length>0}]}))}return n},hl=function(e){const n=[],s=e.getChildren();for(let o=0;o<s.length;o++)s[o].is(t.Colon)&&n.push(M.createStatementSymptom(b.UnexpectedColon,s,0,s.length-1,{before:o>0?s[o-1].getTextValue():ce,after:o<s.length-1?s[o+1].getTextValue():ce}));return n};class du extends Y{constructor(e,n){if(n.length<4)throw new Error("A lambda expression must have a minimum of 4 children");const s=K.split(n.slice(1),t.Colon);if(s.length!==2)throw new Error("Lambda expects at least one argument and a return value");const o=K.split(s[0],t.Comma);for(const f of o)for(const g of f)g.is(t.VariableName)&&(g.setAssignedOrChanged(),g.setDataType(d.Unknown));const u=K.createTree(s[1]);if(u.length!==1)throw new Error("Lambda can only have one return value");super(e,n,t.LambdaDefinitionStatement,a.BlockDefinitions,u[0].getDataType());I(this,ps);I(this,ms);y(this,ps,o),y(this,ms,u[0]),u[0].addObserver(this)}getVariableExpressions(){let e=[];for(let n of this.getChildren())n.is(t.VariableName)?e.push(n):e=e.concat(n.getVariableExpressions());return e}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...this.getChildren().flatMap(n=>n.getAllNestedExpressions())]}toJSON(){const e=super.toJSON();return e.arguments=c(this,ps).map(n=>n.map(s=>s.toJSON())),e.return=c(this,ms).toJSON(),e}}ps=new WeakMap,ms=new WeakMap;const Ss=class Ss extends Y{constructor(e,n){var o;if(n.length!==5)throw new Error("Ternary should contain 5 children");let s=m(o=Ss,ws,rr).call(o,n);super(e,n,t.TernaryStatement,a.BlockDefinitionStatement,s);I(this,Qs);n[0].addObserver(this),n[4].addObserver(this),this.addRule(m(this,Qs,fl))}setDataType(e){var s;const n=m(s=Ss,ws,rr).call(s,this.getChildren());n!==this.getDataType()&&super.setDataType(n)}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...this.getChildren().flatMap(n=>n.getAllNestedExpressions())]}toJSON(){const e=super.toJSON();return e.nodes=this.getChildren().map(n=>n.toJSON()),e}};ws=new WeakSet,rr=function(e){return e.length===5?Nt([e[0].getDataType(),e[4].getDataType()]):d.Unknown},Qs=new WeakSet,fl=function(e){const n=[];if(e.getDataType()===d.Bool){const s=e.getChildren();if(s[0].is(t.TrueType)&&s[4].is(t.FalseType)){let o=e.getParent();for(;o.is(t.GroupStatement);)o=o.getParent();const u=f=>{switch(f){case t.ReturnStatement.name:return"return";case t.AssignmentStatement.name:return"assignment";default:return"unknown"}};n.push(M.createStatementSymptom(b.TernaryReturnsBool,s,0,s.length-1,{boolValue:s[2].getTextValue(),boolLiteralIfTrue:s[0].getTextValue(),boolLiteralIfFalse:s[4].getTextValue(),parentText:o?o.getTextValue():"",parentEntity:o?u(o.getEntity().name):""}))}}return n},I(Ss,ws);let Si=Ss;const Ci=class Ci extends Y{constructor(e,n){if(n.length<3||n.length>5)throw new Error("List comprehension should contain 3-5 children");super(e,n,t.ListComprehension,a.BlockDefinitionStatement,d.List);I(this,On);const s=`${n[0].getStartLineNumber()}-listComprehension-${n[0].getDocumentStartIndex()}`;this.setBlockId(s),this.setScopeId(s),m(this,On,pl).call(this)}getVariableExpressions(){let e=[];const n=this.getChildren(),s=m(this,On,gl).call(this);if(s>-1){e=e.concat(n[s].getVariableExpressions());for(let o=0;o<n.length;o++)o!==s&&(e=e.concat(n[o].getVariableExpressions()))}return e}copyAndConvertToPlaceholder(){const e=new Ci(this.getTextValue(),this.getChildren());return this.setTextValue(""),this.setChildren([]),e}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...this.getChildren().flatMap(n=>n.getAllNestedExpressions())]}toJSON(){const e=super.toJSON();return e.nodes=this.getChildren().map(n=>n.toJSON()),e}};On=new WeakSet,gl=function(){const e=this.getChildren();for(let n=0;n<e.length;n++)if(e[n].is(t.IteratorExpression))return n;return-1},pl=function(){const e=this.getChildren();if(e.length>0&&e[0].is(t.ListComprehension)&&e[2].is(t.IteratorExpression)){const n=e[0].getChildren();if(n.length>=3&&n[2].is(t.IteratorExpression)){const s=e[2].getIterable(),o=n[2].getLoopVariables();for(const u of o)u.getTextValue()===s.getTextValue()&&(u.addObserver(s),s.setDataType(u.getDataType()),s.setAssignedOrChanged())}}};let Ii=Ci;class hu extends Y{constructor(e,n){if(n.length===0||!n[0].is(t.ReturnKeyword))throw new Error("Not a valid return statement");let s=d.None;if(n.length===2)s=n[1].getDataType();else if(n.length>2)if(Un(n,t.Comma)){s=d.Tuple;const o=n.slice(1),u=K.split(o,t.Comma),f=new Vs(oe(o),o,t.TupleDefinition,u);n=[n[0],f]}else s=d.Invalid;super(e,n,t.ReturnStatement,a.MultipartValue,s);I(this,Je);n.length===2&&(n[1].addObserver(this),this.addConnection(n[1])),this.addRules([m(this,Je,bl),m(this,Je,Il),m(this,Je,ml),m(this,Je,Sl)])}getReturnedValue(){return this.getChildren().slice(1)}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...this.getChildren().flatMap(n=>n.getAllNestedExpressions()).slice(1)]}toJSON(){const e=super.toJSON();return e.returnedValue=this.getReturnedValue().map(n=>n.toJSON()),e}}Je=new WeakSet,ml=function(e){var o;const n=[],s=e.getChildren();return s.length===2&&s[1].is(t.GroupStatement)&&n.push(M.createStatementSymptom(b.ReturnInParentheses,s,0,1,{contents:m(o=e,Je,wl).call(o,s[1]),textInParentheses:s[1].getTextValue().substring(1,s[1].getTextValue().length-1)})),n},wl=function(e){const n=e.getContents();if(n.length===1){if(n[0].isOneOf([a.Literals,a.Types]))return tc;if(n[0].isOneOf([t.VariableName,t.SubscriptedExpression]))return nc;if(n[0].isOneOf([a.FunctionCall,a.MethodCall]))return hr;if(n[0].is(a.CompoundTypes))return fr}return gr},Sl=function(e){const n=[],s=e.getChildren();for(let o=0;o<s.length;o++)s[o].is(t.Colon)&&n.push(M.createStatementSymptom(b.UnexpectedColon,s,0,s.length-1,{before:o>0?s[o-1].getTextValue():ce,after:o<s.length-1?s[o+1].getTextValue():ce}));return n},Il=function(e){const n=[],u=e.getChildren().flatMap(f=>f.is(t.GroupStatement)?f.getContents():f).filter(f=>Ct(f)||f.getDataType()===d.None&&!f.isOneOf([t.NoneType,t.VariableName]));return u.length>0&&n.push(...u.map(f=>M.createStatementSymptom(b.AssignedNone,[f],0,0,{expression:f,usage:dr}))),n},bl=function(e){const n=e.getChildren(),s=[];for(let o=1;o<n.length;o++)if(n[o].is(t.AssignmentStatement)){const u=n[o].getTargetVariables().map(f=>f.getTextValue());s.push(M.createStatementSymptom(b.AssignmentInReturn,n,o,o,{assignedVariables:u}))}return s};class fu extends Y{constructor(e,n){super(e,n,t.ImportStatement,a.KeywordStatement,d.NA);I(this,Xs);I(this,Mn,[]);if(n.length>1&&(y(this,Xs,n[1]),n[0].is(t.FromKeyword)))for(let s=3;s<n.length;s++)n[s].is(t.Comma)||c(this,Mn).push(n[s])}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...c(this,Mn).flatMap(n=>n.getAllNestedExpressions())]}toJSON(){const e=super.toJSON();return e.importedEntities=c(this,Mn).map(n=>n.toJSON()),e}}Xs=new WeakMap,Mn=new WeakMap;class gu extends Y{constructor(e,n){if(n.length===0)throw new Error("Not enough elements to make a statement");let s=t.Unknown;if(n[0].is(t.AssertKeyword))s=t.AssertStatement;else if(n[0].is(t.GlobalKeyword))s=t.GlobalStatement;else if(n[0].is(t.RaiseKeyword))s=t.ThrowStatement;else throw new Error("Unknown keyword");super(e,n,s,a.KeywordStatement,d.NA);I(this,xn,[]);y(this,xn,n.slice(1))}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...c(this,xn).flatMap(n=>n.getAllNestedExpressions())]}toJSON(){const e=super.toJSON();return e.keyword=this.getChildren()[0].toJSON(),e.values=c(this,xn).map(n=>n.toJSON()),e}}xn=new WeakMap;const Gt=class Gt extends As{constructor(e,n,s,o=[],u=!0){super();I(this,Le);I(this,Et);l(this,"lineNumbers",new Set);I(this,me);I(this,Is);I(this,bs);I(this,Pe);y(this,Et,e),this.lineNumbers.add(n),y(this,bs,s),y(this,Is,s.getSpaceCount()+s.getTabCount()),o.length>0&&(o[o.length-1].is(t.ContinuationLine)&&o.pop(),o.length>0&&o[0].isOneOf([t.IfDefinition,t.ElifDefinition,t.WhileDefinition])&&this.addRule(m(this,Le,Nl))),y(this,me,o),this.addRule(m(this,Le,Fl)),u&&m(this,Le,or).call(this)}getRawText(){return c(this,Et)}updateRawText(e){y(this,Et,e)}getLineNumbers(){return this.lineNumbers}getFirstLineNumber(){return this.lineNumbers.size>0?Math.min(...Array.from(this.lineNumbers)):-1}getLastLineNumber(){return this.lineNumbers.size>0?Math.max(...Array.from(this.lineNumbers)):-1}addLineNumber(e){this.lineNumbers.add(e)}getIndentation(){return c(this,Is)}getIndent(){return c(this,bs)}getExpressions(){return c(this,Pe)===void 0?c(this,me):c(this,Pe)}getRawExpressions(){return c(this,me)}containsExpression(e){for(let n of this.getExpressions())if(n.contains(e))return!0;return!1}getVariableUsages(){const e=new Map;for(let n of c(this,Pe)){const s=n.getVariableExpressions();for(let o of s)e.has(o.getTextValue())||e.set(o.getTextValue(),[]),e.get(o.getTextValue()).push(o)}return e}isBlank(){return c(this,Pe).length===0}getFirstExpression(){if(this.isBlank())throw new Error("Statement is blank. Could not get first expression.");return c(this,Pe)[0]}isBlockStatement(){return!1}isDefinitionOfBlock(){return c(this,Pe).length===0?!1:c(this,Pe)[0].is(a.BlockDefinitionStatement)}static createFromSource(e){return new Gt(e.getText(),e.getLineNumber(),e.getIndent(),e.getExpressions(),!e.continuesOnNextLine())}continueFromSource(e){this.addLineNumber(e.getLineNumber()),m(this,Le,yl).call(this,e.getExpressions()),this.updateRawText(c(this,Et)+`
`+e.getText()),e.continuesOnNextLine()||m(this,Le,or).call(this)}toJSON(){return{expressions:c(this,Pe).map(e=>e.toJSON())}}};Et=new WeakMap,me=new WeakMap,Is=new WeakMap,bs=new WeakMap,Pe=new WeakMap,Le=new WeakSet,or=function(){y(this,Pe,K.createTree(c(this,me))),this.addRules([m(this,Le,Tl)]),this.checkRules(this)},yl=function(e){if(e.length>0&&e[0].is(t.OpenParenthesis)&&c(this,me).length>0&&c(this,me)[c(this,me).length-1].is(t.VariableName)){const n=c(this,me).length-1,s=c(this,me)[n];let o=We(c(this,me)[c(this,me).length-1]);o.category!==a.BuiltInFunctions&&(o=new Z(t.FunctionName,a.Identifiers)),c(this,me)[n]=$n(s.getTextValue(),o,s.getStartLineNumber(),s.getDocumentStartIndex(),s.getDocumentEndIndex(),s.getEndLineNumber())}y(this,me,c(this,me).concat(e))},Fl=function(e){var o,u,f;const n=e.getRawExpressions(),s=[];for(let g=0;g<n.length;g++)m(o=Gt,yt,Cl).call(o,n,g)&&s.push(M.createStatementSymptom(b.NaturalLanguageBoolean,n,g,g+1,{form:rc})),m(u=Gt,yt,Ml).call(u,n,g)&&s.push(M.createStatementSymptom(b.OutOfPlaceBooleanOperator,n,g,g)),m(f=Gt,yt,Ol).call(f,n,g)&&s.push(M.createStatementSymptom(b.DoubleComparisonOperators,n,g,g+1));return s},Tl=function(e){const n=[],s=c(e,Pe);for(let o=0;o<s.length;o++)s[o].is(t.Colon)&&n.push(M.createStatementSymptom(b.UnexpectedColon,s,0,s.length-1,{before:o>0?{type:s[o-1].getEntity().name,value:s[o-1].getTextValue()}:{type:ce},after:o<s.length-1?{type:s[o+1].getEntity().name,value:s[o+1].getTextValue()}:{type:ce}}));return n},Nl=function(e){const n=e.getFirstExpression().getExpressionsOfKind(t.AssignmentStatement),s=[];for(const o of n)s.push(M.createStatementSymptom(b.AssignmentInBoolean,[o],0,0,{parentText:e.getRawText()}));return s},yt=new WeakSet,Cl=function(e,n){return e[n].is(t.AndOperator)&&n<e.length-1&&e[n+1].is(t.OrOperator)},Ol=function(e,n){return n<e.length-1&&e[n].isOneOf([t.AssignmentOperator,a.ComparisonOperators])&&e[n+1].isOneOf([t.AssignmentOperator,a.ComparisonOperators])},Ml=function(e,n){return e[n].is(a.LogicalOperators)?!!(!e[n].is(t.NotOperator)&&(n===0||e[n-1].isOneOf([a.LogicalOperators,a.MathsOperators,a.ComparisonOperators,a.BlockDefinitions]))||!e[n].is(t.NotOperator)&&n<e.length-1&&e[n+1].isOneOf([a.LogicalOperators,a.MathsOperators,a.ComparisonOperators,a.BlockDefinitions])&&!e[n+1].is(t.NotOperator)):!1},I(Gt,yt);let Mt=Gt;class pu extends Mt{constructor(e,n){super(e.getRawText(),e.getFirstLineNumber(),e.getIndent());I(this,et);I(this,j,[]);for(const s of e.getExpressions())s.setBlockId(`${e.getFirstLineNumber()}-${e.getRawExpressions()[0].getTextValue()}`),s.setScopeId(n);c(this,j).push(e);for(const s of e.getLineNumbers())this.addLineNumber(s);this.addRules([m(this,et,ar)])}getExpressions(){let e=[];for(let n of c(this,j))e=e.concat(n.getExpressions());return e}getVariableUsages(){const e=new Map;for(let n of c(this,j)){const s=n.getVariableUsages();for(const[o,u]of s)if(!e.has(o))e.set(o,u);else{const f=e.get(o).concat(u);e.set(o,f)}}return e}isBlank(){return!1}getFirstExpression(){if(this.isBlank())throw new Error("Statement is blank. Could not get first expression.");return c(this,j)[0].getFirstExpression()}isBlockStatement(){return!0}getLineNumbers(){const e=new Set;for(let n of c(this,j))for(let s=n.getFirstLineNumber();s<=n.getLastLineNumber();s++)e.add(s);return e}getFirstLineNumber(){return c(this,j).length===0?-1:c(this,j)[0].getFirstLineNumber()}getLastLineNumber(){return c(this,j).length===0?-1:c(this,j)[c(this,j).length-1].getLastLineNumber()}getStatements(){return c(this,j)}getDefinitionStatement(){let e=c(this,j)[0];for(;e.isBlockStatement();)e=e.getDefinitionStatment();return e}addStatement(e,n){const s=c(this,j).length>0&&c(this,j)[c(this,j).length-1].getExpressions().length>0?c(this,j)[c(this,j).length-1].getFirstExpression().getBlockId():"unknown";c(this,j).push(e);for(const f of e.getExpressions())f.setBlockId(s),f.setScopeId(n.getScope().getId());const o=oe(this.getExpressions());this.updateRawText(o);for(let f of e.getLineNumbers())this.addLineNumber(f);K.connectVariableUsages(e,n);const u=n.getBlockEntity()===t.DocumentDefinition?n:n.getParentBlock().getScope();K.connectUserDefinedFunctions(e,u),K.connectUserDefinedMethods(e,u),K.makeGraphConnections(c(this,j))}getBlockStatementForIndent(e){if(c(this,j).length===0||e<=this.getIndentation())return;const n=c(this,j)[c(this,j).length-1];if(!n.isBlockStatement())return this;const s=n.getBlockStatementForIndent(e);return s===void 0?this:s}getLastBlockStatement(){if(c(this,j).length===0)return;const e=c(this,j)[c(this,j).length-1];if(!e.isBlockStatement())return this;const n=e.getLastBlockStatement();return n===void 0?this:n}toJSON(){return{definition:this.getDefinitionStatement().toJSON(),statements:c(this,j).slice(1).map(e=>e.toJSON())}}}j=new WeakMap,et=new WeakSet,ar=function(e){var u,f,g;const n=[],s=e.getDefinitionStatement();s.getFirstExpression().is(t.ForDefinitionStatement)?n.push(...m(u=e,et,Dl).call(u,e,s)):s.getFirstExpression().is(t.ExceptDefinitionStatement)&&n.push(...m(f=e,et,xl).call(f,e,s));const o=e.getStatements().filter(w=>w.isBlockStatement());for(const w of o)n.push(...m(g=w,et,ar).call(g,w));return n},xl=function(e,n){const s=[];if(n.getFirstExpression().getChildren().length===3&&n.getFirstExpression().getChildren()[1].is(t.ExceptionName)){const o=n.getFirstExpression().getChildren()[1],u=e.getStatements().slice(1);for(const f of u){const g=f.getFirstExpression();if(g.is(t.ThrowStatement)){const w=g.getExpressionsOfKind(t.ExceptionName);for(const S of w)S.getTextValue()===o.getTextValue()&&s.push(M.createStatementSymptom(b.RedundantException,[g],0,0))}}}return s},Md=function(e,n){const s=[],o=n.getFirstExpression(),u=o.getVariableExpressions();for(const f of e.getStatements()){const g=f.getExpressions();for(const w of g){if(Xt(w))return s;const S=w.getVariableExpressions().filter(T=>T.isAssignedOrChanged()),F=new Set(S.map(T=>T.getTextValue()));for(const T of u)if(F.has(T.getTextValue()))return s}}return s.push(M.createStatementSymptom(b.InfiniteLoop,[o],0,0)),s},Dl=function(e,n){const s=[],o=n.getFirstExpression().getCondition()[0];if(o!==void 0&&o.is(t.IteratorExpression)){const u=o.getLoopVariables(),f=e.getVariableUsages();for(const g of u)if(f.has(g.getTextValue())){const w=f.get(g.getTextValue()).filter(S=>S.getStartLineNumber()!==n.getFirstLineNumber());for(let S=0;S<w.length;S++){const F=w[S].getParent();if(F.is(t.IteratorExpression)&&F.getLoopVariables().filter(T=>T===w[S]).length>0)break;if(w[S].isAssignedOrChanged()&&!(w.slice(S+1).filter(R=>!R.isAssignedOrChanged()).length>0)){const R=n.getFirstExpression().getTextValue(),k=g.getDataType().name;s.push(M.createStatementSymptom(b.ForLoopIteratorModified,[w[S]],0,0,{definitionText:R.trim(),loopVarTypeAtDefinition:k,modificationText:w[S].getParent().getTextValue()}));break}}}}return s};const mu=(p,i,e)=>{let n=new Map;for(let[s,o]of Wu){const u=o(p,i,e);u.length>0&&n.set(s,bi.create(s,u))}return n},wu=p=>p.filter(e=>e.getID()===b.AssignmentInBoolean.name).map(e=>new J(e.getLineNumber(),e.getDocIndex(),new $([e],"A single equals operator is used in a boolean expression where a double equals operator might be expected."))),Su=p=>{const i=p.filter(n=>n.getID()===b.UnexpectedColon.name&&n.getAdditionalInfo().after.type!==ce&&n.getAdditionalInfo().before.type===t.VariableName.name);let e=[];for(let n of i){const s=new $([n],"The unexpected colon is preceded by a variable name and followed by a value. The intention may be to assign the value to the named variable.");e.push(new J(n.getLineNumber(),n.getDocIndex(),s))}return e},Iu=p=>{const i=p.filter(o=>o.getID()===b.NaturalLanguageBoolean.name&&o.getAdditionalInfo().operator==="or"),e=new Map,n=[];for(const o of i){let u,f=o.getAdditionalInfo().tempExpression.is(t.BooleanExpression)?o.getAdditionalInfo().tempExpression:void 0;try{for(u=o.getAdditionalInfo().tempExpression.getParent();u.is(t.BooleanExpression);)f=u,u=u.getParent()}catch{u=void 0}if(u)try{u.getFirstExpressionOf(t.ComparisonExpression)&&o.getAdditionalInfo().operator==="or"?(e.has(u)||e.set(u,[]),e.get(u).push(o),o.getAdditionalInfo().parentText=u.getTextValue(),o.getAdditionalInfo().parentEntity=u.getEntity(),f&&(o.getAdditionalInfo().completeBooleanExpression=f.getTextValue())):n.push(o)}catch{n.push(o)}else n.push(o)}let s=[];for(const o of e.values()){o.sort((f,g)=>f.getDocIndex()-g.getDocIndex());const u=new $(o,"One or more non-boolean value is used where a boolean expression is expected.");s.push(new J(o[0].getLineNumber(),o[0].getDocIndex(),u))}return s},bu=p=>{const i=p.filter(n=>n.getID()===b.CompareBoolLiteral.name);let e=[];for(let n of i){const s=n.toJSON();if(s.boolLiteral===Yl){const o=new $([n],`${s.boolValue} is a boolean value so ${s.operator} ${s.boolLiteral} is redundant.`);e.push(new J(n.getLineNumber(),n.getDocIndex(),o))}else{const o=new $([n],`${s.boolValue} is a boolean value so the expression can be rewritten as not ${s.boolValue}.`);e.push(new J(n.getLineNumber(),n.getDocIndex(),o))}}return e},yu=p=>{const i=p.filter(n=>n.getID()===b.UnreachableExit.name&&n.getAdditionalInfo().exitKeyword===dr);p.filter(n=>n.getID()===b.LoopReturn.name&&n.getAdditionalInfo().loopType==="for"&&n.getAdditionalInfo().exitType==="return");let e=[];for(let n of i){const s=new $([n],"Code follows a return statement in the same branch.");e.push(new J(n.getLineNumber(),n.getDocIndex(),s))}return e},Fu=p=>{const i=p.filter(n=>n.getID()===b.OverwrittenVariable.name&&n.getAdditionalInfo().overwriteType===ri&&n.getAdditionalInfo().overwriteValue!==ai&&!(n.getAdditionalInfo().prevUsageIsDefinition&&n.getAdditionalInfo().overwrittenVar[n.getAdditionalInfo().overwrittenVar.length-1].forLoopDefinition));let e=[];for(let n of i){const s=new $([n],`The iterating variable ${n.getAffectedText()} is initialised before the loop. ${n.getAdditionalInfo().overwriteValue===mr?"The overwritten value is different from the value initialised by the loop":"It could not be determined if the overwritten value is the same as the value initialised by the loop"}.`);e.push(new J(n.getLineNumber(),n.getDocIndex(),s))}return e},Tu=(p,i)=>{const e=p.filter(f=>f.getID()===b.UndefinedVariable.name),n=Array.from(i.values()).flatMap(f=>f).flatMap(f=>f.getUsages()).filter(f=>f.getVariable().getDataType()===d.Function).map(f=>f.getVariable()),s=p.filter(f=>f.getID()===b.SubscriptedNonSubscriptable.name),o=p.filter(f=>f.getID()===b.VariableWithSameNameAsFunction.name&&(f.getAdditionalInfo().funcType===Qt||f.getAdditionalInfo().funcType===zt&&f.getAdditionalInfo().numArgsExpected>0));let u=[];if(o.length===0||e.length===0&&n.length===0)return u;for(let f of o){const g=f.getAffectedText(),w=f.getDocIndex();for(let S of e)if(S.getAffectedText()===g&&S.getDocIndex()===w&&s.filter(T=>T.getAdditionalInfo().varName===g&&T.getDocIndex()===w).length===0){const T=new $([S,f],`The variable ${g} has not been assigned a value and the file contains a user-defined function of the same name.`);u.push(new J(S.getLineNumber(),S.getDocIndex(),T))}for(let S of n)if(S.getTextValue()===g&&S.getDocumentStartIndex()===w&&s.filter(T=>T.getAdditionalInfo().varName===g&&T.getDocIndex()===w).length===0){const T=new $([f],`The variable ${g} has not been assigned a value and the file contains a user-defined function of the same name.`);u.push(new J(f.getLineNumber(),f.getDocIndex(),T))}}return u},Nu=p=>{const i=p.filter(s=>s.getID()===b.SubscriptedNonSubscriptable.name),e=p.filter(s=>s.getID()===b.VariableWithSameNameAsFunction.name);let n=[];for(let s of i){let o=s.getAdditionalInfo().varName,u=s.getDocIndex();for(let f of e)if(f.getAffectedText()===o&&f.getDocIndex()===u){const g=s.getAdditionalInfo().isUndefined?"undefined variable":s.getAdditionalInfo().subscriptedType==="unknown data type"?"variable with unknown data type":`variable with ${s.getAdditionalInfo().subscriptedType} data type`,w=new $([s,f],`${o} (${g}) has the same name as a function. ${o} is subscripted, suggesting a mistake may have been made while calling a function of the same name. It is possible there is confusion about when to use square brackets versus parentheses.`);n.push(new J(s.getLineNumber(),s.getDocIndex(),w))}}return n},Cu=p=>{const i=p.filter(s=>s.getID()===b.LoopVarModifiedInChildLoop.name&&s.getAdditionalInfo().modifiedIn.every(o=>o.loopType==="for"&&o.varDataType==="int")),e=p.filter(s=>s.getID()===b.LoopVarNotModified.name);let n=[];for(let s of i){const o=s.getAffectedText(),u=s.getBlock();for(const f of e)if(f.getBlock()===u&&f.getAdditionalInfo().unmodifiedVars.includes(o)){const g=new $([s,f],`The int variable ${o} is referenced in a while loop condition but only modified in a nested for loop. If ${o} is being used to count the iterated items, the two loops could be replaced with a single for loop using enumerate() or range() to count the items.`);n.push(new J(s.getLineNumber(),s.getDocIndex(),g));break}}return n},Ou=p=>{const i=p.filter(n=>n.getID()===b.OverwrittenVariable.name&&n.getAdditionalInfo().overwriteType===ri&&n.getAdditionalInfo().overwriteValue===ai&&n.getAdditionalInfo().prevUsageIsDefinition&&!n.getAdditionalInfo().overwrittenVar[n.getAdditionalInfo().overwrittenVar.length-1].forLoopDefinition);let e=[];for(let n of i){const s=new $([n],`The iterating variable ${n.getAffectedText()} is initialised before the loop with the same value that it is initialised with in the for loop definition.`);e.push(new J(n.getLineNumber(),n.getDocIndex(),s))}return e},Mu=(p,i)=>{const e=p.filter(s=>s.getID()===b.UndefinedVariable.name&&s.getAdditionalInfo().variable.getScope().getBlockEntity()===t.DocumentDefinition);let n=[];for(let s of e){const o=s.getAdditionalInfo().variable.getName(),u=i.get(o).filter(f=>f.getScope().getBlockEntity()!==t.DocumentDefinition);if(u.length>0){s.getAdditionalInfo().localVariables=[];for(const g of u){const w={scope:g.getScope().getBlockEntity().name};g.getScope().getBlockEntity()===t.FunctionDefinition&&(w.functionName=g.getScope().getFunctionName()),s.getAdditionalInfo().localVariables.push(w)}const f=new $([s],`The undefined variable ${s.getAffectedText()} has global scope. The document contains ${u.length} other ${u.length===1?"variable":"variables"} with the same name in function scope.`);n.push(new J(s.getLineNumber(),s.getDocIndex(),f))}}return n},xu=p=>{let i=p.filter(n=>n.getID()===b.ForLoopIteratorModified.name),e=[];for(let n of i){let s="";s=`The for loop iterator variable ${n.getAffectedText()} is modified in the loop.`;const o=new $([n],s);e.push(new J(n.getLineNumber(),n.getDocIndex(),o))}return e},Du=p=>{const i=p.filter(n=>n.getID()===b.OneLineConditional.name);let e=[];for(let n of i){const s=n.toJSON();if(s.form===si){const o=new $([n],"Conditional returns a boolean literal that matches the value of the boolean expression in the if statement. The whole conditional could be replaced with a single line.");e.push(new J(n.getLineNumber(),n.getDocIndex(),o))}else if(s.form===ii){const o=new $([n],`The variable ${s.variableAssigned} is assigned a boolean literal that matches the value of the boolean expression in the if statement. The whole conditional could be replaced with a single line.`);e.push(new J(n.getLineNumber(),n.getDocIndex(),o))}}return e},Bu=p=>{const i=p.filter(n=>n.getID()===b.TernaryReturnsBool.name);let e=[];for(let n of i){const s=new $([n],"Ternary returns a boolean literal that matches the value of the boolean expression in the ternary. The ternary could be replaced with the boolean expression alone.");e.push(new J(n.getLineNumber(),n.getDocIndex(),s))}return e},Au=p=>{const i=p.filter(s=>s.getID()===b.UnexpectedColon.name&&s.getAdditionalInfo().after.type===ce&&(s.getAdditionalInfo().before.type===t.FunctionName.name||s.getAdditionalInfo().before.type===pr)),e=p.filter(s=>s.getID()===b.UnknownFunction.name);let n=[];for(let s of i)if(s.getAdditionalInfo().before.type===t.FunctionName.name){let o=e.filter(u=>u.getAffectedText()===s.getAdditionalInfo().before.value);if(o.length>0){const u=new $([s,o[0]],`The unexpected colon is preceded by a call to unknown function, ${o[0].getAffectedText()}. It is possible the intention was to declare a function but the def keyword has been omitted.`);n.push(new J(s.getLineNumber(),s.getDocIndex(),u))}}else if(s.getAdditionalInfo().before.type===pr){const o=new $([s],"The unexpected colon is preceded by a Boolean expression. It is possible the intention was to declare a while, if, or elif but the keyword was omitted.");n.push(new J(s.getLineNumber(),s.getDocIndex(),o))}return n},ku=p=>{const i=p.filter(s=>s.getID()===b.DefinitionFollowedByReservedWord.name),e=p.filter(s=>s.getID()===b.ReservedWordAssigned.name);let n=[];for(let s of i){const o=new $([s],`The reserved word, ${s.getAdditionalInfo().reservedWord}, follows the ${s.getAdditionalInfo().definitionType}.`);n.push(new J(s.getLineNumber(),s.getDocIndex(),o))}for(let s of e){const o=new $([s],`The reserved word, ${s.getAffectedText()}, is followed by the assignment operator.`);n.push(new J(s.getLineNumber(),s.getDocIndex(),o))}return n},Pu=(p,i)=>{const e=p.filter(f=>f.getID()===b.UndefinedVariable.name),n=Array.from(i.values()).flatMap(f=>f).flatMap(f=>f.getUsages()).filter(f=>f.getVariable().getDataType()===d.Function).map(f=>f.getVariable()),s=p.filter(f=>f.getID()===b.SubscriptedNonSubscriptable.name),o=p.filter(f=>f.getID()===b.VariableWithSameNameAsFunction.name&&f.getAdditionalInfo().funcType===zt&&f.getAdditionalInfo().numArgsExpected===0);let u=[];if(o.length===0||e.length===0&&n.length===0)return u;for(let f of o){const g=f.getAffectedText(),w=f.getDocIndex();for(let S of e)if(S.getAffectedText()===g&&S.getDocIndex()===w&&s.filter(T=>T.getAdditionalInfo().varName===g&&T.getDocIndex()===w).length===0){const T=new $([S,f],`The variable ${g} has not been assigned a value and the file contains a user-defined function of the same name, which does not expect any arguments.`);u.push(new J(S.getLineNumber(),S.getDocIndex(),T))}for(let S of n)if(S.getTextValue()===g&&S.getDocumentStartIndex()===w&&s.filter(T=>T.getAdditionalInfo().varName===g&&T.getDocIndex()===w).length===0){const T=new $([f],`The variable ${g} has not been assigned a value and the file contains a user-defined function of the same name, which does not expect any arguments.`);u.push(new J(f.getLineNumber(),f.getDocIndex(),T))}}return u},Lu=p=>{const i=p.filter(o=>o.getID()===b.AssignedNone.name),e=p.filter(o=>o.getID()===b.FunctionPrints.name),n=p.filter(o=>o.getID()===b.UnusedReturn.name&&o.getAdditionalInfo().expression.is(t.FunctionName));let s=[];for(let o of i){const u=o.toJSON();if(u.expressionNoValue.type===zt){const f=u.expressionNoValue.value.split("(")[0],g=e.filter(S=>S.getAffectedText()===f);if(g.length>0){const S=new $([o,...g],`User-defined function ${f} prints to the console but does not return a value.`);s.push(new J(o.getLineNumber(),o.getDocIndex(),S))}else{const S=new $([o],`User-defined function ${f} does not return a value but it is used as if it does.`);s.push(new J(o.getLineNumber(),o.getDocIndex(),S))}}else if(u.expressionNoValue.type===Qt&&u.expressionNoValue.value.indexOf("print(")===0){const f=new $([o],"The print function does not return a value but it is used as if it does.");s.push(new J(o.getLineNumber(),o.getDocIndex(),f))}}for(let o of n){const f=o.toJSON().unusedFunc.value,g=e.filter(S=>S.getAffectedText()===f);if(g.length>0){const S=new $([o,...g],`User-defined function ${f} prints to the console and returns a value but the value is not used.`);s.push(new J(o.getLineNumber(),o.getDocIndex(),S))}}return s},Vu=p=>{const i=p.filter(s=>s.getID()===b.FunctionPrints.name),e=p.filter(s=>s.getID()===b.UnusedReturn.name&&!(s.getAdditionalInfo().expression.is(a.BuiltInMethods)&&br.has(s.getAdditionalInfo().expression.getEntity()))&&!s.getAdditionalInfo().expression.isOneOf([t.StrFunction,t.IntFunction,t.FloatFunction,t.BoolFunction,t.ListFunction,t.TupleFunction,t.SetFunction])),n=[];for(let s of e){const u=s.toJSON().unusedFunc.value;if(!(i.filter(w=>w.getAffectedText()===u).length>0)){const w=new $([s],`The function ${u} returns a value but the value is not used.`);n.push(new J(s.getLineNumber(),s.getDocIndex(),w))}}return n},vu=p=>{const i=p.filter(n=>n.getID()===b.ReturnInParentheses.name),e=n=>n===hr?"function call":n===fr?"compound type (e.g. list, set)":n===gr?"compound expression":n;return i.map(n=>new J(n.getLineNumber(),n.getDocIndex(),new $([n],`The function returns a ${e(n.getAdditionalInfo().contents)} wrapped in parentheses. The parentheses are unnecessary.`)))},Ru=p=>{const i=p.filter(n=>n.getID()===b.SequentialIfs.name&&n.getAdditionalInfo().branchMatches.length>0);let e=[];for(let n of i)for(let s of n.getAdditionalInfo().branchMatches){let o=s.map(f=>f.lineNum+1).join(", "),u=o.lastIndexOf(",");o=o.substring(0,u)+" and"+o.substring(u+1),s.length>0&&e.push(new J(s[0].lineNum,s[0].docIndex,new $([n],`The if statement is part of a sequence of if statements (lines ${o}) that have very similar boolean expressions.`)))}return e},Uu=(p,i,e)=>{const n=new Set(p.filter(u=>u.getID()===b.AssignmentInReturn.name).map(u=>u.getLineNumber())),s=p.filter(u=>u.getID()===b.OverwrittenVariable.name&&u.getAdditionalInfo().isParameter&&u.getAdditionalInfo().prevUsageIsDefinition&&!n.has(u.getLineNumber()));let o=[];for(let u of s){const f=u.getAdditionalInfo().functionBlock;let g="";for(const[S,F]of e.entries())if(F.getBlockId()===f){g=S;break}u.getAdditionalInfo().functionBlock=g;const w=new $([u],`The parameter ${u.getAffectedText()} is overwritten before use.`);o.push(new J(u.getLineNumber(),u.getDocIndex(),w))}return o},Eu=p=>{const i=p.filter(n=>n.getID()===b.UnusedReturn.name&&n.getAdditionalInfo().expression.is(a.BuiltInMethods)&&br.has(n.getAdditionalInfo().expression.getEntity()));let e=[];for(let n of i){const s=new $([n],`A String method, ${n.getAdditionalInfo().expression.getTextValue()}, that returns a new string is called but the return value is not assigned or passed.`);e.push(new J(n.getLineNumber(),n.getDocIndex(),s))}return e},Gu=p=>{const i=p.filter(n=>n.getID()===b.UnusedReturn.name&&n.getAdditionalInfo().expression.isOneOf([t.StrFunction,t.IntFunction,t.FloatFunction,t.BoolFunction,t.ListFunction,t.TupleFunction,t.SetFunction]));let e=[];for(let n of i){const s=new $([n],`${n.getAdditionalInfo().expression.getTextValue()}() is called but the converted value returned by the function is not saved or passed.`);e.push(new J(n.getLineNumber(),n.getDocIndex(),s))}return e},$u=p=>{const i=p.filter(s=>s.getID()===b.LoopVarNotModified.name),e=p.filter(s=>s.getID()===b.LoopReturn.name);let n=[];for(const s of e){if(s.getAdditionalInfo().exitTypes.filter(u=>u!=="return").length>0||s.getAdditionalInfo().loopType==="while"&&i.filter(u=>u.getBlock()===s.getBlock()).length>0)continue;const o=new $([s],`A ${s.getAdditionalInfo().loopType} always exits on the first iteration due to return statements. Related to DeferredReturn.`);n.push(new J(s.getLineNumber(),s.getDocIndex(),o))}return n},Ju=p=>{const i=p.filter(s=>s.getID()===b.LoopVarNotModified.name),e=p.filter(s=>s.getID()===b.LoopReturn.name);let n=[];for(let s of i){const o=e.filter(u=>u.getBlock()===s.getBlock());if(o.length>0){const u=new $([s,...o],"No while loop variables are modified (excluding modifications in any nested loops) and the loop always exits on the first iteration.");n.push(new J(s.getLineNumber(),s.getDocIndex(),u))}}return n},Ku=p=>{const i=p.filter(n=>n.getID()===b.TypeUnnecessary.name);let e=[];for(let n of i){const s=n.toJSON();let o;s.argType===_l&&s.convertedType===ec?o=new $([n],`A string value, ${s.convertedValue}, is converted to a list which may not be necessary. The programmer may not realise that much of the functionality provided by a list is also available to strings.`):o=new $([n],`${s.convertedValue} is guaranteed to be a ${s.argType} so there is no need to convert it to ${s.convertedType}.`),o!==void 0&&e.push(new J(n.getLineNumber(),n.getDocIndex(),o))}return e},Oi=class Oi{constructor(i,e){I(this,Dn);I(this,ys);I(this,$t);y(this,Dn,i.name),y(this,ys,i.description),y(this,$t,e)}addOccurrence(i){c(this,$t).push(i)}getName(){return c(this,Dn)}isPresentInToken(i,e){for(const n of c(this,$t))for(const s of n.getReason().getContributingSymptoms())if(i<=s.getDocIndex()&&e>=s.getDocIndex())return!0;return!1}toJSON(){return{type:c(this,Dn),description:c(this,ys),occurrences:c(this,$t).map(i=>i.toJSON())}}static create(i,e){return new Oi(i,e)}};Dn=new WeakMap,ys=new WeakMap,$t=new WeakMap;let bi=Oi;class J{constructor(i,e,n){I(this,Bn);I(this,An);I(this,kn);y(this,Bn,i),y(this,An,e),y(this,kn,n)}getLineNumber(){return c(this,Bn)}getDocIndex(){return c(this,An)}getReason(){return c(this,kn)}toJSON(){return{line:c(this,Bn),docIndex:c(this,An),reason:c(this,kn).toJSON()}}}Bn=new WeakMap,An=new WeakMap,kn=new WeakMap;class ${constructor(i,e){I(this,Pn);I(this,Fs);y(this,Pn,i),y(this,Fs,e)}getContributingSymptoms(){return c(this,Pn)}toJSON(){return{contributingSymptoms:c(this,Pn).map(i=>i.toJSON()),explanation:c(this,Fs)}}}Pn=new WeakMap,Fs=new WeakMap;const Wu=new Map([[L.PrintSameAsReturn,Lu],[L.UnusedReturn,Vu],[L.MapToBooleanWithIf,Du],[L.ComparisonWithBoolLiteral,bu],[L.DeferredReturn,yu],[L.TypeMustBeSpecified,Ku],[L.CompareMultipleValuesWithOr,Iu],[L.ParenthesesOnlyIfArgument,Pu],[L.FunctionCallsUseSquareBrackets,Nu],[L.FunctionCallsNoParentheses,Tu],[L.AssignCompares,wu],[L.ReturnCall,vu],[L.SequentialIfsAreExclusive,Ru],[L.WhileSameAsIf,Ju],[L.IterationRequiresTwoLoops,Cu],[L.StringMethodsModifyTheString,Eu],[L.TypeConversionModifiesArgument,Gu],[L.MapToBooleanWithTernaryOperator,Bu],[L.NoReservedWords,ku],[L.ParameterMustBeAssignedInFunction,Uu],[L.LocalVariablesAreGlobal,Mu],[L.IteratorInitialisedOutsideLoop,Ou],[L.ForLoopVarIsLocal,Fu],[L.LoopCounter,xu],[L.NoKeyword,Au],[L.ColonAssigns,Su],[L.ReturnWaitsForLoop,$u]]);class Rr{constructor(i){I(this,Zs);I(this,Jt);I(this,Ke);I(this,Ft);I(this,Ts);I(this,Kt);I(this,Wt);I(this,Ln);y(this,Jt,i.getTextValue()),y(this,Ke,i.getCategory()),y(this,Ft,i.getEntity()),y(this,Kt,i.getDocumentStartIndex()),y(this,Wt,i.getDocumentEndIndex()),y(this,Ts,i.getConnectedTo()),y(this,Ln,new Set)}getText(){return c(this,Jt)}getEntity(){return c(this,Ft)}getCategory(){return c(this,Ke)}getConnectedTo(){return c(this,Ts)}addMisconception(i){c(this,Ln).add(i)}getID(){let i=`${c(this,Ft).name}_${c(this,Ke).name} ${c(this,Jt)}`;return m(this,Zs,Bl).call(this)?i:`${c(this,Kt)}_${c(this,Wt)}_${i}`}getStartIndex(){return c(this,Kt)}getEndIndex(){return c(this,Wt)}toJSON(){return{id:this.getID(),text:c(this,Jt),entity:c(this,Ft).name,category:c(this,Ke).name,startDocIndex:c(this,Kt),endDocIndex:c(this,Wt),misconceptions:Array.from(c(this,Ln))}}}Jt=new WeakMap,Ke=new WeakMap,Ft=new WeakMap,Ts=new WeakMap,Kt=new WeakMap,Wt=new WeakMap,Ln=new WeakMap,Zs=new WeakSet,Bl=function(){return c(this,Ft)===t.FunctionName&&c(this,Ke)===a.Identifiers||c(this,Ke)===a.BuiltInFunctions||c(this,Ke)===a.BuiltInMethods||c(this,Ke)===a.BuiltInModules||c(this,Ke)===a.BuiltInExceptions};class qu{constructor(i,e){I(this,He);I(this,Tt,new Map);I(this,Vn,new Map);const n=Array.from(e.values());for(const s of i)m(this,He,Al).call(this,n,s),m(this,He,lr).call(this,s);m(this,He,kl).call(this)}toJSON(){const i={nodes:{},edges:{}};for(const[e,n]of c(this,Tt))i.nodes[e]=n.toJSON();for(const[e,n]of c(this,Vn))i.edges[e]=Array.from(n);return i}}Tt=new WeakMap,Vn=new WeakMap,He=new WeakSet,Al=function(i,e){const n=i.filter(s=>s.isPresentInToken(e.getStartIndex(),e.getEndIndex()));for(const s of n)e.addMisconception(s.getName())},lr=function(i){const e=i.getID();c(this,Tt).has(e)||(c(this,Tt).set(e,i),c(this,Vn).set(e,new Set))},kl=function(){for(const[i,e]of c(this,Tt)){const n=e.getConnectedTo();for(const s of n){const o=new Rr(s);c(this,Tt).has(o.getID())||m(this,He,lr).call(this,o),i!==o.getID()&&m(this,He,Pl).call(this,i,o.getID())}}},Pl=function(i,e){c(this,Vn).get(i).add(e)};class ju{constructor(i){I(this,v);I(this,Ns);I(this,Me,[]);I(this,ye);l(this,"variables");l(this,"userDefinedFunctions");l(this,"userDefinedClasses");l(this,"modules");y(this,Ns,i),y(this,ye,new En),this.variables=new Map,this.modules=new Map,M.symptoms=[];try{m(this,v,Ll).call(this,i)}catch(e){const n=`Unable to process ${i} due to error: ${e.stack}`;throw new Error(n)}}getUserDefinedFunctions(){return this.userDefinedFunctions}getUserDefinedClasses(){return this.userDefinedClasses}getVariables(){return this.variables}getSymptoms(){return M.symptoms}getMisconceptions(){return mu(M.symptoms,this.variables,this.getUserDefinedFunctions())}getText(){return c(this,Ns)}getBlocks(){return c(this,ye)}getGraph(){let i=[];for(const n of c(this,Me))for(const s of n.getExpressions()){let o=s.getAllNestedExpressions();try{i.push(...o.map(u=>new Rr(u)))}catch(u){console.log("Unable to get graph nodes:",u)}}return new qu(i,this.getMisconceptions())}}Ns=new WeakMap,Me=new WeakMap,ye=new WeakMap,v=new WeakSet,Ll=function(i){y(this,Me,[]);let e=c(this,ye);const n=i.split(/\r?\n/);if(n.length>0){let s=new Gn(n[0],0,0);c(this,Me).push(Mt.createFromSource(s)),s.continuesOnNextLine()||(e=m(this,v,ur).call(this,c(this,Me)[c(this,Me).length-1],e));for(let o=1;o<n.length;o++){const u=e.isScopeBlock()?m(this,v,cr).call(this,e):m(this,v,cr).call(this,e.getScope()),f=Array.from(e.getScope().findAllModules().keys()),g={varsWithTypeNames:u,moduleNames:f,classDefinitionInProgress:e.hasParentOfEntity(t.ClassDefinition)},w=s.getDocumentStartIndex()+s.getText().length+1;if(s.continuesOnNextLine())g.groupCharCounts=s.getOpenGroupChars(),g.lastLineExpressions=s.getExpressions(),s.hasOpenComment()&&(g.multilineCommentDelimiter=s.getCommentDelimiter()),s.hasOpenString()&&(g.stringLiteralDelimiter=s.getStringLiteralDelimiter()),s=new Gn(n[o],o,w,g),c(this,Me)[c(this,Me).length-1].continueFromSource(s);else if(s.followedBySeparateStatement()){o--;const S=s.getLineEndIndex()+1;g.startFrom=S,s=new Gn(n[o],o,s.getDocumentStartIndex(),g),c(this,Me).push(Mt.createFromSource(s))}else s=new Gn(n[o],o,w,g),c(this,Me).push(Mt.createFromSource(s));s.continuesOnNextLine()||(e=m(this,v,ur).call(this,c(this,Me)[c(this,Me).length-1],e))}}m(this,v,vl).call(this),m(this,v,Rl).call(this),m(this,v,Vl).call(this)},Ht=function(){return[c(this,ye)].concat(c(this,ye).getChildBlocksOfKind(t.FunctionDefinition)).concat(c(this,ye).getChildBlocksOfKind(t.ClassDefinition)).concat(c(this,ye).getChildBlocksOfKind(t.ListComprehension))},Vl=function(){const i=m(this,v,Ht).call(this);for(const e of i)for(const n of e.getStatements()){for(const s of n.getExpressions())s.checkForSymptoms(),s.checkForConstructs(s);n.isBlockStatement()&&n.checkRules(n)}for(const e of this.variables.values())for(const n of e)n.checkRules(n);for(const e of this.userDefinedFunctions.values()){const n=e.getParent();if(n!==void 0&&n.is(t.FunctionDefinitionStatement)){const s=n.getParameters().length-n.getOptionalParameterCount(),o=n.getParameters().length,u=Array.from(e.getObservers()).filter(f=>f.is(t.UserDefinedFunctionCall));for(const f of u){const g=f.getArguments();(g.length<s||g.length>o)&&M.symptoms.push(M.createStatementSymptom(b.WrongArgNumber,[f],0,0,{expectedMinArgs:s,expectedMaxArgs:o,receivedArgs:g.length}))}}}c(this,ye).checkRules(c(this,ye))},vl=function(){const i=new Map,e=m(this,v,Ht).call(this);for(const n of e){const s=n.getVariableMap(),o=n.getUserDefinedFunctions();for(const[u,f]of s){let g=!1;const w=f.getUsages()[0].getVariable();w.getDataType()===d.NotParsed&&!w.isAssignedOrChanged()&&!w.isParameter()&&(K.checkIfVariableExistsInParent(f,n)?g=!0:o.has(u)?w.setDataType(d.Function):(f.getUsages()[0].getVariable().setDataType(d.Undefined),f.checkAndAdjustUndefined())),i.has(u)||i.set(u,[]),g||i.get(u).push(f)}}this.variables=i},Rl=function(){this.userDefinedFunctions=m(this,v,$l).call(this),this.userDefinedClasses=c(this,ye).getUserDefinedClasses();const i=c(this,ye).getChildBlocksOfKind(t.FunctionDefinition);for(const n of i){let s=n.getLastExecutedStatements();const o=n.alwaysReturnsAValue();if(o&&(s=s.filter(u=>u.getFirstExpression().is(t.ReturnStatement))),n.getParentBlock().getBlockEntity()!==t.ClassDefinition)this.userDefinedFunctions.has(n.getFunctionName())&&this.userDefinedFunctions.get(n.getFunctionName()).is(t.FunctionName)&&this.userDefinedFunctions.get(n.getFunctionName()).addReturns(s,!o);else{const u=n.getParentBlock().getClassType().name;if(this.userDefinedClasses.has(u)){const f=this.userDefinedClasses.get(u).methods;f.has(n.getFunctionName())&&f.get(n.getFunctionName()).addReturns(s,!o)}}}m(this,v,Jl).call(this);const e=m(this,v,El).call(this);m(this,v,Gl).call(this,e),m(this,v,Ul).call(this),m(this,v,Kl).call(this)},Ul=function(){const i=this.userDefinedFunctions.keys(),e=Array.from(i).filter(n=>this.variables.has(n));for(const n of e){const s=this.userDefinedFunctions.get(n).getParent();if(s!==void 0){for(const o of this.variables.get(n))if(o.getUsages().length>0){const u=o.getUsages()[0].getVariable();M.symptoms.push(M.createStatementSymptom(b.VariableWithSameNameAsFunction,[u],0,0,{funcType:zt,numArgsExpected:s.getParameters().length-s.getOptionalParameterCount(),varIsParameter:u.isParameter()}))}}}},El=function(){const i=this.userDefinedFunctions.keys(),e=[];for(const n of i)We(n).category===a.BuiltInFunctions&&e.push(n);return e},Gl=function(i){if(i.length>0){const e=m(this,v,Ht).call(this);for(const n of e){const s=n.getStatements();for(const o of s){const f=o.getExpressions().flatMap(g=>g.getExpressionsOfKind(t.BuiltInFunctionCall)).filter(g=>i.includes(g.getFunctionName()));for(const g of f)i.includes(g.getFunctionName())&&g.convertToUserDefinedFunction(this.userDefinedFunctions.get(g.getFunctionName()))}}}},$l=function(){const i=new Map;let e=m(this,v,Ht).call(this);for(const n of e){const s=n.getUserDefinedFunctions();for(const[o,u]of s)i.set(o,u)}return i},Jl=function(){const i=m(this,v,Ht).call(this);for(const e of i){const n=e.getUnconnectedFunctionCalls();for(let s of n)for(let o of s[1])if(this.userDefinedFunctions.has(s[0])){const u=this.userDefinedFunctions.get(s[0]);u.addObserver(o),o.setDataType(u.getReturnType())}else m(this,v,Wl).call(this,s[0],e)?o.convertToImportedFunction():(o.setDataType(d.Unknown),M.symptoms.push(M.createStatementSymptom(b.UnknownFunction,[o],0,0)))}},Kl=function(){const i=m(this,v,Ht).call(this);for(const e of i){const n=e.getUnconnectedMethodCalls();for(let s of n)for(let o of s[1]){const u=o.getObject();let f;if(u.getDataType().isCustom)u.getDataType().methods.has(s[0])&&(f=u.getDataType().methods.get(s[0]));else for(const g of this.userDefinedClasses.values())if(g.methods.has(s[0])){f=g.methods.get(s[0]);break}f&&(f.addObserver(o),o.setDataType(f.getReturnType()))}}},Wl=function(i,e){let n=e;for(;n!==void 0;){if(n.getModuleMap().has(i)||Array.from(n.getModuleMap().values()).filter(s=>s.hasDirectImport(i)).length>0)return!0;n=n.getParentBlock()!==void 0?n.getParentBlock().getScope():void 0}return!1},cr=function(i){const e=new Set(["int","float","bool","str","list","set","dict"]);let n=Array.from(i.getVariableMap().keys()).filter(o=>e.has(o)),s=i;for(;s.getBlockEntity()!==t.DocumentDefinition;)s=s.getParentBlock().getScope(),n=n.concat(Array.from(s.getVariableMap().keys()).filter(o=>e.has(o)));return n},ur=function(i,e){if(!i.isBlank()){const n=i.getFirstExpression(),s=i.getIndentation(),o=n.getStartLineNumber();let u;const f=m(this,v,Hl).call(this,i);e.isScopeBlock()||(u=e.getScope().getStatementToUpdate(s,o)),n.isOneOf([t.FunctionDefinitionStatement,t.MethodDefinitionStatement])?(e=m(this,v,Ql).call(this,e,i,s),n.is(t.MethodDefinitionStatement)&&m(this,v,jl).call(this,e,n)):n.is(t.ClassDefinitionStatement)?e=m(this,v,Xl).call(this,e,i,s):n.is(a.BlockDefinitionStatement)&&!n.is(t.TernaryStatement)?e=m(this,v,zl).call(this,e,i,s,u):u!==void 0?(e=m(this,v,Rn).call(this,s,e,o),u.addStatement(i,e)):(e=m(this,v,Rn).call(this,s,e,o),e.addStatement(i)),f.length>0&&m(this,v,ql).call(this,f,e)}return e},ql=function(i,e){for(let n of i){const s=new qc(e,n);e.addChildBlock(s)}},jl=function(i,e){const n=i.getParentBlock();if(n&&n.getBlockEntity()===t.ClassDefinition){const s=n.getClassType(),o=e.getMethodNameExpression();o.setContainingClass(s),s.methods.set(o.getTextValue(),o)}},Hl=function(i){const e=i.getExpressions();let n=[];for(const s of e){const o=s.getExpressionsOfKind(t.ListComprehension);for(const u of o)n.push(u.copyAndConvertToPlaceholder())}return n},zl=function(i,e,n,s){const o=new pu(e,i.getScope().getId()),u=new Or(i,o),f=m(this,v,Rn).call(this,n,i,e.getFirstLineNumber()),g=o.getFirstExpression().isOneOf([t.ElifDefinitionStatement,t.ElseDefinitionStatement]),w=o.getFirstExpression().is(t.ExceptDefinitionStatement);if(o.isBlockStatement()&&(g||w)){const S=s?s.getStatements():f.getStatements(),F=S[S.length-1],T=g?[t.IfDefinitionStatement,t.ElifDefinitionStatement,t.ElseDefinitionStatement]:[t.TryDefinitionStatement];if(F!==void 0&&F.isBlockStatement()&&F.getFirstExpression().isOneOf(T)){const R=f.getChildBlocks(),k=R[R.length-1],O=k.getBlockEntity();if(g&&(O===t.IfDefinition||O===t.ElifDefinition)||w&&O===t.TryDefinition){const qt=k.getSiblingConditionalBranches();for(const Er of qt)u.addSibling(Er),Er.addSibling(u);k.addSibling(u),u.addSibling(k)}}}return f.addChildBlock(u),s?s.addStatement(o,u):f.addStatement(o),u},Ql=function(i,e,n){i=m(this,v,Rn).call(this,n,i,e.getFirstLineNumber());const s=new di(i,e);return i.addChildBlock(s),s},Xl=function(i,e,n){i=m(this,v,Rn).call(this,n,i,e.getFirstLineNumber());const s=new Wc(i,e);return i.addChildBlock(s),s},Rn=function(i,e,n){let s=e.getIndentation();const o=e.getStatements();if(o.length>0&&o[o.length-1].getLastLineNumber()===n)return e;for(;e.getBlockEntity()!==t.DocumentDefinition&&i<=s;){let u=e.getParentBlock();e=u!==void 0?u:c(this,ye),s=e.getIndentation()}return e};class z{constructor(i,e,n,s,o){l(this,"type");l(this,"docIndex");l(this,"affectedText");l(this,"firstMessage");l(this,"extendedFeedbackParams");for(this.type=i,this.docIndex=e,this.affectedText=n,this.firstMessage=s,this.extendedFeedbackParams=o;this.extendedFeedbackParams.includes("+");)this.extendedFeedbackParams=this.extendedFeedbackParams.replace("+","%2B");this.extendedFeedbackParams=encodeURI(this.extendedFeedbackParams)}static notImplemented(){return new z("Invalid",-1,"N/A","No feedback","")}toJSON(){return{type:this.type,docIndex:this.docIndex,affectedText:this.affectedText,firstMessage:this.firstMessage,extendedFeedbackParams:this.extendedFeedbackParams}}}const Hu=p=>p.hasOwnProperty("reason")&&p.reason.hasOwnProperty("contributingSymptoms")&&p.reason.contributingSymptoms.length>0,lt=(p,i)=>p.type===i,zu=p=>{const i=[];try{for(const e of p.occurrences)if(Hu(e))switch(p.type){case L.AssignCompares.name:i.push(Qu(p.type,e));break;case L.ColonAssigns.name:i.push(Xu(p.type,e));break;case L.CompareMultipleValuesWithOr.name:i.push(Zu(p.type,e));break;case L.ComparisonWithBoolLiteral.name:i.push(Yu(p.type,e));break;case L.DeferredReturn.name:i.push(ed(p.type,e));break;case L.ForLoopVarIsLocal.name:case L.IteratorInitialisedOutsideLoop.name:i.push(td(p.type,e));break;case L.FunctionCallsNoParentheses.name:case L.ParenthesesOnlyIfArgument.name:i.push(sd(p.type,e));break;case L.IterationRequiresTwoLoops.name:i.push(id(p.type,e));break;case L.LocalVariablesAreGlobal.name:i.push(rd(p.type,e));break;case L.LoopCounter.name:i.push(nd(p.type,e));break;case L.MapToBooleanWithIf.name:i.push(od(p.type,e));break;case L.MapToBooleanWithTernaryOperator.name:i.push(ad(p.type,e));break;case L.ParameterMustBeAssignedInFunction.name:i.push(ld(p.type,e));break;case L.PrintSameAsReturn.name:i.push(cd(p.type,e));break;case L.ReturnCall.name:i.push(ud(p.type,e));break;case L.ReturnWaitsForLoop.name:i.push(pd(p.type,e));break;case L.SequentialIfsAreExclusive.name:i.push(_u(p.type,e));break;case L.StringMethodsModifyTheString.name:i.push(dd(p.type,e));break;case L.TypeConversionModifiesArgument.name:i.push(hd(p.type,e));break;case L.TypeMustBeSpecified.name:i.push(fd(p.type,e));break;case L.UnusedReturn.name:i.push(gd(p.type,e));break;case L.WhileSameAsIf.name:i.push(md(p.type,e));break;default:console.log("Not implemented!",p.type)}}catch(e){console.log(e)}return i},ie=(p,i)=>`?miscon=${p}&lineNumber=${i.line+1}`,Qu=(p,i)=>{const e=i.reason.contributingSymptoms[0],n=i.docIndex,s=e.text,o="Should this = be == ?",u=`${ie(p,i)}&text=${s}&parentText=${e.parentText}`;return new z(p,n,s,o,u)},Xu=(p,i)=>{const e=i.reason.contributingSymptoms[0],n=i.docIndex,s=e.text,o="Should this : be = ?",u=`${ie(p,i)}&text=${s}&variableName=${e.before.value}&assignedValue=${e.after.value}`;return new z(p,n,s,o,u)},Zu=(p,i)=>{const e="NA",n=i.docIndex,s=i.reason.contributingSymptoms[0].text?i.reason.contributingSymptoms[0].text:e,o=i.reason.contributingSymptoms[0].completeBooleanExpression?`${i.reason.contributingSymptoms[0].completeBooleanExpression} will always be True`:"This boolean expression will always be True";let u=e,f=e,g=e;const w=[],S=[],F=[],T=[],R=[];for(const O of i.reason.contributingSymptoms)lt(O,b.NaturalLanguageBoolean.name)&&(O.completeBooleanExpression&&(u=O.completeBooleanExpression),O.parentText&&(f=O.parentText),O.parentEntity&&(g=O.parentEntity),O.rightSideEntity&&(O.rightSideEntity===t.ComparisonExpression.name&&(w.length===0||w[0]!==O.rightSideText)?w.unshift(O.rightSideText):O.rightSideEntity!==t.BooleanExpression.name&&(S.length===0||S[0]!==O.rightSideText)&&(S.unshift(O.rightSideText),T.unshift(O.rightSideEntity),F.unshift(O.rightSideType))),O.leftSideEntity&&(O.leftSideEntity===t.ComparisonExpression.name?w.unshift(O.leftSideText):O.leftSideEntity!==t.BooleanExpression.name&&(S.unshift(O.leftSideText),T.unshift(O.leftSideEntity),F.unshift(O.leftSideType))),R.unshift(O.operator));const k=`${ie(p,i)}&booleanExpressionText=${u}&parentText=${f}&parentEntity=${g}&${w.map(O=>"comparisonText="+O).join("&")}&${S.map(O=>"otherText="+O).join("&")}&${T.map(O=>"otherEntity="+O).join("&")}&${F.map(O=>"otherType="+O).join("&")}&${R.map(O=>"operator="+O).join("&")}}`;return new z(p,n,s,o,k)},Yu=(p,i)=>{const e=i.reason.contributingSymptoms[0],n=i.docIndex,s=e.text,o=e.boolValue,u=e.boolLiteral,f=u==="True"?`${o} is boolean so == True is not needed`:`${s} is the same as not ${o}`,g=`${ie(p,i)}&text=${s}&boolValue=${o}&boolLiteral=${u}`;return new z(p,n,s,f,g)},_u=(p,i)=>{const e=i.docIndex;let n=i.reason.contributingSymptoms[0].text;const s=new Set;for(const g of i.reason.contributingSymptoms){if(!lt(g,b.SequentialIfs.name))continue;const w=g.branchMatches.flat();w.forEach(O=>{s.add(O.lineNum+1)});const S=w[0].docIndex-g.docIndex,F=S,T=w[w.length-1].docIndex-w[0].docIndex+S,R=n.substring(T).indexOf(`
`),k=R>-1?T+R:n.length;n=n.substring(F,k)}const u=`Should this sequence of if statements be if${Array(s.size-1).fill("-elif").join("")} instead?`,f=`${ie(p,i)}&fullText=${n}&${[...s].map(g=>"statementLine="+g).join("&")}`;return new z(p,e,n,u,f)},ed=(p,i)=>{for(const e of i.reason.contributingSymptoms)if(lt(e,b.UnreachableExit.name)&&e.exitKeyword==="return"){const n=e.docIndex,s=e.text,o="This code will never execute",u=`${ie(p,i)}&exitKeyword=${e.exitKeyword}`;return new z(p,n,s,o,u)}return z.notImplemented()},td=(p,i)=>{const e=i.reason.contributingSymptoms[0],n=e.text,s=e.usageText,o=e.overwrittenVar[e.overwrittenVar.length-1].lineNum+1,u=e.prevUsageIsDefinition,f=u?`${n} does not need to be defined if it is only used in the for loop on line ${e.line+1}`:`This for loop changes the value of an existing variable, ${n}`,g=u?e.overwrittenVar[0].docIndex:i.docIndex,w=`${ie(p,i)}&loopVariable=${n}&forDefinition=${s}&overwrittenVarLine=${o}&overwrittenIsDefinition=${u}`;return new z(p,g,n,f,w)},nd=(p,i)=>{const e=i.docIndex,n=i.reason.contributingSymptoms[0],s=n.text,o=`This value of ${s} will be ignored by the next loop iteration`,u=`${ie(p,i)}&loopVarName=${s}&definitionText=${n.definitionText}&loopVarTypeAtDefinition=${n.loopVarTypeAtDefinition}&modificationText=${n.modificationText}`;return new z(p,e,s,o,u)},sd=(p,i)=>{let e=i.docIndex,n=`${ie(p,i)}`,s="";const o=i.reason.contributingSymptoms;if(o.length===2){const f=lt(o[0],b.UndefinedVariable.name)?o[0]:o[1],g=lt(o[1],b.VariableWithSameNameAsFunction.name)?o[1]:o[0];lt(f,b.UndefinedVariable.name)&&lt(g,b.VariableWithSameNameAsFunction.name)&&(s=g.text,e=f.docIndex,n=`${n}&funcName=${s}&funcType=${g.funcType}&funcExpectedArgs=${g.numArgsExpected}&matchesUndefinedVarOnLine=${f.line+1}`)}else o.length===1&&lt(o[0],b.VariableWithSameNameAsFunction.name)&&(s=o[0].text,e=o[0].docIndex,n=`${n}&funcName=${s}&funcType=${o[0].funcType}&funcExpectedArgs=${o[0].numArgsExpected}`);const u=`Did you forget () after ${s}?`;return new z(p,e,s,u,n)},id=(p,i)=>{const e="This while loop might not be needed",n=i.reason.contributingSymptoms,s=n[0].type===b.LoopVarNotModified.name?n[0]:n[1],o=n[0].type===b.LoopVarModifiedInChildLoop.name?n[0]:n[1],u=s.text,f=s.docIndex,g=`${ie(p,i)}&outerLoopText=${u}&outerLoopVariable=${o.text}${o.modifiedIn.map(w=>`&modifiedInType=${w.loopType}&modifiedInStartLine=${w.startLine+1}`)}`;return new z(p,f,u,e,g)},rd=(p,i)=>{const e=i.reason.contributingSymptoms[0],n=i.docIndex,s=e.text,o=`${s} is undefined`;let u=`${ie(p,i)}&text=${s}`;return e.hasOwnProperty("localVariables")&&(u=`${u}${e.localVariables.map(f=>`&localScope=${f.scope}${f.hasOwnProperty("functionName")?"&localFunction="+f.functionName:"&localFunction=NA"}`).join()}`),new z(p,n,s,o,u)},od=(p,i)=>{const e=i.reason.contributingSymptoms[0],n=i.docIndex,s=e.text,o="This conditional could be shortened to one line";let u=`${ie(p,i)}&text=${e.text}&form=${e.form}`;return e.form==="valueAssigned"&&(u=`${u}&variableAssigned=${e.variableAssigned}`),e.condition&&e.condition.length>0&&(u=`${u}&condition=${e.condition}`),new z(p,n,s,o,u)},ad=(p,i)=>{const e=i.reason.contributingSymptoms[0],n=i.docIndex,s=e.text,o="This ternary is not needed",u=`${ie(p,i)}&text=${e.text}&boolExp=${e.boolValue}&valueIfTrue=${e.boolLiteralIfTrue}&valueIfFalse=${e.boolLiteralIfFalse}&parentText=${e.parentText}&parentEntity=${e.parentEntity}`;return new z(p,n,s,o,u)},ld=(p,i)=>{const e=i.reason.contributingSymptoms[0],n=i.docIndex,s=e.text,o="This statement replaces the value of an argument passed to the function";let u=`${ie(p,i)}&paramName=${s}`;return e.functionBlock!==""&&(u=`${u}&functionName=${e.functionBlock}`),new z(p,n,s,o,u)},cd=(p,i)=>{const e=i.reason.contributingSymptoms.filter(o=>o.type===b.AssignedNone.name),n=i.reason.contributingSymptoms.filter(o=>b.UnusedReturn);let s=`${ie(p,i)}`;if(e.length>0){const o=e[0],u=o.docIndex,f=o.expressionNoValue.value,g=`${o.expressionNoValue.value} has no value`;if(s=`${s}&variant=AssignedNoReturn&expressionNoValueType=${o.expressionNoValue.type}&expressionNoValueUsage=${o.usage}&expressionNoValueText=${o.expressionNoValue.value}&expressionNoValueTarget=${o.target}`,o.expressionNoValue.type==="userDefinedFunction"){const w=i.reason.contributingSymptoms.filter(F=>F.type===b.FunctionPrints.name),S=w.length===1?w[0]:void 0;S&&S.printLines.filter(T=>T.isEndOfExitBranch).length>0&&!S.functionReturns&&(s=`${s}&isFuncPrintNoReturn=true`)}return new z(p,u,f,g,s)}else if(n.length>0){const o=n[0],u=o.docIndex,f=o.unusedFunc.value,g=`The value returned by ${f}() is not used`;if(s=`${s}&variant=UnusedReturn&expressionUnusedType=${o.unusedFunc.type}&expressionUnusedText=${o.unusedFunc.value}`,o.unusedFunc.type==="userDefinedFunction"){const w=i.reason.contributingSymptoms.filter(F=>F.type===b.FunctionPrints.name),S=w.length===1?w[0]:void 0;S&&S.text===o.unusedFunc.value&&(s=`${s}&isFuncPrintsAndReturns=true`)}return new z(p,u,f,g,s)}return z.notImplemented()},ud=(p,i)=>{const e=i.reason.contributingSymptoms[0],n=i.docIndex,s=e.text,o=`The () around ${e.textInParentheses} are not needed`,u=`${ie(p,i)}&text=${s}&returnValueType=${e.contents}&returnValueText=${e.textInParentheses}`;return new z(p,n,s,o,u)},dd=(p,i)=>{const e=i.reason.contributingSymptoms[0],n=i.docIndex,s=e.text,o=e.unusedFunc.value,u=e.unusedFunc.returnType,f=new RegExp("[ ]*.[ ]*"+o),g=s.split(f)[0],w=`${o}() will not change ${g}`,S=`${ie(p,i)}&text=${s}&unusedMethod=${o}&unusedReturnType=${u}&stringValue=${g}`;return new z(p,n,s,w,S)},hd=(p,i)=>{const e=i.reason.contributingSymptoms[0],n=i.docIndex,s=e.text,o=e.unusedFunc.value,u=e.unusedFunc.returnType,f=s.substring(s.indexOf("(")+1,s.lastIndexOf(")")),g=`${o}() will not change ${f}`,w=`${ie(p,i)}&text=${s}&typeFunction=${o}&returnType=${u}&argument=${f}`;return new z(p,n,s,g,w)},fd=(p,i)=>{const e=i.reason.contributingSymptoms[0],n=i.docIndex,s=e.text,o="This type conversion is not needed",u=`${ie(p,i)}&text=${s}&argType=${e.argType}&convertedType=${e.convertedType}&convertedValue=${e.convertedValue}`;return new z(p,n,s,o,u)},gd=(p,i)=>{const e=i.reason.contributingSymptoms[0],n=i.docIndex,s=e.text,o=e.unusedFunc.returnType,u=o!==d.Unknown.name&&o!==d.Invalid.name&&o!==d.NA.name&&o!==d.NotParsed.name,f=u?`The ${o} returned by ${s} is not used`:`The value returned by ${s} is not used`,g=`${ie(p,i)}&expressionUnusedType=${e.unusedFunc.type}&expressionUnusedText=${e.unusedFunc.value}${u?"&returnType="+o:""}`;return new z(p,n,s,f,g)},pd=(p,i)=>{const e=i.docIndex,n=i.reason.contributingSymptoms[0],s=n.text,o=n.loopType,u=n.exitTypes.length,f=n.exitLevel,g=`This ${o} loop always ends the first time it runs because of where return is used`,w=`${ie(p,i)}&text=${s}&loopType=${o}&returnCount=${u}&exitLevel=${f}`;return new z(p,e,s,g,w)},md=(p,i)=>{const e=i.docIndex,n=i.reason.contributingSymptoms,s=n.filter(f=>f.type===b.LoopReturn.name),o=n.filter(f=>f.type===b.LoopVarNotModified.name),u=ie(p,i);if(o.length===1){const f=o[0].text,g="Could this while loop be an if statement?",w=`${u}&variant=${o[0].type}&definitionText=${f}&loopText=${o[0].loopText}${o[0].unmodifiedVars.map(S=>`&loopVar=${S}`)}${s.map(S=>`&earlyExitLine=${S.line+1}&earlyExitText=${S.text}`)}`;return new z(p,e,f,g,w)}return z.notImplemented()},wd=(p,i)=>p.getLineNumber()===i.getLineNumber()&&p.getID()===i.getID()?0:p.getLineNumber()<i.getLineNumber()||p.getLineNumber()===i.getLineNumber()&&p.getID()<i.getID()?-1:1,Ur=(p,i=!1,e=!1,n=!1)=>{const s=[];try{s.push("Sending to DocInfo");let o=new ju(p);s.push("Getting symptom information");const u=o.getSymptoms().sort(wd).map(R=>{try{return R.toJSON()}catch(k){return{error:"Could not process symptom",msg:k.toString()}}});s.push("Getting variable information");const f=Array.from(o.getVariables().values()).flat().map(R=>{try{return R.toJSON()}catch(k){return{error:"Could not process variable",msg:k.toString()}}});s.push("Getting function information");const g=Array.from(o.getUserDefinedFunctions().values()).filter(R=>R.is(t.FunctionName)).map(R=>{try{return R.toJSON()}catch(k){return{error:"Could not process function",msg:k.toString()}}});s.push("Getting class information");const w=Array.from(o.getUserDefinedClasses().values()).map(R=>R.toJSON());s.push("Getting misconception information");const S=Array.from(o.getMisconceptions().values()).map(R=>{try{return R.toJSON()}catch(k){return{error:"Could not process misconception",msg:k.toString()}}});s.push("Getting block information");const F=o.getBlocks(),T={misconceptions:S,symptoms:u,blocks:F.toJSON(),variables:f,functions:g,classes:w};if(i){const R=F.toTree();T.tree=R}if(e){const R=o.getGraph();T.graph=R.toJSON()}return T}catch(o){console.log("Unable to parse",o);const u={misconceptions:[],symptoms:[],blocks:[],variables:[],functions:[],classes:[],error:`Unable to parse! ${o.toString()}`};return s.push(o.toString()),n&&(u.errorDetail=s.join(`
`)),u}},Sd=()=>{let p={};for(let i in b)p[b[i].name]=b[i].description;return p},Id=()=>{let p={};for(let i in L)p[L[i].name]=L[i].description;return p},bd=(p,i=!1)=>{const e=Ur(p),n={};if(i&&(n.parse=e),n.feedback=[],e.hasOwnProperty("misconceptions"))for(const s of e.misconceptions)s.hasOwnProperty("type")&&n.feedback.push(...zu(s).map(o=>o.toJSON()));return n};U.feedback=bd,U.misconceptionInfo=Id,U.parse=Ur,U.symptomInfo=Sd,Object.defineProperty(U,Symbol.toStringTag,{value:"Module"})});
