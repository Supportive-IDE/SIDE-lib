(function(W,q){typeof exports=="object"&&typeof module<"u"?q(exports):typeof define=="function"&&define.amd?define(["exports"],q):(W=typeof globalThis<"u"?globalThis:W||self,q(W["side-lib"]={}))})(this,function(W){"use strict";var tf=Object.defineProperty;var nf=Object.getPrototypeOf;var sf=Reflect.get;var sr=W=>{throw TypeError(W)};var of=(W,q,A)=>q in W?tf(W,q,{enumerable:!0,configurable:!0,writable:!0,value:A}):W[q]=A;var l=(W,q,A)=>of(W,typeof q!="symbol"?q+"":q,A),Ki=(W,q,A)=>q.has(W)||sr("Cannot "+A);var u=(W,q,A)=>(Ki(W,q,"read from private field"),A?A.call(W):q.get(W)),b=(W,q,A)=>q.has(W)?sr("Cannot add the same private member more than once"):q instanceof WeakSet?q.add(W):q.set(W,A),y=(W,q,A,c)=>(Ki(W,q,"write to private field"),c?c.call(W,A):q.set(W,A),A),m=(W,q,A)=>(Ki(W,q,"access private method"),A);var hi=(W,q,A,c)=>({set _(t){y(W,q,t,A)},get _(){return u(W,q,c)}}),Wi=(W,q,A)=>sf(nf(W),A,q);var Vt,Lt,vt,Rt,Et,ln,cn,Zs,ir,Gt,Jt,Xn,Zn,$t,$e,gt,lt,un,Yn,_n,Ie,or,qi,rr,ar,lr,cr,ur,pt,ke,dn,es,mt,dr,fi,ts,ns,hn,ct,Kt,fn,wt,St,Ke,bt,ge,ss,ee,$,hr,fr,gr,pr,mr,wr,ji,Hi,zi,Qi,Sr,Xi,Zi,Yi,Rs,Li,vi,gn,Ri,is,Ys,br,os,_i,z,Qe,Es,Ir,yr,Fr,Nr,Cr,Or,Tr,gi,Mr,se,Wt,rs,pn,Ze,Pe,K,qt,as,Ve,Ee,ye,It,Ei,C,xr,Dr,eo,Ar,en,tt,Re,Br,kr,to,no,Pr,so,Vr,Lr,vr,Rr,Er,Ur,Gr,Jr,$r,Kr,Wr,Kn,qr,rf,jr,Hr,zr,Qr,Xr,Zr,Yr,_r,ea,ta,x,io,na,sa,ia,oa,ra,aa,la,ca,oo,ua,da,ha,fa,be,ga,pa,ma,ro,wa,ao,Sa,lo,ba,Ia,ya,Fa,co,Na,yt,Ft,Nt,ut,mn,wn,Sn,cs,bn,xe,jt,In,us,Ue,ei,Ca,Se,ds,yn,Oa,Fn,Ta,Ma,xa,fs,pe,ue,Da,Aa,pi,Ba,ka,Pa,Va,La,ni,va,me,Fe,Ra,Ea,Us,Ua,Ga,Ja,Nn,$a,Ka,si,Wa,st,Le,Cn,qa,ja,ii,Ha,oi,za,Ye,On,Qa,Xa,ri,Za,Ct,Ot,gs,ps,ms,ce,mi,Ya,_a,el,tl,nl,sl,uo,ws,it,Ss,ho,Tn,ai,il,ie,li,ol,de,Mn,rl,al,te,Te,Z,ll,cl,ul,fo,dl,go,po,hl,fl,gl,pl,ml,We,Ge,xn,dt,qe,wl,Sl,bl,Il,yl,re,Dn,Fl,Nl,De,ot,An,Cl,Ol,bs,mo,je,Tl,rt,wo,So,Ml,xl,Dl,Al,Bl,He,kl,ys,bo,Pl,Vl,Ll,vl,_e,Rl,Ns,Io,El,Ul,af,Gl,Bn,he,ae,Ae,Jl,$l,Kl,yo,Wl,ql,Os,Ts,Ms,Fo,kn,jl,Hl,Pn,zl,Ql,Me,Xl,Zl,Yl,_l,ec,tc,nc,ci,Vn,Ln,zt,Ne,Ds,As,Je,Be,No,sc,ic,oc,rc,ac,Tt,lc,cc,uc,Y,Bs,ks,Ce,Co,dc,lf,hc,Oo,fc,gc,vn,Ps,Xt,Rn,En,Un,Gn,Vs,Zt,ze,Mt,Ls,Yt,_t,Jn,ui,pc,xt,$n,et,mc,To,wc,Sc,vs,ve,Oe,U,bc,tn,Ic,yc,Fc,Nc,Cc,Oc,Tc,Mc,xc,Dc,Mo,xo,Ac,Bc,kc,Pc,Vc,Lc,Wn;class q{constructor(i){this.name=i}}const T=class T extends q{static getCategory(i){return i>=65&&i<=90||i>=97&&i<=122?T.Letter:i>=48&&i<=57?T.Digit:i===46?T.Decimal:i===95?T.Underscore:i===32?T.Space:i===9?T.Tab:i===10||i===13?T.NewLine:i===40?T.OpenParentheses:i===41?T.CloseParentheses:i===123?T.OpenCurlyBrace:i===125?T.CloseCurlyBrace:i===91?T.OpenSquareBracket:i===93?T.CloseSquareBracket:i===44?T.Comma:i===58?T.Colon:i===59?T.Semicolon:i===43?T.Plus:i===45?T.Minus:i===42?T.Asterisk:i===37?T.Modulo:i===61?T.Equals:i===60?T.LessThan:i===62?T.GreaterThan:i===33?T.Exclamation:i===47?T.ForwardSlash:i===92?T.BackSlash:i===35?T.Hash:i===39?T.SingleQuote:i===34?T.DoubleQuote:i===64?T.At:T.Unknown}isQuote(){return this===T.SingleQuote||this===T.DoubleQuote}};l(T,"Letter",new T("letter")),l(T,"Digit",new T("digit")),l(T,"Decimal",new T("decimal")),l(T,"Underscore",new T("underscore")),l(T,"Space",new T("space")),l(T,"Tab",new T("tab")),l(T,"NewLine",new T("newline")),l(T,"OpenParentheses",new T("openParentheses")),l(T,"CloseParentheses",new T("closeParentheses")),l(T,"OpenCurlyBrace",new T("openCurlyBrace")),l(T,"CloseCurlyBrace",new T("closeCurlyBrace")),l(T,"OpenSquareBracket",new T("openSquareBracket")),l(T,"CloseSquareBracket",new T("closeSquareBracket")),l(T,"Comma",new T("comma")),l(T,"Colon",new T("colon")),l(T,"Semicolon",new T("semicolon")),l(T,"Plus",new T("plus")),l(T,"Minus",new T("minus")),l(T,"Asterisk",new T("asterisk")),l(T,"Modulo",new T("modulo")),l(T,"Equals",new T("equals")),l(T,"LessThan",new T("lessThan")),l(T,"GreaterThan",new T("greaterThan")),l(T,"Exclamation",new T("exclamation")),l(T,"ForwardSlash",new T("forwardSlash")),l(T,"BackSlash",new T("backSlash")),l(T,"Hash",new T("hash")),l(T,"SingleQuote",new T("singleQuote")),l(T,"DoubleQuote",new T("doubleQuote")),l(T,"At",new T("at")),l(T,"Unknown",new T("unknown"));let A=T;const B=class B extends q{};l(B,"BlockDefinitions",new B("BlockDefinitions")),l(B,"LogicalOperators",new B("LogicalOperators")),l(B,"Types",new B("Types")),l(B,"MathsOperators",new B("MathsOperators")),l(B,"ComparisonOperators",new B("ComparisonOperators")),l(B,"OtherKeywords",new B("OtherKeywords")),l(B,"BuiltInFunctions",new B("BuiltInFunctions")),l(B,"BuiltInMethods",new B("BuiltInMethods")),l(B,"OtherMethods",new B("OtherMethods")),l(B,"Identifiers",new B("Identifiers")),l(B,"MagicMethods",new B("MagicMethods")),l(B,"SpecialVariables",new B("SpecialVariables")),l(B,"Properties",new B("Properties")),l(B,"BuiltInExceptions",new B("BuiltInExceptions")),l(B,"Literals",new B("Literals")),l(B,"CompoundTypes",new B("CompoundTypes")),l(B,"Other",new B("Other")),l(B,"Comment",new B("Comment")),l(B,"Unknown",new B("Unknown")),l(B,"BuiltInModules",new B("BuiltInModules")),l(B,"ModuleFunctions",new B("ModuleFunctions")),l(B,"ModuleProperties",new B("ModuleProperties")),l(B,"ClassAttributes",new B("ClassAttributes")),l(B,"ImportedEntities",new B("ImportedEntities")),l(B,"TypeHint",new B("TypeHint")),l(B,"SyntacticSugar",new B("SyntacticSugar")),l(B,"FunctionCall",new B("FunctionCall")),l(B,"MethodCall",new B("MethodCall")),l(B,"ExceptionCall",new B("ExceptionCall")),l(B,"BlockDefinitionStatement",new B("BlockDefinitionStatement")),l(B,"Group",new B("Group")),l(B,"MultipartValue",new B("MultipartValue")),l(B,"Assignment",new B("Assigment")),l(B,"KeywordStatement",new B("KeywordStatement"));let c=B;const r=class r extends q{};l(r,"ClassDefinition",new r("class")),l(r,"FunctionDefinition",new r("def")),l(r,"ElifDefinition",new r("elif")),l(r,"ElseDefinition",new r("else")),l(r,"ExceptDefinition",new r("except")),l(r,"FinallyDefinition",new r("finally")),l(r,"ForDefinition",new r("for")),l(r,"IfDefinition",new r("if")),l(r,"LambdaDefinition",new r("lambda")),l(r,"TryDefinition",new r("try")),l(r,"WhileDefinition",new r("while")),l(r,"DocumentDefinition",new r("document")),l(r,"ListComprehension",new r("listComprehension")),l(r,"AndOperator",new r("and")),l(r,"NotOperator",new r("not")),l(r,"OrOperator",new r("or")),l(r,"FalseType",new r("False")),l(r,"NoneType",new r("None")),l(r,"TrueType",new r("True")),l(r,"AsKeyword",new r("AsKeyword")),l(r,"AssertKeyword",new r("AssertKeyword")),l(r,"BreakKeyword",new r("BreakKeyword")),l(r,"ContinueKeyword",new r("continue")),l(r,"DelKeyword",new r("del")),l(r,"FromKeyword",new r("from")),l(r,"ImportKeyword",new r("import")),l(r,"InKeyword",new r("in")),l(r,"IsKeyword",new r("is")),l(r,"NotInKeyword",new r("not in")),l(r,"IsNotKeyword",new r("is not")),l(r,"PassKeyword",new r("pass")),l(r,"RaiseKeyword",new r("raise")),l(r,"ReturnKeyword",new r("return")),l(r,"WithKeyword",new r("with")),l(r,"YieldKeyword",new r("yield")),l(r,"GlobalKeyword",new r("global")),l(r,"AddOperator",new r("+")),l(r,"SubtractOperator",new r("-")),l(r,"MultiplyOperator",new r("*")),l(r,"DivideOperator",new r("/")),l(r,"ModulusOperator",new r("%")),l(r,"ExponentOperator",new r("**")),l(r,"IntDivideOperator",new r("//")),l(r,"AssignmentOperator",new r("=")),l(r,"IncrementOperator",new r("+=")),l(r,"DecrementOperator",new r("-=")),l(r,"MultiplyAssignOperator",new r("*=")),l(r,"DivideAssignOperator",new r("/=")),l(r,"RemainderAssignOperator",new r("%=")),l(r,"IntDivideAssignOperator",new r("//=")),l(r,"ExponentAssignOperator",new r("**=")),l(r,"EqualOperator",new r("==")),l(r,"NotEqualOperator",new r("!=")),l(r,"GreaterThanOperator",new r(">")),l(r,"LessThanOperator",new r("<")),l(r,"GreaterThanOrEqualOperator",new r(">=")),l(r,"LessThanOrEqualOperator",new r("<=")),l(r,"TypeHintReturn",new r("->")),l(r,"Decorator",new r("decorator")),l(r,"AbsFunction",new r("abs")),l(r,"AllFunction",new r("all")),l(r,"AnyFunction",new r("any")),l(r,"AsciiFunction",new r("ascii")),l(r,"AssertFunction",new r("assert")),l(r,"BinFunction",new r("bin")),l(r,"BoolFunction",new r("bool")),l(r,"CallableFunction",new r("callable")),l(r,"ChrFunction",new r("chr")),l(r,"DictFunction",new r("dict")),l(r,"DivModFunction",new r("divmod")),l(r,"EnumerateFunction",new r("enumerate")),l(r,"EvalFunction",new r("eval")),l(r,"ExecFunction",new r("exec")),l(r,"ExitFunction",new r("exit")),l(r,"FilterFunction",new r("filter")),l(r,"FloatFunction",new r("float")),l(r,"FormatFunction",new r("format")),l(r,"GetAttrFunction",new r("getattr")),l(r,"GlobalsFunction",new r("globals")),l(r,"HasAttrFunction",new r("hasattr")),l(r,"InputFunction",new r("input")),l(r,"IntFunction",new r("int")),l(r,"IsInstanceFunction",new r("isinstance")),l(r,"LenFunction",new r("len")),l(r,"ListFunction",new r("list")),l(r,"MapFunction",new r("map")),l(r,"MaxFunction",new r("max")),l(r,"MinFunction",new r("min")),l(r,"OpenFunction",new r("open")),l(r,"OrdFunction",new r("ord")),l(r,"PowFunction",new r("pow")),l(r,"PrintFunction",new r("print")),l(r,"QuitFunction",new r("quit")),l(r,"RangeFunction",new r("range")),l(r,"ReversedFunction",new r("reversed")),l(r,"RoundFunction",new r("round")),l(r,"SetFunction",new r("set")),l(r,"SortedFunction",new r("sorted")),l(r,"StrFunction",new r("str")),l(r,"SumFunction",new r("sum")),l(r,"TupleFunction",new r("tuple")),l(r,"TypeFunction",new r("type")),l(r,"ZipFunction",new r("zip")),l(r,"Capitalize",new r("capitalize")),l(r,"Casefold",new r("casefold")),l(r,"Center",new r("center")),l(r,"Count",new r("count")),l(r,"Encode",new r("encode")),l(r,"EndsWith",new r("endswith")),l(r,"ExpandTabs",new r("expandtabs")),l(r,"Find",new r("find")),l(r,"Format",new r("format")),l(r,"FormatMap",new r("format_map")),l(r,"Index",new r("index")),l(r,"IsAlnum",new r("isalnum")),l(r,"IsAlpha",new r("isalpha")),l(r,"IsAscii",new r("isascii")),l(r,"IsDecimal",new r("isdecimal")),l(r,"IsDigit",new r("isdigit")),l(r,"IsIdentifier",new r("isidentifier")),l(r,"IsLower",new r("islower")),l(r,"IsNumeric",new r("isnumeric")),l(r,"IsPrintable",new r("isprintable")),l(r,"IsSpace",new r("isspace")),l(r,"IsTitle",new r("istitle")),l(r,"IsUpper",new r("isupper")),l(r,"Join",new r("join")),l(r,"LJust",new r("ljust")),l(r,"Lower",new r("lower")),l(r,"LStrip",new r("lstrip")),l(r,"MakeTrans",new r("maketrans")),l(r,"Partition",new r("partition")),l(r,"Replace",new r("replace")),l(r,"RFind",new r("rfind")),l(r,"RIndex",new r("rindex")),l(r,"RJust",new r("rjust")),l(r,"RPartition",new r("rpartition")),l(r,"RSplit",new r("rsplit")),l(r,"RStrip",new r("rstrip")),l(r,"Split",new r("split")),l(r,"SplitLines",new r("splitlines")),l(r,"StartsWith",new r("startswith")),l(r,"Strip",new r("strip")),l(r,"SwapCase",new r("swapcase")),l(r,"Title",new r("title")),l(r,"Translate",new r("translate")),l(r,"Upper",new r("upper")),l(r,"ZFill",new r("zfill")),l(r,"Append",new r("append")),l(r,"Clear",new r("clear")),l(r,"Copy",new r("copy")),l(r,"Extend",new r("extend")),l(r,"Insert",new r("insert")),l(r,"Pop",new r("pop")),l(r,"Remove",new r("remove")),l(r,"Reverse",new r("reverse")),l(r,"Sort",new r("sort")),l(r,"FromKeys",new r("fromkeys")),l(r,"Get",new r("get")),l(r,"Items",new r("items")),l(r,"Keys",new r("keys")),l(r,"PopItem",new r("popitem")),l(r,"SetDefault",new r("setdefault")),l(r,"Update",new r("update")),l(r,"Values",new r("values")),l(r,"Add",new r("add")),l(r,"Difference",new r("difference")),l(r,"DifferenceUpdate",new r("difference_update")),l(r,"Discard",new r("discard")),l(r,"Intersection",new r("intersection")),l(r,"IntersectionUpdate",new r("intersection_update")),l(r,"IsDisjoint",new r("isdisjoint")),l(r,"IsSubset",new r("issubset")),l(r,"IsSuperset",new r("issuperset")),l(r,"SymmetricDifference",new r("symmetric_difference")),l(r,"SymmetricDifferenceUpdate",new r("symmetric_difference_update")),l(r,"Union",new r("union")),l(r,"Close",new r("close")),l(r,"Detach",new r("detach")),l(r,"FileNo",new r("fileno")),l(r,"Flush",new r("flush")),l(r,"IsAtty",new r("isatty")),l(r,"Read",new r("read")),l(r,"Readable",new r("readable")),l(r,"ReadLine",new r("readline")),l(r,"ReadLines",new r("readlines")),l(r,"Seek",new r("seek")),l(r,"Seekable",new r("seekable")),l(r,"Tell",new r("tell")),l(r,"Truncate",new r("truncate")),l(r,"Writable",new r("writable")),l(r,"Write",new r("write")),l(r,"WriteLines",new r("writelines")),l(r,"Main",new r("__main__")),l(r,"Cmp",new r("__cmp__")),l(r,"Eq",new r("__eq__")),l(r,"Ne",new r("__ne__")),l(r,"Lt",new r("__lt__")),l(r,"Gt",new r("__gt__")),l(r,"Le",new r("__le__")),l(r,"Ge",new r("__ge__")),l(r,"Str",new r("__str__")),l(r,"SpecialContains",new r("__contains__")),l(r,"SpecialLen",new r("__len__")),l(r,"Name",new r("__name__")),l(r,"Self",new r("__self__")),l(r,"Doc",new r("__doc__")),l(r,"GetAttrVariable",new r("__getattr__")),l(r,"SetAttrVariable",new r("__setattr__")),l(r,"ClassVariable",new r("__class__")),l(r,"R",new r("r")),l(r,"F",new r("f")),l(r,"Sep",new r("sep")),l(r,"End",new r("end")),l(r,"Dot",new r(".")),l(r,"OpenParenthesis",new r("(")),l(r,"CloseParenthesis",new r(")")),l(r,"OpenSquareBracket",new r("[")),l(r,"CloseSquareBracket",new r("]")),l(r,"OpenBrace",new r("{")),l(r,"CloseBrace",new r("}")),l(r,"Comma",new r(",")),l(r,"Colon",new r(":")),l(r,"SingleQuote",new r("'")),l(r,"DoubleQuote",new r('"')),l(r,"MultiLineCommentDelimiter",new r("'''")),l(r,"ImportAll",new r("import all (*)")),l(r,"NamedImport",new r("named import")),l(r,"ExceptionName",new r("exceptionName")),l(r,"VariableName",new r("variableName")),l(r,"FunctionName",new r("functionName")),l(r,"MethodName",new r("methodName")),l(r,"ClassName",new r("className")),l(r,"PropertyName",new r("propertyName")),l(r,"ModuleName",new r("moduleName")),l(r,"IntLiteral",new r("intLiteral")),l(r,"StringLiteral",new r("stringLiteral")),l(r,"ContinuationLine",new r("continuationLine")),l(r,"Separator",new r("separator")),l(r,"FloatLiteral",new r("floatLiteral")),l(r,"SingleLineComment",new r("singleLineComment")),l(r,"MultiLineComment",new r("multilineComment")),l(r,"TypeHint",new r("typeHint")),l(r,"StrType",new r("strType")),l(r,"IntType",new r("intType")),l(r,"FloatType",new r("floatType")),l(r,"BoolType",new r("boolType")),l(r,"ListType",new r("listType")),l(r,"SetType",new r("setType")),l(r,"DictType",new r("dictType")),l(r,"TupleType",new r("tupleType")),l(r,"ListDefinition",new r("listDefinition")),l(r,"TupleDefinition",new r("tupleDefinition")),l(r,"SetDefinition",new r("setDefinition")),l(r,"DictDefinition",new r("dictDefinition")),l(r,"IndexKey",new r("indexKey")),l(r,"Slice",new r("slice")),l(r,"Unknown",new r("unknown")),l(r,"RandomModule",new r("randomModule")),l(r,"MathModule",new r("mathModule")),l(r,"StringModule",new r("stringModule")),l(r,"ReModule",new r("reModule")),l(r,"Pattern",new r("Pattern")),l(r,"Match",new r("Match")),l(r,"Sys",new r("sys")),l(r,"Seed",new r("seed")),l(r,"GetState",new r("getstate")),l(r,"SetState",new r("setstate")),l(r,"GetRandBits",new r("getrandbits")),l(r,"RandRange",new r("randrange")),l(r,"RandInt",new r("randint")),l(r,"Choice",new r("choice")),l(r,"Choices",new r("choices")),l(r,"Shuffle",new r("shuffle")),l(r,"Sample",new r("sample")),l(r,"RandomMethod",new r("random")),l(r,"Uniform",new r("uniform")),l(r,"Triangular",new r("triangular")),l(r,"BetaVariate",new r("betavariate")),l(r,"ExpoVariate",new r("expovariate")),l(r,"GammaVariate",new r("gammavariate")),l(r,"Gauss",new r("gauss")),l(r,"LogNormVariate",new r("lognormvariate")),l(r,"NormalVariate",new r("normalvariate")),l(r,"VonMisesVariate",new r("vonmisesvariate")),l(r,"ParetoVariate",new r("paretovariate")),l(r,"WeibullVariate",new r("weibullvariate")),l(r,"Acos",new r("acos")),l(r,"Acosh",new r("acosh")),l(r,"Asin",new r("asin")),l(r,"Asinh",new r("asinh")),l(r,"Atan",new r("atan")),l(r,"Atan2",new r("atan2")),l(r,"Atanh",new r("atanh")),l(r,"Ceil",new r("ceil")),l(r,"Comb",new r("comb")),l(r,"CopySign",new r("copysign")),l(r,"Cos",new r("cos")),l(r,"Cosh",new r("cosh")),l(r,"Degrees",new r("degrees")),l(r,"Dist",new r("dist")),l(r,"Erf",new r("erf")),l(r,"Erfc",new r("erfc")),l(r,"Exp",new r("exp")),l(r,"Expm1",new r("expm1")),l(r,"Fabs",new r("fabs")),l(r,"Factorial",new r("factorial")),l(r,"Floor",new r("floor")),l(r,"Fmod",new r("fmod")),l(r,"Frexp",new r("frexp")),l(r,"Fsum",new r("fsum")),l(r,"Gamma",new r("gamma")),l(r,"Gcd",new r("gcd")),l(r,"Hypot",new r("hypot")),l(r,"IsClose",new r("isclose")),l(r,"IsFinite",new r("isfinite")),l(r,"IsInf",new r("isinf")),l(r,"IsNaN",new r("isnan")),l(r,"ISqrt",new r("isqrt")),l(r,"Ldexp",new r("ldexp")),l(r,"LGamma",new r("lgamma")),l(r,"Log",new r("log")),l(r,"Log10",new r("log10")),l(r,"Log1P",new r("log1p")),l(r,"Log2",new r("log2")),l(r,"Perm",new r("perm")),l(r,"Pow",new r("pow")),l(r,"Prod",new r("prod")),l(r,"Radians",new r("radians")),l(r,"Remainder",new r("remainder")),l(r,"Sin",new r("sin")),l(r,"Sinh",new r("sinh")),l(r,"Sqrt",new r("sqrt")),l(r,"Tan",new r("tan")),l(r,"Tanh",new r("tanh")),l(r,"Trunc",new r("trunc")),l(r,"E",new r("e")),l(r,"Inf",new r("inf")),l(r,"Nan",new r("nan")),l(r,"Pi",new r("pi")),l(r,"Tau",new r("tau")),l(r,"AsciiLetters",new r("ascii_letters")),l(r,"AsciiLowercase",new r("ascii_lowercase")),l(r,"AsciiUppercase",new r("ascii_uppercase")),l(r,"Digits",new r("digits")),l(r,"Hexdigits",new r("hexdigits")),l(r,"Octdigits",new r("octdigits")),l(r,"Punctuation",new r("punctuation")),l(r,"Printable",new r("printable")),l(r,"Whitespace",new r("whitespace")),l(r,"Formatter",new r("Formatter")),l(r,"Template",new r("Template")),l(r,"Capwords",new r("capwords")),l(r,"ReA",new r("A")),l(r,"ReASCII",new r("ASCII")),l(r,"ReDebug",new r("DEBUG")),l(r,"ReI",new r("I")),l(r,"ReIGNORECASE",new r("IGNORECASE")),l(r,"ReL",new r("L")),l(r,"ReLOCALE",new r("LOCALE")),l(r,"ReM",new r("M")),l(r,"ReMULTILINE",new r("MULTILINE")),l(r,"ReS",new r("S")),l(r,"ReDOTALL",new r("DOTALL")),l(r,"ReX",new r("X")),l(r,"ReVERBOSE",new r("VERBOSE")),l(r,"Compile",new r("compile")),l(r,"Search",new r("search")),l(r,"Match",new r("match")),l(r,"FullMatch",new r("fullmatch")),l(r,"FindAll",new r("findall")),l(r,"FindIter",new r("finditer")),l(r,"Sub",new r("sub")),l(r,"SubN",new r("subn")),l(r,"Escape",new r("escape")),l(r,"Purge",new r("purge")),l(r,"AddAuditHook",new r("addaudithook")),l(r,"Audit",new r("audit")),l(r,"CallTracing",new r("call_tracing")),l(r,"ClearTypeCache",new r("_clear_type_cache")),l(r,"CurrentFrames",new r("_current_frames")),l(r,"CurrentExceptions",new r("_current_exceptions")),l(r,"BreakpointHook",new r("breakpointhook")),l(r,"DebugMallocStats",new r("_debugmallocstats")),l(r,"DisplayHook",new r("displayhook")),l(r,"ExceptHook",new r("excepthook")),l(r,"ExcInfo",new r("exc_info")),l(r,"SysExit",new r("exit")),l(r,"GetAllocatedBlocks",new r("getallocatedblocks")),l(r,"GetAndroidApiLevel",new r("getandroidapilevel")),l(r,"GetDefaultEncoding",new r("getdefaultencoding")),l(r,"GetDLOpenFlags",new r("getdlopenflags")),l(r,"GetFileSystemEncoding",new r("getfilesystemencoding")),l(r,"GetFileSystemEncodeErrors",new r("getfilesystemencodeerrors")),l(r,"GetRefCount",new r("getrefcount")),l(r,"GetRecursionLimit",new r("getrecursionlimit")),l(r,"GetSizeOf",new r("getsizeof")),l(r,"GetSwitchInterval",new r("getswitchinterval")),l(r,"GetFrame",new r("_getframe")),l(r,"GetProfile",new r("getprofile")),l(r,"GetTrace",new r("gettrace")),l(r,"GetWindowsVersion",new r("getwindowsversion")),l(r,"GetAsyncGenHooks",new r("get_asyncgen_hooks")),l(r,"GetCoroutineOriginTrackingDepth",new r("get_coroutine_origin_tracking_depth")),l(r,"Intern",new r("intern")),l(r,"IsFinalizing",new r("is_finalizing")),l(r,"SetDLOpenFlags",new r("setdlopenflags")),l(r,"SetProfile",new r("setprofile")),l(r,"SetRecursionLimit",new r("setrecursionlimit")),l(r,"SetSwitchInterval",new r("setswitchinterval")),l(r,"SetTrace",new r("settrace")),l(r,"SetAsyncgenHooks",new r("set_asyncgen_hooks")),l(r,"EnableLegacyWindowsFSEncoding",new r("_enablelegacywindowsfsencoding")),l(r,"ABIFlags",new r("abiflags")),l(r,"Argv",new r("argv")),l(r,"BaseExecPrefix",new r("base_exec_prefix")),l(r,"BasePrefix",new r("base_prefix")),l(r,"ByteOrder",new r("byte_order")),l(r,"BuiltInModuleNames",new r("built_in_module_names")),l(r,"Copyright",new r("copyright")),l(r,"DllHandle",new r("dllhandle")),l(r,"DontWriteBytecode",new r("dont_write_bytecode")),l(r,"PycachePrefix",new r("pycache_prefix")),l(r,"ExecPrefix",new r("exec_prefix")),l(r,"Executable",new r("executable")),l(r,"Flags",new r("flags")),l(r,"FloatInfo",new r("float_info")),l(r,"FloatReprStyle",new r("float_repr_style")),l(r,"HashInfo",new r("hash_info")),l(r,"HexVersion",new r("hexversion")),l(r,"Implementation",new r("implementation")),l(r,"IntInfo",new r("int_info")),l(r,"LastType",new r("last_type")),l(r,"LastValue",new r("last_value")),l(r,"LastTraceback",new r("last_traceback")),l(r,"MaxSize",new r("maxsize")),l(r,"MaxUnicode",new r("maxunicode")),l(r,"MetaPath",new r("meta_path")),l(r,"Modules",new r("modules")),l(r,"OrigArgv",new r("orig_argv")),l(r,"Path",new r("path")),l(r,"PathHooks",new r("path_hooks")),l(r,"PathImporterCache",new r("path_importer_cache")),l(r,"Platform",new r("platform")),l(r,"Prefix",new r("prefix")),l(r,"PS1",new r("ps1")),l(r,"PS2",new r("ps2")),l(r,"StdIn",new r("stdin")),l(r,"StdOut",new r("stdout")),l(r,"StdErr",new r("stderr")),l(r,"StdLibModuleNames",new r("stdlib_module_names")),l(r,"ThreadInfo",new r("thread_info")),l(r,"TracebackLimit",new r("tracebacklimit")),l(r,"Version",new r("version")),l(r,"ApiVersion",new r("api_version")),l(r,"VersionInfo",new r("version_info")),l(r,"WarnOptions",new r("warnoptions")),l(r,"WinVer",new r("winver")),l(r,"XOptions",new r("_xoptions")),l(r,"UserDefinedFunctionCall",new r("UserDefinedFunctionCall")),l(r,"BuiltInFunctionCall",new r("BuiltInFunctionCall")),l(r,"UserDefinedMethodCall",new r("UserDefinedMethodCall")),l(r,"BuiltInMethodCall",new r("BuiltInMethodCall")),l(r,"ExceptionCall",new r("ExceptionCall")),l(r,"FunctionDefinitionStatement",new r("FunctionDefinitionStatement")),l(r,"MethodDefinitionStatement",new r("MethodDefinitionStatement")),l(r,"ForDefinitionStatement",new r("ForDefinitionStatement")),l(r,"ExceptDefinitionStatement",new r("ExceptDefinitionStatement")),l(r,"ClassDefinitionStatement",new r("ClassDefinitionStatement")),l(r,"LambdaDefinitionStatement",new r("LambdaDefinitionStatement")),l(r,"IfDefinitionStatement",new r("IfDefinitionStatement")),l(r,"ElifDefinitionStatement",new r("ElifDefinitionStatement")),l(r,"ElseDefinitionStatement",new r("ElseDefinitionStatement")),l(r,"WhileDefinitionStatement",new r("WhileDefinitionStatement")),l(r,"TryDefinitionStatement",new r("TryDefinitionStatement")),l(r,"FinallyDefinitionStatement",new r("FinallyDefinitionStatement")),l(r,"TernaryStatement",new r("TernaryStatement")),l(r,"WithDefinitionStatement",new r("WithStatment")),l(r,"GroupStatement",new r("GroupStatement")),l(r,"FString",new r("FString")),l(r,"SubscriptedExpression",new r("SubscriptedExpression")),l(r,"CalculatedExpression",new r("CalculatedExpression")),l(r,"ComparisonExpression",new r("ComparisonExpression")),l(r,"BooleanExpression",new r("BooleanExpression")),l(r,"IteratorExpression",new r("IteratorExpression")),l(r,"CombinedStringLiteral",new r("CombinedStringLiteral")),l(r,"ReturnStatement",new r("ReturnStatement")),l(r,"PropertyCallExpression",new r("PropertyCallExpression")),l(r,"AssignmentStatement",new r("AssignmentStatement")),l(r,"ChangeStatement",new r("ChangeStatement")),l(r,"ImportStatement",new r("ImportStatement")),l(r,"AssertStatement",new r("AssertStatement")),l(r,"GlobalStatement",new r("GlobalStatement")),l(r,"ThrowStatement",new r("ThrowStatement"));let t=r;const L=class L extends q{constructor(i,e=!1,n=new Map,s=new Map){super(i),this.isCustom=e,this.attributes=n,this.methods=s}static createCustomType(i){return L[i]=new L(i,!0),L[i]}toJSON(){return{name:this.name,attributes:Array.from(this.attributes.values()).map(i=>i.toJSON()),methods:Array.from(this.methods.values()).map(i=>i.toJSON())}}};l(L,"Int",new L("int")),l(L,"Float",new L("float")),l(L,"Number",new L("number (int or float)")),l(L,"String",new L("string")),l(L,"Bool",new L("bool")),l(L,"List",new L("list")),l(L,"Set",new L("set")),l(L,"Tuple",new L("tuple")),l(L,"Dict",new L("dictionary")),l(L,"File",new L("file")),l(L,"Function",new L("function")),l(L,"Class",new L("class")),l(L,"None",new L("none")),l(L,"Exception",new L("exception")),l(L,"Unknown",new L("unknown data type")),l(L,"NA",new L("N/A")),l(L,"NotParsed",new L("not parsed")),l(L,"Invalid",new L("invalid")),l(L,"Undefined",new L("undefined")),l(L,"Random",new L("random")),l(L,"Math",new L("math")),l(L,"StringModule",new L("string module")),l(L,"Re",new L("re")),l(L,"Pattern",new L("Pattern")),l(L,"Match",new L("Match")),l(L,"Sys",new L("sys"));let d=L;const R=class R extends q{constructor(e,n){super(e);l(this,"description");this.description=n}};l(R,"AssignCompares",new R("AssignCompares","A single equals is used where a boolean expression is expected, e.g. in a conditional statement. This may be a typo or confusion between single and double equals operators.")),l(R,"ColonAssigns",new R("ColonAssigns","A colon is used between a variable name and a value. This may be a typo.")),l(R,"CompareMultipleValuesWithOr",new R("CompareMultipleValuesWithOr","A boolean expression has the form a == some_value or other_value, where other_value is non-boolean. There is likely a misunderstanding of the syntax of comparing multiple values.")),l(R,"ComparisonWithBoolLiteral",new R("ComparisonWithBoolLiteral",'A boolean expression contains "== True" or "== False". The programmer may believe that explicitly checking equality is always necessary in a boolean expression.')),l(R,"DeferredReturn",new R("DeferredReturn","Code follows a return statement in a function. The programmer may not realise that a return statement causes the function to exit immediately.")),l(R,"ForLoopVarIsLocal",new R("ForLoopVarIsLocal","An iterating variable in a for loop overwrites a variable declared before the loop and the value is different from the overwritten value, or the values cannot be determined. This potential misconception is similar to IteratorInitialisedOutsideLoop.")),l(R,"FunctionCallsNoParentheses",new R("FunctionCallsNoParentheses","An undefined variable has the same name as a function. There may be a misunderstanding about how to call a function. Caution: functions in Python are first class objects, so it is possible that use of the function name without parentheses is intended and there is no misconception.")),l(R,"FunctionCallsUseSquareBrackets",new R("FunctionCallsUseSquareBrackets","The name of a function is called followed by square brackets rather than parentheses. The programmer may not be aware of when to use which type of bracket.")),l(R,"IterationRequiresTwoLoops",new R("IterationRequiresTwoLoops","A while loop with an integer loop variable contains a nested for loop. The while loop variable is only modified in the nested for loop and is used to count items in the variable iterated in the for loop. The two nested loops could be replaced with a single for loop using enumerate() or range().")),l(R,"IteratorInitialisedOutsideLoop",new R("TargetInitialisedOutsideLoop","The target variable in a for loop is initialised before the loop with the same value. The programmer may not know that the iterating variable is initialised in the for loop definition.")),l(R,"LocalVariablesAreGlobal",new R("LocalVariablesAreGlobal","An undefined variable in document scope has the same name as a variable with function scope. This may indicate a misunderstanding of variable scope.")),l(R,"LoopCounter",new R("LoopCounter","A for loop target variable is modified in the loop and the modified variable is not used. This may indicate confusion over how loops use loop variables.")),l(R,"MapToBooleanWithIf",new R("MapToBooleanWithIf","A conditional statement checks a boolean expression only to return or assign a value that matches the value of the boolean expression. The programmer may not realise that a boolean expression can be assigned or returned directly.")),l(R,"MapToBooleanWithTernaryOperator",new R("MapToBooleanWithTernaryOperator","A ternary checks a boolean expression only to return or assign a value that matches the value of the boolean expression. The programmer may not realise that a boolean expression can be assigned or returned directly.")),l(R,"NoKeyword",new R("NoKeyword","A block definition keyword (e.g. def, if, while) is missing where one is expected. The programmer may not realise that the keyword is required.")),l(R,"NoReservedWords",new R("NoReservedWords","Any string that meets naming character constraints can be used as an identifier (name of a variable, function, method, or class).")),l(R,"ParameterMustBeAssignedInFunction",new R("ParameterMustBeAssignedInFunction","A user defined function has named parameter but the parameter value is overwritten in the function before it is used e.g. by prompting for command line input. This indicates potential misconceptions about the purpose or use of function parameters.")),l(R,"ParenthesesOnlyIfArgument",new R("ParenthesesOnlyIfArgument","An undefined variable has the same name as a user-defined function with no arguments. There may be a misunderstanding of the syntax of function calls.")),l(R,"PrintSameAsReturn",new R("PrintSameAsReturn","A call to a function that prints but does not return (including the print() function) is assigned or passed, or a call to a function that prints before returning a value is not assigned or passed. There may be confusion about printing a value versus returning a value.")),l(R,"ReturnCall",new R("ReturnCall","Function return values are surrounded by parentheses. There may be a belief that return needs to be called like a function.")),l(R,"ReturnWaitsForLoop",new R("ReturnWaitsForLoop","A return statement in a loop causes the loop to consistently exit on the first iteration. Typically due to a missing if statement, there may be an expectation that the loop implicitly knows when to return and when to continue.")),l(R,"SequentialIfsAreExclusive",new R("ConditionalIsSequence","If statements with very similar conditional statements appear in a sequence. There may be a belief that subsequent if statements will only execute if the previous condition does not. The programmer may not be aware of the efficiency drawbacks of using sequential if statements where a multiway conditional would be more appropriate.")),l(R,"StringMethodsModifyTheString",new R("StringMethodsModifyTheString","A string method is called but the result is not saved or passed. There may be an assumption that string methods mutate the string.")),l(R,"TypeConversionModifiesArgument",new R("TypeConversionModifiesArgument","A type conversion function (e.g. int(), float()) is called but the return value is not saved or used.")),l(R,"TypeMustBeSpecified",new R("TypeMustBeSpecified","A value that is guaranteed to have a particular data type is passed to a type conversion function that returns the same data type. In the case of literals, there may be a belief that type must be specified as in strongly typed languages. In other cases, there may be a misunderstanding or lack of confidence in how Python dynamically determines type.")),l(R,"UnusedReturn",new R("UnusedReturn","The result of a call to a function / method that returns a value is not used in some way.")),l(R,"WhileSameAsIf",new R("WhileSameAsIf","A while loop does not modify any of its loop variables and may also always exit during the first iteration. Where this behaviour is intentional, the while definition would be better replaced with an if statement. Where the loop does not exit, there is a risk of an infinite loop."));let v=R;const j=class j extends q{constructor(e,n){super(e);l(this,"description");this.description=n}};l(j,"Equality",new j("Equality","A correctly formed equality check, e.g. x == y, where a Boolean expression is expected, such as an if statement or a while loop definition.")),l(j,"Assignment",new j("Assignment","A correctly formed assigment statement.")),l(j,"MultipleEquality",new j("MultipleEquality","A boolean expression comprised of multiple correctly formed equality checks.")),l(j,"BooleanVariableCondition",new j("BooleanVariableCondition","A single Boolean variable is used as a condition statement instead of explicitly comparing the variable to True or False.")),l(j,"ReturnLast",new j("ReturnLast","A function contains at least one return statement and all returns are the last statement in their branch.")),l(j,"NewForLoopVar",new j("NewForLoopVar","A new variable is created in a for loop definition.")),l(j,"FunctionCall",new j("FunctionCall","A correctly formed function call.")),l(j,"SingleCounterLoop",new j("SingleCounterLoop","A counter loop that is not nested in while loop.")),l(j,"VariablesInMultipleScopes",new j("VariablesInMultipleScopes","The document has defined variables in function and document scope. If there are variables in document scope that have the same name as valid function scope variables, the document scope variables are not undefined.")),l(j,"ForLoopTargetNotModified",new j("ForLoopTargetNotModified","A for loop target variable is used in the loop without modification.")),l(j,"BooleanExpressionUsedAsValue",new j("BooleanExpressionUsedAsValue","A non-literal Boolean expression is assigned or returned directly.")),l(j,"UsedReturn",new j("UsedReturn","The value returned by a function is used or stored.")),l(j,"ReturnNoParentheses",new j("ReturnNoParentheses","A return value is not in parentheses.")),l(j,"MultiBranchConditional",new j("MultiBranchConditional","A conditional made up of multiple branches.")),l(j,"ParameterCalled",new j("ParameterCalled","An function parameter is called in the function before or without modification.")),l(j,"StringMethodAssigned",new j("StringMethodAssigned","The result of a string method call is assigned or passed.")),l(j,"ConversionAssigned",new j("ConversionAssigned","The result of a type conversion function call is assigned or passed.")),l(j,"WhileLoopProgresses",new j("WhileLoopProgresses","The loop variable(s) of a while loop is modified and the loop does not have an early exit.")),l(j,"LoopExitsSometimes",new j("LoopExitsSometimes","A loop contains a return that is conditional."));let oe=j;const D=class D extends q{constructor(e,n){super(e);l(this,"description");this.description=n}};l(D,"AssignmentInBoolean",new D("AssignmentInBoolean","An assignment operator is used in a Boolean expression. This could be a typo or an indication of confusion about = and ==.")),l(D,"AssignmentInReturn",new D("AssignmentInReturn","A variable is assigned in a return statement.")),l(D,"AssignedNone",new D("AssignedNoReturn","A function or method that does not return a value is assigned to a variable, passed as an argument, or used in some way. Commonly seen with the print() function.")),l(D,"CompareBoolLiteral",new D("CompareBoolLiteral","A Boolean expression is compared to a Boolean literal. Although this is not an error, it may indicate a misconception about Boolean values.")),l(D,"DefinitionFollowedByReservedWord",new D("DefinitionFollowedByReservedWord","A definition keyword (def or class) is followed by a reserved word, suggesting the intention to define a function or class with the same name as a reserved word.")),l(D,"DoubleComparisonOperators",new D("DoubleComparisonOperators","Two comparison operators are used side by side. This may be due to an extra space e.g. <= is written as < =.")),l(D,"ForLoopIteratorModified",new D("ForLoopTargetModified","A for loop target variable is modified in the loop and the modified value is not used.")),l(D,"FunctionPrints",new D("FunctionPrints","A user-defined function contains print statements. This is not an issue unless AssignedNoReturn is also present and print is used in place of return statements.")),l(D,"InfiniteLoop",new D("InfiniteLoop","A while loop does not exit.")),l(D,"LoopReturn",new D("LoopEarlyExit","A return or break statement causes a loop to always exit on the first iteration.")),l(D,"LoopVarModifiedInChildLoop",new D("WhileLoopVarModifiedInChildLoop","A while loop variable is modified in a nested for or while loop.")),l(D,"LoopVarNotModified",new D("WhileLoopVarNotModified","None of the variables used in a while loop definition are modified in the body of the while loop. If the while loop contains a nested loop, only usages of the variable in the outer loop are checked.")),l(D,"NaturalLanguageBoolean",new D("NaturalLanguageBoolean",`A Boolean expression uses syntax that makes sense in spoken English but may produce unexpected results or even and error in Python. The most common form is checking if a particular expression is equal to one of a range of values using "or <non_boolean>" e.g., "day == 'sat' or 'sun'".`)),l(D,"OneLineConditional",new D("OneLineConditional","A conditional that could be re-written as one line. Although this is not an error, it may indicate a misconception about Boolean values.")),l(D,"OutOfPlaceBooleanOperator",new D("OutOfPlaceOperatorsInBoolean","A comparison or logical operator is used in an unexpected place in a conditional expression.")),l(D,"OverwrittenVariable",new D("VariableOverwrite","A variable's value is initialised or changed then overwritten without being used.")),l(D,"RedundantException",new D("RedundantException","A specific exception is caught then immediately raised. Suggests confusion about how to work with exceptions.")),l(D,"ReservedWordAssigned",new D("ReservedWordAssigned","A reserved word is followed by the assignment operator, suggesting an intention to create a variable with the same name as a reserved word.")),l(D,"ReturnInParentheses",new D("ReturnInParentheses","The return keyword is followed by a value or compound expression in parentheses. May suggest a belief that returned values must be encapsulated in parentheses.")),l(D,"SequentialIfs",new D("SequentialIfs","Multiple if statements appear in sequence with no other code between the if blocks. If statements that contain a return or break at the top level are not included. Depending on the contents of the boolean expressions and each block, it may indicate a misconception about how conditionals are evaluated.")),l(D,"SubscriptedNonSubscriptable",new D("SubscriptedNonSubscriptable","Square brackets follow a variable name that does not have a subscriptable type (i.e. is not a string, list, tuple, or dictionary)")),l(D,"TernaryReturnsBool",new D("TernaryReturnsBool","A ternary returns a boolean. Although this is not an error, it may indicate a misconception about Boolean values.")),l(D,"TypeErrorInvalid",new D("InvalidCalculation","A calculation that produces a TypeError e.g. string + int.")),l(D,"TypeUnnecessary",new D("UnnecessaryTypeConversion","A value that has a guaranteed data type is passed to a type conversion function that produces the same data type. Also captures strings converted to lists.")),l(D,"UndefinedVariable",new D("UndefinedVariable","A variable that was not declared is called. Depending on context, may be due to sloppiness (e.g. a typo) or may suggest misconception about variable scope, function parameters, or how to call functions.")),l(D,"UnexpectedColon",new D("UnexpectedColon","A colon is found where it is not expected, indicating either a typo or a misunderstanding of syntax.")),l(D,"UnknownFunction",new D("UnknownFunction","A function that is not defined in the file or built in to Python is called. Could be a typo or a misunderstanding about variables.")),l(D,"UnknownMethod",new D("UnknownMethod","An unknown method, or a method that is not valid is called on a value with known data type.")),l(D,"UnreachableExhaustiveConditional",new D("UnreachableCode.exhaustiveConditional","Code that is unreachable because it follows a conditional with an else branch in which all branches return.")),l(D,"UnreachableExit",new D("UnreachableCode.exitKeyword","Code that is unreachable because it follows a <code>return</code> or <code>break</code> statement. This might indicate a misconception about how those keywords affect the flow of control.")),l(D,"UnreachableInfiniteLoop",new D("UnreachableCode.infiniteLoop",'Code that is unreachable because it follows a loop created using "while True" that never exits.')),l(D,"UnusedReturn",new D("UnusedReturn","The result of a call to a function / method that returns a value is not used in some way.")),l(D,"UnusedValue",new D("UnusedValue","A value (either a single variable or a compound expression) is created but not assigned to a variable, passed as a function argument, or used in some other way.")),l(D,"UnusedVariable",new D("UnusedVariable","A variable is not used after initialisation. May be an oversight but could potentially indicate misconceptions about variables.")),l(D,"VariableWithSameNameAsFunction",new D("VariableWithSameNameAsFunction","A variable has the same name as a function.")),l(D,"WhileLoopVarAssignedIntLiteral",new D("WhileLoopVarAssignedIntLiteral","A while loop counter variable is assigned an int value rather than incremented or decremented. The variable is not modified elsewhere in the loop.")),l(D,"WrongArgNumber",new D("WrongArgNumber","A user-defined function is called with the wrong number of arguments.")),l(D,"WhileTrue",new D("WhileTrue","A while loop is defined to iterate forever. This is a valid approach but may be a contributor to misconceptions when combined with other symptoms."));let I=D;const H=class H extends q{constructor(e,n){super(e);l(this,"description");this.description=n}};l(H,"EqualityExpression",new H("EqualityExpression","An equality operator is used in a Boolean expression.")),l(H,"ValidAssignment",new H("ValidAssignment","A variable is assigned correctly")),l(H,"StandaloneBooleanVariable",new H("StandaloneBooleanVariable","A boolean variable is used as a complete term in a condition.")),l(H,"ReturnLast",new H("ReturnLast","A return statement is the last statement in its branch.")),l(H,"NewForLoopVar",new H("NewForLoopVar","A new variable is created in a for loop definition.")),l(H,"ValidFunctionCall",new H("ValidFunctionCall","A function is called with parentheses.")),l(H,"CounterLoop",new H("CounterLoop","A for loop that counts (uses range() or enumerate()).")),l(H,"ValidGlobalVariable",new H("ValidGlobalVariable","A variable in document scope is properly assigned")),l(H,"FunctionScopeVariable",new H("FunctionScopeVariable","A variable is defined in function scope")),l(H,"ForLoopTargetNotModified",new H("ForLoopTargetNotModified","A for loop target variable is called and not modified in the loop.")),l(H,"NonLiteralBooleanAssigned",new H("NonLiteralBooleanAssigned","A non-literal Boolean expression is assigned to a variable without a conditional.")),l(H,"NonLiteralBooleanReturned",new H("NonLiteralBooleanReturned","A non-literal Boolean expression is returned without a conditional.")),l(H,"UsedReturn",new H("UsedReturn","The value returned by a function call is used or assigned.")),l(H,"NoReturnStandaloneCall",new H("NoReturnStandaloneCall","A function that does not return is called as a standalone statement.")),l(H,"ReturnNoParentheses",new H("ReturnNoParentheses","A return value is not in parentheses.")),l(H,"IfElif",new H("IfElif","An if statement is followed by an elif or an else.")),l(H,"ParameterCalled",new H("ParameterCalled","An function parameter is called in the function before or without modification.")),l(H,"LoopExitsSometimes",new H("LoopExitsSometimes","A loop contains a return that is conditional.")),l(H,"WhileLoopVarModified",new H("WhileLoopVarModified","A while loop's loop variable is modified in the loop, allowing it to progress."));let k=H;const nn="userDefinedFunction",vc="userDefinedVariable",sn="builtInFunction",wi="valueReturned",Si="valueAssigned",Rc="True",bi="return",Ec="string",Uc="list",Gc="literal",Do="functionCall",Jc="variable",Ao="compoundTypeDefinition",Bo="compoundExpression",ko="booleanExpression",Ii="forLoopVariable",$c="forLoopTargetReplacesIterable",yi="assignment",Fi="same",Po="different",Gs="unknown",we="empty",Kc="orNonBoolean",Wc="andOr",qc="topLevel",jc="allBranchesOfExhaustiveConditional",Vo="functionArgument",Hc="calculation",zc="comparison";function X(g,i){this.entity=g,this.category=i}function Js(g){switch(g){case t.TrueType:case t.FalseType:return d.Bool;case t.NoneType:return d.None;case t.StrType:case t.IntType:case t.FloatType:case t.BoolType:case t.ListType:case t.SetType:case t.DictType:case t.TupleType:return d.Class;case t.Name:case t.Doc:case t.Sep:case t.End:return d.String;case t.IntLiteral:return d.Int;case t.FloatLiteral:return d.Float;case t.StringLiteral:return d.String;case t.ListDefinition:return d.List;case t.TupleDefinition:return d.Tuple;case t.SetDefinition:return d.Set;case t.DictDefinition:return d.Dict;case t.RandomModule:return d.Random;case t.MathModule:return d.Math;case t.StringModule:return d.StringModule;case t.ReModule:return d.Re;case t.Pattern:return d.Pattern;case t.Match:return d.Match;case t.Sys:return d.Sys;default:return d.Unknown}}function Dt(g){if(g.length===0)return d.Undefined;if(g.length===1)return g[0];{const i=new Set(g);if(i.size===1)return g[0];for(let e of i)if(e!==d.Int&&e!==d.Float&&e!==d.Number)return d.Unknown;return d.Number}}function $s(g){return new Set([d.String,d.List,d.Dict,d.Tuple,d.Unknown,d.NotParsed]).has(g)}function fe(g,i=!1){if(g.length===0)return"";let e=g[0].getTextValue();const n=i?g[0].getIndexOnLine():0;for(let s=0;s<n;s++)e=" "+e;for(let s=1;s<g.length;s++){let o=g[s].getDocumentStartIndex()-g[s-1].getDocumentEndIndex()-1;for(let a=g[s-1].getEndLineNumber();a<g[s].getStartLineNumber();a++)e+=`
`,o--;for(let a=0;a<o;a++)e+=" ";e+=g[s].getTextValue()}return e}function qn(g){const i=[];for(const e of g){const n=e.getExpressions();i.push(...n)}return i}function jn(g,i){for(let e of g)if(e.is(i))return!0;return!1}function At(g){return g.getExpressionsOfKind(t.ReturnKeyword).length>0||g.getExpressionsOfKind(t.BreakKeyword).length>0||g.getExpressionsOfKind(t.ExitFunction).length>0||g.getExpressionsOfKind(t.SysExit).length>0||g.getExpressionsOfKind(t.QuitFunction).length>0}function on(g,i){for(let e=0;e<g.length;e++)if(g[e].is(i))return e;return-1}function Qc(g){return new Set(["str","int","float","bool","str","list","set","dict"]).has(g)}function Bt(g){return g.isOneOf([t.UserDefinedFunctionCall,t.BuiltInFunctionCall,t.UserDefinedMethodCall,t.BuiltInMethodCall])&&g.getDataType()===d.None}function Ni(g,i,e){if(!Xc(i,e))return!1;let n=0,s=0;for(let o of g)o.is(i)?n++:o.is(e)&&s++;return n>0&&n===s}function Xc(g,i){return g===t.OpenParenthesis?i===t.CloseParenthesis:g===t.OpenBrace?i===t.CloseBrace:g===t.OpenSquareBracket?i===t.CloseSquareBracket:!1}function Lo(g){return g===t.OpenBrace||g===t.OpenParenthesis||g===t.OpenSquareBracket}function Zc(g){return g===t.CloseBrace||g===t.CloseParenthesis||g===t.CloseSquareBracket}function Yc(g){if(!Lo(g))throw new Error(`${g} is not a valid open bracket.`);return g===t.OpenBrace?t.CloseBrace:g===t.OpenParenthesis?t.CloseParenthesis:t.CloseSquareBracket}const f=(g,i)=>({entity:g,category:i}),Xe=g=>{switch(g){case"class":return f(t.ClassDefinition,c.BlockDefinitions);case"def":return f(t.FunctionDefinition,c.BlockDefinitions);case"elif":return f(t.ElifDefinition,c.BlockDefinitions);case"else":return f(t.ElseDefinition,c.BlockDefinitions);case"except":return f(t.ExceptDefinition,c.BlockDefinitions);case"finally":return f(t.FinallyDefinition,c.BlockDefinitions);case"for":return f(t.ForDefinition,c.BlockDefinitions);case"if":return f(t.IfDefinition,c.BlockDefinitions);case"lambda":return f(t.LambdaDefinition,c.BlockDefinitions);case"try":return f(t.TryDefinition,c.BlockDefinitions);case"while":return f(t.WhileDefinition,c.BlockDefinitions);case"with":return f(t.WithKeyword,c.BlockDefinitions);case"and":return f(t.AndOperator,c.LogicalOperators);case"not":return f(t.NotOperator,c.LogicalOperators);case"or":return f(t.OrOperator,c.LogicalOperators);case"False":return f(t.FalseType,c.Types);case"None":return f(t.NoneType,c.Types);case"True":return f(t.TrueType,c.Types);case"as":return f(t.AsKeyword,c.OtherKeywords);case"global":return f(t.GlobalKeyword,c.OtherKeywords);case"assert":return f(t.AssertKeyword,c.OtherKeywords);case"break":return f(t.BreakKeyword,c.OtherKeywords);case"continue":return f(t.ContinueKeyword,c.OtherKeywords);case"del":return f(t.DelKeyword,c.OtherKeywords);case"from":return f(t.FromKeyword,c.OtherKeywords);case"import":return f(t.ImportKeyword,c.OtherKeywords);case"in":return f(t.InKeyword,c.ComparisonOperators);case"is":return f(t.IsKeyword,c.ComparisonOperators);case"pass":return f(t.PassKeyword,c.OtherKeywords);case"raise":return f(t.RaiseKeyword,c.OtherKeywords);case"return":return f(t.ReturnKeyword,c.OtherKeywords);case"yield":return f(t.YieldKeyword,c.OtherKeywords);case"r":return f(t.R,c.OtherKeywords);case"f":return f(t.F,c.OtherKeywords);case"+":return f(t.AddOperator,c.MathsOperators);case"-":return f(t.SubtractOperator,c.MathsOperators);case"*":return f(t.MultiplyOperator,c.MathsOperators);case"/":return f(t.DivideOperator,c.MathsOperators);case"%":return f(t.ModulusOperator,c.MathsOperators);case"**":return f(t.ExponentOperator,c.MathsOperators);case"//":return f(t.IntDivideOperator,c.MathsOperators);case"=":return f(t.AssignmentOperator,c.MathsOperators);case"+=":return f(t.IncrementOperator,c.MathsOperators);case"-=":return f(t.DecrementOperator,c.MathsOperators);case"*=":return f(t.MultiplyAssignOperator,c.MathsOperators);case"/=":return f(t.DivideAssignOperator,c.MathsOperators);case"%=":return f(t.RemainderAssignOperator,c.MathsOperators);case"//=":return f(t.IntDivideAssignOperator,c.MathsOperators);case"**=":return f(t.ExponentAssignOperator,c.MathsOperators);case"==":return f(t.EqualOperator,c.ComparisonOperators);case"!=":return f(t.NotEqualOperator,c.ComparisonOperators);case">":return f(t.GreaterThanOperator,c.ComparisonOperators);case"<":return f(t.LessThanOperator,c.ComparisonOperators);case">=":return f(t.GreaterThanOrEqualOperator,c.ComparisonOperators);case"<=":return f(t.LessThanOrEqualOperator,c.ComparisonOperators);case"->":return f(t.TypeHintReturn,c.TypeHint);case"@":return f(t.Decorator,c.SyntacticSugar);case"abs":return f(t.AbsFunction,c.BuiltInFunctions);case"all":return f(t.AllFunction,c.BuiltInFunctions);case"any":return f(t.AnyFunction,c.BuiltInFunctions);case"ascii":return f(t.AsciiFunction,c.BuiltInFunctions);case"bin":return f(t.BinFunction,c.BuiltInFunctions);case"bool":return f(t.BoolFunction,c.BuiltInFunctions);case"callable":return f(t.CallableFunction,c.BuiltInFunctions);case"chr":return f(t.ChrFunction,c.BuiltInFunctions);case"dict":return f(t.DictDefinition,c.BuiltInFunctions);case"divmod":return f(t.DivModFunction,c.BuiltInFunctions);case"enumerate":return f(t.EnumerateFunction,c.BuiltInFunctions);case"eval":return f(t.EvalFunction,c.BuiltInFunctions);case"exec":return f(t.ExecFunction,c.BuiltInFunctions);case"exit":return f(t.ExitFunction,c.BuiltInFunctions);case"filter":return f(t.FilterFunction,c.BuiltInFunctions);case"float":return f(t.FloatFunction,c.BuiltInFunctions);case"getattr":return f(t.GetAttrFunction,c.BuiltInFunctions);case"globals":return f(t.GlobalsFunction,c.BuiltInFunctions);case"hasattr":return f(t.HasAttrFunction,c.BuiltInFunctions);case"input":return f(t.InputFunction,c.BuiltInFunctions);case"int":return f(t.IntFunction,c.BuiltInFunctions);case"isinstance":return f(t.IsInstanceFunction,c.BuiltInFunctions);case"len":return f(t.LenFunction,c.BuiltInFunctions);case"list":return f(t.ListFunction,c.BuiltInFunctions);case"map":return f(t.MapFunction,c.BuiltInFunctions);case"max":return f(t.MaxFunction,c.BuiltInFunctions);case"min":return f(t.MinFunction,c.BuiltInFunctions);case"open":return f(t.OpenFunction,c.BuiltInFunctions);case"ord":return f(t.OrdFunction,c.BuiltInFunctions);case"pow":return f(t.PowFunction,c.BuiltInFunctions);case"print":return f(t.PrintFunction,c.BuiltInFunctions);case"quit":return f(t.QuitFunction,c.BuiltInFunctions);case"range":return f(t.RangeFunction,c.BuiltInFunctions);case"reversed":return f(t.ReversedFunction,c.BuiltInFunctions);case"round":return f(t.RoundFunction,c.BuiltInFunctions);case"set":return f(t.SetFunction,c.BuiltInFunctions);case"sorted":return f(t.SortedFunction,c.BuiltInFunctions);case"str":return f(t.StrFunction,c.BuiltInFunctions);case"sum":return f(t.SumFunction,c.BuiltInFunctions);case"tuple":return f(t.TupleFunction,c.BuiltInFunctions);case"type":return f(t.TypeFunction,c.BuiltInFunctions);case"zip":return f(t.ZipFunction,c.BuiltInFunctions);case"__main__":return f(t.Main,c.MagicMethods);case"__cmp__":return f(t.Cmp,c.MagicMethods);case"__eq__":return f(t.Eq,c.MagicMethods);case"__ne__":return f(t.Ne,c.MagicMethods);case"__lt__":return f(t.Lt,c.MagicMethods);case"__gt__":return f(t.Gt,c.MagicMethods);case"__le__":return f(t.Le,c.MagicMethods);case"__ge__":return f(t.Ge,c.MagicMethods);case"__str__":return f(t.Str,c.MagicMethods);case"__getattr__":return f(t.GetAttrVariable,c.MagicMethods);case"__setattr__":return f(t.SetAttrVariable,c.MagicMethods);case"__contains__":return f(t.SpecialContains,c.MagicMethods);case"__len__":return f(t.SpecialLen,c.MagicMethods);case"__name__":return f(t.Name,c.SpecialVariables);case"__self__":return f(t.Self,c.SpecialVariables);case"__doc__":return f(t.Doc,c.SpecialVariables);case"__class__":return f(t.ClassVariable,c.SpecialVariables);case"sep":return f(t.Sep,c.SpecialVariables);case"end":return f(t.End,c.SpecialVariables);case"ArtithmeticError":return f(t.ExceptionName,c.BuiltInExceptions);case"AssertionError":return f(t.ExceptionName,c.BuiltInExceptions);case"AttributeError":return f(t.ExceptionName,c.BuiltInExceptions);case"BlockingIOError":return f(t.ExceptionName,c.BuiltInExceptions);case"BrokenPipeError":return f(t.ExceptionName,c.BuiltInExceptions);case"BufferError":return f(t.ExceptionName,c.BuiltInExceptions);case"ChildProcessError":return f(t.ExceptionName,c.BuiltInExceptions);case"ConnectionAbortedError":return f(t.ExceptionName,c.BuiltInExceptions);case"ConnectionError":return f(t.ExceptionName,c.BuiltInExceptions);case"ConnectionRefusedError":return f(t.ExceptionName,c.BuiltInExceptions);case"ConnectionResetError":return f(t.ExceptionName,c.BuiltInExceptions);case"Exception":return f(t.ExceptionName,c.BuiltInExceptions);case"EOFError":return f(t.ExceptionName,c.BuiltInExceptions);case"EnvironmentError":return f(t.ExceptionName,c.BuiltInExceptions);case"FileExistsError":return f(t.ExceptionName,c.BuiltInExceptions);case"FileNotFoundError":return f(t.ExceptionName,c.BuiltInExceptions);case"FloatingPointError":return f(t.ExceptionName,c.BuiltInExceptions);case"GeneratorExit":return f(t.ExceptionName,c.BuiltInExceptions);case"ImportError":return f(t.ExceptionName,c.BuiltInExceptions);case"IndentationError":return f(t.ExceptionName,c.BuiltInExceptions);case"IndexError":return f(t.ExceptionName,c.BuiltInExceptions);case"InterruptedError":return f(t.ExceptionName,c.BuiltInExceptions);case"IOError":return f(t.ExceptionName,c.BuiltInExceptions);case"IsADirectoryError":return f(t.ExceptionName,c.BuiltInExceptions);case"KeyError":return f(t.ExceptionName,c.BuiltInExceptions);case"KeyboardInterrupt":return f(t.ExceptionName,c.BuiltInExceptions);case"LookupError":return f(t.ExceptionName,c.BuiltInExceptions);case"MemoryError":return f(t.ExceptionName,c.BuiltInExceptions);case"ModuleNotFoundError":return f(t.ExceptionName,c.BuiltInExceptions);case"NameError":return f(t.ExceptionName,c.BuiltInExceptions);case"NotADirectoryError":return f(t.ExceptionName,c.BuiltInExceptions);case"NotImplementedError":return f(t.ExceptionName,c.BuiltInExceptions);case"OSError":return f(t.ExceptionName,c.BuiltInExceptions);case"OverflowError":return f(t.ExceptionName,c.BuiltInExceptions);case"PermissionError":return f(t.ExceptionName,c.BuiltInExceptions);case"ProcessLookupError":return f(t.ExceptionName,c.BuiltInExceptions);case"RecursionError":return f(t.ExceptionName,c.BuiltInExceptions);case"ReferenceError":return f(t.ExceptionName,c.BuiltInExceptions);case"RuntimeError":return f(t.ExceptionName,c.BuiltInExceptions);case"StopIteration":return f(t.ExceptionName,c.BuiltInExceptions);case"SyntaxError":return f(t.ExceptionName,c.BuiltInExceptions);case"TabError":return f(t.ExceptionName,c.BuiltInExceptions);case"TimeoutError":return f(t.ExceptionName,c.BuiltInExceptions);case"SystemError":return f(t.ExceptionName,c.BuiltInExceptions);case"SystemExit":return f(t.ExceptionName,c.BuiltInExceptions);case"TypeError":return f(t.ExceptionName,c.BuiltInExceptions);case"UnboundLocalError":return f(t.ExceptionName,c.BuiltInExceptions);case"UnicodeError":return f(t.ExceptionName,c.BuiltInExceptions);case"UnicodeEncodeError":return f(t.ExceptionName,c.BuiltInExceptions);case"UnicodeDecodeError":return f(t.ExceptionName,c.BuiltInExceptions);case"UnicodeTranslateError":return f(t.ExceptionName,c.BuiltInExceptions);case"ValueError":return f(t.ExceptionName,c.BuiltInExceptions);case"Warning":return f(t.ExceptionName,c.BuiltInExceptions);case"ZeroDivisionError":return f(t.ExceptionName,c.BuiltInExceptions);case"capitalize":return f(t.Capitalize,c.BuiltInMethods);case"casefold":return f(t.Casefold,c.BuiltInMethods);case"center":return f(t.Center,c.BuiltInMethods);case"count":return f(t.Count,c.BuiltInMethods);case"encode":return f(t.Encode,c.BuiltInMethods);case"endswith":return f(t.EndsWith,c.BuiltInMethods);case"expandtabs":return f(t.ExpandTabs,c.BuiltInMethods);case"find":return f(t.Find,c.BuiltInMethods);case"format":return f(t.Format,c.BuiltInMethods);case"format_map":return f(t.FormatMap,c.BuiltInMethods);case"index":return f(t.Index,c.BuiltInMethods);case"isalnum":return f(t.IsAlnum,c.BuiltInMethods);case"isalpha":return f(t.IsAlpha,c.BuiltInMethods);case"isascii":return f(t.IsAscii,c.BuiltInMethods);case"isdecimal":return f(t.IsDecimal,c.BuiltInMethods);case"isdigit":return f(t.IsDigit,c.BuiltInMethods);case"isidentifier":return f(t.IsIdentifier,c.BuiltInMethods);case"islower":return f(t.IsLower,c.BuiltInMethods);case"isnumeric":return f(t.IsNumeric,c.BuiltInMethods);case"isprintable":return f(t.IsPrintable,c.BuiltInMethods);case"isspace":return f(t.IsSpace,c.BuiltInMethods);case"istitle":return f(t.IsTitle,c.BuiltInMethods);case"isupper":return f(t.IsUpper,c.BuiltInMethods);case"join":return f(t.Join,c.BuiltInMethods);case"ljust":return f(t.LJust,c.BuiltInMethods);case"lower":return f(t.Lower,c.BuiltInMethods);case"lstrip":return f(t.LStrip,c.BuiltInMethods);case"maketrans":return f(t.MakeTrans,c.BuiltInMethods);case"partition":return f(t.Partition,c.BuiltInMethods);case"replace":return f(t.Replace,c.BuiltInMethods);case"rfind":return f(t.RFind,c.BuiltInMethods);case"rindex":return f(t.RIndex,c.BuiltInMethods);case"rjust":return f(t.RJust,c.BuiltInMethods);case"rpartition":return f(t.RPartition,c.BuiltInMethods);case"rsplit":return f(t.RSplit,c.BuiltInMethods);case"rstrip":return f(t.RStrip,c.BuiltInMethods);case"split":return f(t.Split,c.BuiltInMethods);case"splitlines":return f(t.SplitLines,c.BuiltInMethods);case"startswith":return f(t.StartsWith,c.BuiltInMethods);case"strip":return f(t.Strip,c.BuiltInMethods);case"swapcase":return f(t.SwapCase,c.BuiltInMethods);case"title":return f(t.Title,c.BuiltInMethods);case"translate":return f(t.Translate,c.BuiltInMethods);case"upper":return f(t.Upper,c.BuiltInMethods);case"zfill":return f(t.ZFill,c.BuiltInMethods);case"append":return f(t.Append,c.BuiltInMethods);case"clear":return f(t.Clear,c.BuiltInMethods);case"copy":return f(t.Copy,c.BuiltInMethods);case"extend":return f(t.Extend,c.BuiltInMethods);case"insert":return f(t.Insert,c.BuiltInMethods);case"pop":return f(t.Pop,c.BuiltInMethods);case"remove":return f(t.Remove,c.BuiltInMethods);case"reverse":return f(t.Reverse,c.BuiltInMethods);case"sort":return f(t.Sort,c.BuiltInMethods);case"fromkeys":return f(t.FromKeys,c.BuiltInMethods);case"get":return f(t.Get,c.BuiltInMethods);case"items":return f(t.Items,c.BuiltInMethods);case"keys":return f(t.Keys,c.BuiltInMethods);case"popitem":return f(t.PopItem,c.BuiltInMethods);case"setdefault":return f(t.SetDefault,c.BuiltInMethods);case"update":return f(t.Update,c.BuiltInMethods);case"values":return f(t.Values,c.BuiltInMethods);case"add":return f(t.Add,c.BuiltInMethods);case"difference":return f(t.Difference,c.BuiltInMethods);case"difference_update":return f(t.DifferenceUpdate,c.BuiltInMethods);case"discard":return f(t.Discard,c.BuiltInMethods);case"intersection":return f(t.Intersection,c.BuiltInMethods);case"intersection_update":return f(t.IntersectionUpdate,c.BuiltInMethods);case"isdisjoint":return f(t.IsDisjoint,c.BuiltInMethods);case"issubset":return f(t.IsSubset,c.BuiltInMethods);case"issuperset":return f(t.IsSuperset,c.BuiltInMethods);case"symmetric_difference":return f(t.SymmetricDifference,c.BuiltInMethods);case"symmetric_difference_update":return f(t.SymmetricDifferenceUpdate,c.BuiltInMethods);case"union":return f(t.Union,c.BuiltInMethods);case"close":return f(t.Close,c.BuiltInMethods);case"detach":return f(t.Detach,c.BuiltInMethods);case"fileno":return f(t.FileNo,c.BuiltInMethods);case"flush":return f(t.Flush,c.BuiltInMethods);case"isatty":return f(t.IsAtty,c.BuiltInMethods);case"read":return f(t.Read,c.BuiltInMethods);case"readable":return f(t.Readable,c.BuiltInMethods);case"readline":return f(t.ReadLine,c.BuiltInMethods);case"readlines":return f(t.ReadLines,c.BuiltInMethods);case"seek":return f(t.Seek,c.BuiltInMethods);case"seekable":return f(t.Seekable,c.BuiltInMethods);case"tell":return f(t.Tell,c.BuiltInMethods);case"truncate":return f(t.Truncate,c.BuiltInMethods);case"writable":return f(t.Writable,c.BuiltInMethods);case"write":return f(t.Write,c.BuiltInMethods);case"writelines":return f(t.WriteLines,c.BuiltInMethods);case"(":return f(t.OpenParenthesis,c.Other);case")":return f(t.CloseParenthesis,c.Other);case"[":return f(t.OpenSquareBracket,c.Other);case"]":return f(t.CloseSquareBracket,c.Other);case"{":return f(t.OpenBrace,c.Other);case"}":return f(t.CloseBrace,c.Other);case",":return f(t.Comma,c.Other);case":":return f(t.Colon,c.Other);case".":return f(t.Dot,c.Other);case"\\":return f(t.ContinuationLine,c.Other);case";":return f(t.Separator,c.Other);case"'":return f(t.SingleQuote,c.Other);case'"':return f(t.DoubleQuote,c.Other);case"random":return f(t.RandomModule,c.BuiltInModules);case"math":return f(t.MathModule,c.BuiltInModules);case"string":return f(t.StringModule,c.BuiltInModules);case"re":return f(t.ReModule,c.BuiltInModules);case"sys":return f(t.Sys,c.BuiltInModules);case"seed":return f(t.Seed,c.ModuleFunctions);case"getstate":return f(t.GetState,c.ModuleFunctions);case"setstate":return f(t.SetState,c.ModuleFunctions);case"getrandbits":return f(t.GetRandBits,c.ModuleFunctions);case"randrange":return f(t.RandRange,c.ModuleFunctions);case"randint":return f(t.RandInt,c.ModuleFunctions);case"choice":return f(t.Choice,c.ModuleFunctions);case"choices":return f(t.Choices,c.ModuleFunctions);case"shuffle":return f(t.Shuffle,c.ModuleFunctions);case"sample":return f(t.Sample,c.ModuleFunctions);case"uniform":return f(t.Uniform,c.ModuleFunctions);case"triangular":return f(t.Triangular,c.ModuleFunctions);case"betavariate":return f(t.BetaVariate,c.ModuleFunctions);case"expovariate":return f(t.ExpoVariate,c.ModuleFunctions);case"gammavariate":return f(t.GammaVariate,c.ModuleFunctions);case"gauss":return f(t.Gauss,c.ModuleFunctions);case"lognormvariate":return f(t.LogNormVariate,c.ModuleFunctions);case"normalvariate":return f(t.NormalVariate,c.ModuleFunctions);case"vonmisesvariate":return f(t.VonMisesVariate,c.ModuleFunctions);case"paretovariate":return f(t.ParetoVariate,c.ModuleFunctions);case"weibullvariate":return f(t.WeibullVariate,c.ModuleFunctions);case"acos":return f(t.Acos,c.ModuleFunctions);case"acosh":return f(t.Acosh,c.ModuleFunctions);case"asin":return f(t.Asin,c.ModuleFunctions);case"asinh":return f(t.Asinh,c.ModuleFunctions);case"atan":return f(t.Atan,c.ModuleFunctions);case"atan2":return f(t.Atan2,c.ModuleFunctions);case"atanh":return f(t.Atanh,c.ModuleFunctions);case"ceil":return f(t.Ceil,c.ModuleFunctions);case"comb":return f(t.Comb,c.ModuleFunctions);case"copysign":return f(t.Copysign,c.ModuleFunctions);case"cos":return f(t.Cos,c.ModuleFunctions);case"cosh":return f(t.Cosh,c.ModuleFunctions);case"degrees":return f(t.Degrees,c.ModuleFunctions);case"dist":return f(t.Dist,c.ModuleFunctions);case"erf":return f(t.Erf,c.ModuleFunctions);case"erfc":return f(t.Erfc,c.ModuleFunctions);case"exp":return f(t.Exp,c.ModuleFunctions);case"expm1":return f(t.Expm1,c.ModuleFunctions);case"fabs":return f(t.Fabs,c.ModuleFunctions);case"factorial":return f(t.Factorial,c.ModuleFunctions);case"floor":return f(t.Floor,c.ModuleFunctions);case"fmod":return f(t.Fmod,c.ModuleFunctions);case"frexp":return f(t.Frexp,c.ModuleFunctions);case"fsum":return f(t.Fsum,c.ModuleFunctions);case"gamma":return f(t.Gamma,c.ModuleFunctions);case"gcd":return f(t.Gcd,c.ModuleFunctions);case"hypot":return f(t.Hypot,c.ModuleFunctions);case"isclose":return f(t.IsClose,c.ModuleFunctions);case"isfinite":return f(t.IsFinite,c.ModuleFunctions);case"isinf":return f(t.IsInf,c.ModuleFunctions);case"isnan":return f(t.IsNaN,c.ModuleFunctions);case"isqrt":return f(t.ISqrt,c.ModuleFunctions);case"ldexp":return f(t.Ldexp,c.ModuleFunctions);case"lgamma":return f(t.LGamma,c.ModuleFunctions);case"log":return f(t.Log,c.ModuleFunctions);case"log10":return f(t.Log10,c.ModuleFunctions);case"log1p":return f(t.Log1P,c.ModuleFunctions);case"log2":return f(t.Log2,c.ModuleFunctions);case"perm":return f(t.Perm,c.ModuleFunctions);case"pow":return f(t.Pow,c.ModuleFunctions);case"prod":return f(t.Prod,c.ModuleFunctions);case"radians":return f(t.Radians,c.ModuleFunctions);case"remainder":return f(t.Remainder,c.ModuleFunctions);case"sin":return f(t.Sin,c.ModuleFunctions);case"sinh":return f(t.Sinh,c.ModuleFunctions);case"sqrt":return f(t.Sqrt,c.ModuleFunctions);case"tan":return f(t.Tan,c.ModuleFunctions);case"tanh":return f(t.Tanh,c.ModuleFunctions);case"trun":return f(t.Trunc,c.ModuleFunctions);case"e":return f(t.E,c.ModuleProperties);case"inf":return f(t.Inf,c.ModuleProperties);case"nan":return f(t.Nan,c.ModuleProperties);case"pi":return f(t.Pi,c.ModuleProperties);case"tau":return f(t.Tau,c.ModuleProperties);case"ascii_letters":return f(t.AsciiLetters,c.ModuleProperties);case"ascii_lowercase":return f(t.AsciiLowercase,c.ModuleProperties);case"ascii_uppercase":return f(t.AsciiUppercase,c.ModuleProperties);case"digits":return f(t.Digits,c.ModuleProperties);case"hexdigits":return f(t.Hexdigits,c.ModuleProperties);case"octdigits":return f(t.Octdigits,c.ModuleProperties);case"punctuation":return f(t.Punctuation,c.ModuleProperties);case"printable":return f(t.Printable,c.ModuleProperties);case"whitespace":return f(t.Whitespace,c.ModuleProperties);case"Formatter":return f(t.Formatter,c.ModuleFunctions);case"Template":return f(t.Template,c.ModuleFunctions);case"capwords":return f(t.Capwords,c.ModuleFunctions);case"Pattern":return f(t.Pattern,c.Types);case"Match":return f(t.Match,c.Types);case"A":return f(t.ReA,c.ModuleProperties);case"ASCII":return f(t.ReASCII,c.ModuleProperties);case"DEBUG":return f(t.ReDebug,c.ModuleProperties);case"I":return f(t.ReI,c.ModuleProperties);case"IGNORECASE":return f(t.ReIGNORECASE,c.ModuleProperties);case"L":return f(t.ReL,c.ModuleProperties);case"LOCALE":return f(t.ReLOCALE,c.ModuleProperties);case"M":return f(t.ReM,c.ModuleProperties);case"MULTILINE":return f(t.ReMULTILINE,c.ModuleProperties);case"S":return f(t.ReS,c.ModuleProperties);case"DOTALL":return f(t.ReDOTALL,c.ModuleProperties);case"X":return f(t.ReX,c.ModuleProperties);case"VERBOSE":return f(t.ReVERBOSE,c.ModuleProperties);case"compile":return f(t.Compile,c.ModuleFunctions);case"search":return f(t.Search,c.ModuleFunctions);case"match":return f(t.Match,c.ModuleFunctions);case"fullmatch":return f(t.FullMatch,c.ModuleFunctions);case"findall":return f(t.FindAll,c.ModuleFunctions);case"finditer":return f(t.FindIter,c.ModuleFunctions);case"sub":return f(t.Sub,c.ModuleFunctions);case"subn":return f(t.SubN,c.ModuleFunctions);case"escape":return f(t.Escape,c.ModuleFunctions);case"purge":return f(t.Purge,c.ModuleFunctions);case"addaudithook":return f(t.AddAuditHook,c.ModuleFunctions);case"audit":return f(t.Audit,c.ModuleFunctions);case"call_tracing":return f(t.CallTracing,c.ModuleFunctions);case"_clear_type_cache":return f(t.ClearTypeCache,c.ModuleFunctions);case"_current_frames":return f(t.CurrentFrames,c.ModuleFunctions);case"_current_exceptions":return f(t.CurrentExceptions,c.ModuleFunctions);case"breakpointhook":return f(t.BreakpointHook,c.ModuleFunctions);case"_debugmallocstats":return f(t.DebugMallocStats,c.ModuleFunctions);case"displayhook":return f(t.DisplayHook,c.ModuleFunctions);case"excepthook":return f(t.ExceptHook,c.ModuleFunctions);case"exc_info":return f(t.ExcInfo,c.ModuleFunctions);case"getallocatedblocks":return f(t.GetAllocatedBlocks,c.ModuleFunctions);case"getandroidapilevel":return f(t.GetAndroidApiLevel,c.ModuleFunctions);case"getdefaultencoding":return f(t.GetDefaultEncoding,c.ModuleFunctions);case"getdlopenflags":return f(t.GetDLOpenFlags,c.ModuleFunctions);case"getfilesystemencoding":return f(t.GetFileSystemEncoding,c.ModuleFunctions);case"getfilesystemencodeerrors":return f(t.GetFileSystemEncodeErrors,c.ModuleFunctions);case"getrefcount":return f(t.GetRefCount,c.ModuleFunctions);case"getrecursionlimit":return f(t.GetRecursionLimit,c.ModuleFunctions);case"getsizeof":return f(t.GetSizeOf,c.ModuleFunctions);case"getswitchinterval":return f(t.GetSwitchInterval,c.ModuleFunctions);case"_getframe":return f(t.GetFrame,c.ModuleFunctions);case"getprofile":return f(t.GetProfile,c.ModuleFunctions);case"gettrace":return f(t.GetTrace,c.ModuleFunctions);case"getwindowsversion":return f(t.GetWindowsVersion,c.ModuleFunctions);case"get_asyncgen_hooks":return f(t.GetAsyncGenHooks,c.ModuleFunctions);case"get_coroutine_origin_tracking_depth":return f(t.GetCoroutineOriginTrackingDepth,c.ModuleFunctions);case"intern":return f(t.Intern,c.ModuleFunctions);case"is_finalizing":return f(t.IsFinalizing,c.ModuleFunctions);case"setdlopenflags":return f(t.SetDLOpenFlags,c.ModuleFunctions);case"setprofile":return f(t.SetProfile,c.ModuleFunctions);case"setrecursionlimit":return f(t.SetRecursionLimit,c.ModuleFunctions);case"setswitchinterval":return f(t.SetSwitchInterval,c.ModuleFunctions);case"settrace":return f(t.SetTrace,c.ModuleFunctions);case"set_asyncgen_hooks":return f(t.SetAsyncgenHooks,c.ModuleFunctions);case"_enablelegacywindowsfsencoding":return f(t.EnableLegacyWindowsFSEncoding,c.ModuleFunctions);case"abiflags":return f(t.ABIFlags,c.ModuleProperties);case"argv":return f(t.Argv,c.ModuleProperties);case"base_exec_prefix":return f(t.BaseExecPrefix,c.ModuleProperties);case"base_prefix":return f(t.BasePrefix,c.ModuleProperties);case"byte_order":return f(t.ByteOrder,c.ModuleProperties);case"built_in_module_names":return f(t.BuiltInModuleNames,c.ModuleProperties);case"copyright":return f(t.Copyright,c.ModuleProperties);case"dllhandle":return f(t.DllHandle,c.ModuleProperties);case"dont_write_bytecode":return f(t.DontWriteBytecode,c.ModuleProperties);case"pycache_prefix":return f(t.PycachePrefix,c.ModuleProperties);case"exec_prefix":return f(t.ExecPrefix,c.ModuleProperties);case"executable":return f(t.Executable,c.ModuleProperties);case"flags":return f(t.Flags,c.ModuleProperties);case"float_info":return f(t.FloatInfo,c.ModuleProperties);case"float_repr_style":return f(t.FloatReprStyle,c.ModuleProperties);case"hash_info":return f(t.HashInfo,c.ModuleProperties);case"hexversion":return f(t.HexVersion,c.ModuleProperties);case"implementation":return f(t.Implementation,c.ModuleProperties);case"int_info":return f(t.IntInfo,c.ModuleProperties);case"last_type":return f(t.LastType,c.ModuleProperties);case"last_value":return f(t.LastValue,c.ModuleProperties);case"last_traceback":return f(t.LastTraceback,c.ModuleProperties);case"maxsize":return f(t.MaxSize,c.ModuleProperties);case"maxunicode":return f(t.MaxUnicode,c.ModuleProperties);case"meta_path":return f(t.MetaPath,c.ModuleProperties);case"modules":return f(t.Modules,c.ModuleProperties);case"orig_argv":return f(t.OrigArgv,c.ModuleProperties);case"path":return f(t.Path,c.ModuleProperties);case"path_hooks":return f(t.PathHooks,c.ModuleProperties);case"path_importer_cache":return f(t.PathImporterCache,c.ModuleProperties);case"platform":return f(t.Platform,c.ModuleProperties);case"prefix":return f(t.Prefix,c.ModuleProperties);case"ps1":return f(t.PS1,c.ModuleProperties);case"ps2":return f(t.PS2,c.ModuleProperties);case"stdin":return f(t.StdIn,c.ModuleProperties);case"stdout":return f(t.StdOut,c.ModuleProperties);case"stderr":return f(t.StdErr,c.ModuleProperties);case"stdlib_module_names":return f(t.StdLibModuleNames,c.ModuleProperties);case"thread_info":return f(t.ThreadInfo,c.ModuleProperties);case"tracebacklimit":return f(t.TracebackLimit,c.ModuleProperties);case"version":return f(t.Version,c.ModuleProperties);case"api_version":return f(t.ApiVersion,c.ModuleProperties);case"version_info":return f(t.VersionInfo,c.ModuleProperties);case"warnoptions":return f(t.WarnOptions,c.ModuleProperties);case"winver":return f(t.WinVer,c.ModuleProperties);case"_xoptions":return f(t.XOptions,c.ModuleProperties);default:return f(t.Unknown,c.Unknown)}},vo=g=>{switch(g){case"str":return f(t.StrType,c.Types);case"int":return f(t.IntType,c.Types);case"float":return f(t.FloatType,c.Types);case"bool":return f(t.BoolType,c.Types);case"list":return f(t.ListType,c.Types);case"set":return f(t.SetType,c.Types);case"dict":return f(t.DictType,c.Types);case"tuple":return f(t.TupleType,c.Types);default:return f(t.Unknown,c.Unknown)}},kt=new Map([[t.AbsFunction,d.Number],[t.AllFunction,d.Bool],[t.AnyFunction,d.Bool],[t.AsciiFunction,d.String],[t.AssertFunction,d.None],[t.BinFunction,d.String],[t.BoolFunction,d.Bool],[t.CallableFunction,d.Bool],[t.ChrFunction,d.String],[t.DictFunction,d.Dict],[t.DivModFunction,d.Tuple],[t.EnumerateFunction,d.Tuple],[t.EvalFunction,d.Unknown],[t.ExecFunction,d.None],[t.ExitFunction,d.None],[t.FilterFunction,d.Unknown],[t.FloatFunction,d.Float],[t.GetAttrFunction,d.Unknown],[t.GlobalsFunction,d.Dict],[t.HasAttrFunction,d.Bool],[t.InputFunction,d.String],[t.IntFunction,d.Int],[t.IsInstanceFunction,d.Bool],[t.LenFunction,d.Int],[t.ListFunction,d.List],[t.MapFunction,d.Unknown],[t.MaxFunction,d.Number],[t.MinFunction,d.Number],[t.OpenFunction,d.File],[t.OrdFunction,d.Int],[t.PowFunction,d.Number],[t.PrintFunction,d.None],[t.QuitFunction,d.None],[t.RangeFunction,d.Unknown],[t.ReversedFunction,d.Unknown],[t.RoundFunction,d.Float],[t.SetFunction,d.Set],[t.SortedFunction,d.List],[t.StrFunction,d.String],[t.SumFunction,d.Number],[t.TupleFunction,d.Tuple],[t.TypeFunction,d.Class],[t.Capitalize,d.String],[t.Casefold,d.String],[t.Center,d.String],[t.Count,d.Int],[t.Encode,d.String],[t.EndsWith,d.Bool],[t.ExpandTabs,d.String],[t.Find,d.Int],[t.Format,d.String],[t.FormatFunction,d.String],[t.Index,d.Int],[t.IsAlnum,d.Bool],[t.IsAlpha,d.Bool],[t.IsAscii,d.Bool],[t.IsDecimal,d.Bool],[t.IsDigit,d.Bool],[t.IsIdentifier,d.Bool],[t.IsLower,d.Bool],[t.IsNumeric,d.Bool],[t.IsPrintable,d.Bool],[t.IsSpace,d.Bool],[t.IsTitle,d.Bool],[t.IsUpper,d.Bool],[t.Join,d.String],[t.LJust,d.String],[t.Lower,d.String],[t.LStrip,d.String],[t.MakeTrans,d.Dict],[t.Partition,d.Tuple],[t.Replace,d.String],[t.RFind,d.Int],[t.RIndex,d.Int],[t.RJust,d.String],[t.RPartition,d.Tuple],[t.RSplit,d.List],[t.RStrip,d.String],[t.Split,d.List],[t.SplitLines,d.List],[t.StartsWith,d.Bool],[t.Strip,d.String],[t.SwapCase,d.String],[t.Title,d.String],[t.Translate,d.String],[t.Upper,d.String],[t.ZFill,d.String],[t.Append,d.None],[t.Clear,d.None],[t.Copy,d.Unknown],[t.Extend,d.None],[t.Insert,d.None],[t.Pop,d.Unknown],[t.Remove,d.None],[t.Reverse,d.None],[t.Sort,d.None],[t.FromKeys,d.Dict],[t.Get,d.Unknown],[t.Items,d.List],[t.Keys,d.Unknown],[t.PopItem,d.None],[t.SetDefault,d.Unknown],[t.Update,d.None],[t.Values,d.Unknown],[t.Add,d.None],[t.Difference,d.Set],[t.DifferenceUpdate,d.None],[t.Discard,d.None],[t.Intersection,d.Set],[t.IntersectionUpdate,d.None],[t.IsDisjoint,d.Bool],[t.IsSubset,d.Bool],[t.IsSuperset,d.Bool],[t.SymmetricDifference,d.Set],[t.SymmetricDifferenceUpdate,d.None],[t.Union,d.Set],[t.Close,d.None],[t.FileNo,d.Int],[t.Flush,d.None],[t.IsAtty,d.Bool],[t.Read,d.String],[t.Readable,d.Bool],[t.ReadLine,d.String],[t.ReadLines,d.List],[t.Seek,d.None],[t.Seekable,d.Bool],[t.Tell,d.Unknown],[t.Truncate,d.None],[t.Writable,d.Bool],[t.Write,d.None],[t.WriteLines,d.None],[t.Main,d.None],[t.Cmp,d.Int],[t.Eq,d.Bool],[t.Ne,d.Bool],[t.Lt,d.Bool],[t.Gt,d.Bool],[t.Le,d.Bool],[t.Ge,d.Bool],[t.Str,d.String],[t.SpecialContains,d.Bool],[t.SpecialLen,d.Int],[t.ZipFunction,d.Unknown],[t.Seed,d.None],[t.GetState,d.Unknown],[t.SetState,d.None],[t.GetRandBits,d.Int],[t.RandRange,d.Int],[t.RandInt,d.Int],[t.Choice,d.Unknown],[t.Choices,d.List],[t.Shuffle,d.Shuffle],[t.Sample,d.List],[t.RandomMethod,d.Float],[t.Uniform,d.Float],[t.Triangular,d.Float],[t.BetaVariate,d.Float],[t.ExpoVariate,d.Float],[t.GammaVariate,d.Float],[t.Gauss,d.Float],[t.LogNormVariate,d.Float],[t.NormalVariate,d.Float],[t.VonMisesVariate,d.Float],[t.ParetoVariate,d.Float],[t.WeibullVariate,d.Float],[t.Acos,d.Float],[t.Acosh,d.Float],[t.Asin,d.Float],[t.Asinh,d.Float],[t.Atan,d.Float],[t.Atan2,d.Float],[t.Atanh,d.Float],[t.Ceil,d.Int],[t.Comb,d.Int],[t.CopySign,d.Float],[t.Cos,d.Float],[t.Cosh,d.Float],[t.Degrees,d.Float],[t.Dist,d.Float],[t.Erf,d.Float],[t.Erfc,d.Float],[t.Exp,d.Float],[t.Expm1,d.Float],[t.Fabs,d.Float],[t.Factorial,d.Int],[t.Floor,d.Int],[t.Fmod,d.Float],[t.Frexp,d.Tuple],[t.Fsum,d.Float],[t.Gamma,d.Float],[t.Gcd,d.Int],[t.Hypot,d.Float],[t.IsClose,d.Bool],[t.IsFinite,d.Bool],[t.IsInf,d.Bool],[t.IsNaN,d.Bool],[t.ISqrt,d.Int],[t.Ldexp,d.Float],[t.LGamma,d.Float],[t.Log,d.Float],[t.Log10,d.Float],[t.Log1P,d.Float],[t.Log2,d.Float],[t.Perm,d.Int],[t.Pow,d.Float],[t.Prod,d.Float],[t.Radians,d.Float],[t.Remainder,d.Float],[t.Sin,d.Float],[t.Sinh,d.Float],[t.Sqrt,d.Float],[t.Tan,d.Float],[t.Tanh,d.Float],[t.Trunc,d.Int],[t.E,d.Float],[t.Inf,d.Float],[t.Nan,d.Float],[t.Pi,d.Float],[t.Tau,d.Float],[t.AsciiLetters,d.String],[t.AsciiLowercase,d.String],[t.AsciiUppercase,d.String],[t.Digits,d.String],[t.Hexdigits,d.String],[t.Octdigits,d.String],[t.Punctuation,d.String],[t.Printable,d.String],[t.Whitespace,d.String],[t.Formatter,d.String],[t.Template,d.String],[t.Capwords,d.String],[t.ReA,d.Unknown],[t.ReASCII,d.Unknown],[t.ReDebug,d.Unknown],[t.ReI,d.Unknown],[t.ReIGNORECASE,d.Unknown],[t.ReL,d.Unknown],[t.ReLOCALE,d.Unknown],[t.ReM,d.Unknown],[t.ReMULTILINE,d.Unknown],[t.ReS,d.Unknown],[t.ReDOTALL,d.Unknown],[t.ReX,d.Unknown],[t.ReVERBOSE,d.Unknown],[t.Compile,d.Pattern],[t.Search,d.Unknown],[t.Match,d.Unknown],[t.FullMatch,d.Unknown],[t.FindAll,d.List],[t.FindIter,d.Unknown],[t.Sub,d.String],[t.SubN,d.Tuple],[t.Escape,d.String],[t.Purge,d.None],[t.AddAuditHook,d.None],[t.Audit,d.None],[t.CallTracing,d.Unknown],[t.ClearTypeCache,d.None],[t.CurrentFrames,d.Dict],[t.CurrentExceptions,d.Dict],[t.BreakpointHook,d.None],[t.DebugMallocStats,d.None],[t.DisplayHook,d.None],[t.ExceptHook,d.None],[t.ExcInfo,d.Tuple],[t.SysExit,d.None],[t.GetAllocatedBlocks,d.Int],[t.GetAndroidApiLevel,d.Int],[t.GetDefaultEncoding,d.String],[t.GetDLOpenFlags,d.Int],[t.GetFileSystemEncoding,d.String],[t.GetFileSystemEncodeErrors,d.String],[t.GetRefCount,d.Int],[t.GetRecursionLimit,d.Int],[t.GetSizeOf,d.Int],[t.GetSwitchInterval,d.Float],[t.GetFrame,d.Unknown],[t.GetProfile,d.None],[t.GetTrace,d.None],[t.GetWindowsVersion,d.Tuple],[t.GetAsyncGenHooks,d.Unknown],[t.GetCoroutineOriginTrackingDepth,d.Int],[t.Intern,d.Unknown],[t.IsFinalizing,d.Bool],[t.SetDLOpenFlags,d.None],[t.SetProfile,d.Unknown],[t.SetRecursionLimit,d.None],[t.SetSwitchInterval,d.None],[t.SetTrace,d.None],[t.SetAsyncgenHooks,d.None],[t.EnableLegacyWindowsFSEncoding,d.None],[t.ABIFlags,d.String],[t.Argv,d.List],[t.BaseExecPrefix,d.String],[t.BasePrefix,d.String],[t.ByteOrder,d.String],[t.BuiltInModuleNames,d.Tuple],[t.Copyright,d.String],[t.DllHandle,d.Int],[t.DontWriteBytecode,d.Bool],[t.PycachePrefix,d.Unknown],[t.ExecPrefix,d.String],[t.Executable,d.String],[t.Flags,d.Unknown],[t.FloatInfo,d.Unknown],[t.FloatReprStyle,d.String],[t.HashInfo,d.Unknown],[t.HexVersion,d.Int],[t.Implementation,d.Unknown],[t.IntInfo,d.Unknown],[t.LastType,d.Unknown],[t.LastValue,d.Unknown],[t.LastTraceback,d.Unknown],[t.MaxSize,d.Int],[t.MaxUnicode,d.Int],[t.MetaPath,d.List],[t.Modules,d.Dict],[t.OrigArgv,d.List],[t.Path,d.List],[t.PathHooks,d.List],[t.PathImporterCache,d.Dict],[t.Platform,d.String],[t.Prefix,d.String],[t.PS1,d.String],[t.PS2,d.String],[t.StdIn,d.Unknown],[t.StdOut,d.Unknown],[t.StdErr,d.Unknown],[t.StdLibModuleNames,d.Unknown],[t.ThreadInfo,d.Unknown],[t.TracebackLimit,d.Unknown],[t.Version,d.String],[t.ApiVersion,d.Int],[t.VersionInfo,d.Tuple],[t.WarnOptions,d.List],[t.WinVer,d.Int],[t.XOptions,d.Dict]]),_c=new Set([t.Add,t.Append,t.Clear,t.DifferenceUpdate,t.Discard,t.Extend,t.Insert,t.IntersectionUpdate,t.Pop,t.PopItem,t.Remove,t.Reverse,t.SetDefault,t.Sort,t.SymmetricDifferenceUpdate,t.Update]),Ci=new Set([t.Capitalize,t.Casefold,t.Center,t.Encode,t.ExpandTabs,t.Format,t.FormatMap,t.LJust,t.Lower,t.LStrip,t.Replace,t.RJust,t.RStrip,t.Strip,t.SwapCase,t.Title,t.Translate,t.Upper,t.ZFill]),Ro=new Map([[t.Seed,t.RandomModule],[t.GetState,t.RandomModule],[t.SetState,t.RandomModule],[t.GetRandBits,t.RandomModule],[t.RandRange,t.RandomModule],[t.RandInt,t.RandomModule],[t.Choice,t.RandomModule],[t.Choices,t.RandomModule],[t.Shuffle,t.RandomModule],[t.Sample,t.RandomModule],[t.RandomMethod,t.RandomModule],[t.Uniform,t.RandomModule],[t.Triangular,t.RandomModule],[t.BetaVariate,t.RandomModule],[t.ExpoVariate,t.RandomModule],[t.GammaVariate,t.RandomModule],[t.Gauss,t.RandomModule],[t.LogNormVariate,t.RandomModule],[t.NormalVariate,t.RandomModule],[t.VonMisesVariate,t.RandomModule],[t.ParetoVariate,t.RandomModule],[t.WeibullVariate,t.RandomModule],[t.Acos,t.MathModule],[t.Acosh,t.MathModule],[t.Asin,t.MathModule],[t.Asinh,t.MathModule],[t.Atan,t.MathModule],[t.Atan2,t.MathModule],[t.Atanh,t.MathModule],[t.Ceil,t.MathModule],[t.Comb,t.MathModule],[t.CopySign,t.MathModule],[t.Cos,t.MathModule],[t.Cosh,t.MathModule],[t.Degrees,t.MathModule],[t.Dist,t.MathModule],[t.Erf,t.MathModule],[t.Erfc,t.MathModule],[t.Exp,t.MathModule],[t.Expm1,t.MathModule],[t.Fabs,t.MathModule],[t.Factorial,t.MathModule],[t.Floor,t.MathModule],[t.Fmod,t.MathModule],[t.Frexp,t.MathModule],[t.Fsum,t.MathModule],[t.Gamma,t.MathModule],[t.Gcd,t.MathModule],[t.Hypot,t.MathModule],[t.IsClose,t.MathModule],[t.IsFinite,t.MathModule],[t.IsInf,t.MathModule],[t.IsNaN,t.MathModule],[t.ISqrt,t.MathModule],[t.Ldexp,t.MathModule],[t.LGamma,t.MathModule],[t.Log,t.MathModule],[t.Log10,t.MathModule],[t.Log1P,t.MathModule],[t.Log2,t.MathModule],[t.Perm,t.MathModule],[t.Pow,t.MathModule],[t.Prod,t.MathModule],[t.Radians,t.MathModule],[t.Remainder,t.MathModule],[t.Sin,t.MathModule],[t.Sinh,t.MathModule],[t.Sqrt,t.MathModule],[t.Tan,t.MathModule],[t.Tanh,t.MathModule],[t.Trunc,t.MathModule],[t.E,t.MathModule],[t.Inf,t.MathModule],[t.Nan,t.MathModule],[t.Pi,t.MathModule],[t.Tau,t.MathModule],[t.AsciiLetters,t.StringModule],[t.AsciiLowercase,t.StringModule],[t.AsciiUppercase,t.StringModule],[t.Digits,t.StringModule],[t.Hexdigits,t.StringModule],[t.Octdigits,t.StringModule],[t.Punctuation,t.StringModule],[t.Printable,t.StringModule],[t.Whitespace,t.StringModule],[t.Formatter,t.StringModule],[t.Template,t.StringModule],[t.Capwords,t.StringModule],[t.Pattern,t.ReModule],[t.Match,t.ReModule],[t.ReA,t.ReModule],[t.ReASCII,t.ReModule],[t.ReDebug,t.ReModule],[t.ReI,t.ReModule],[t.ReIGNORECASE,t.ReModule],[t.ReL,t.ReModule],[t.ReLOCALE,t.ReModule],[t.ReM,t.ReModule],[t.ReMULTILINE,t.ReModule],[t.ReS,t.ReModule],[t.ReDOTALL,t.ReModule],[t.ReX,t.ReModule],[t.ReVERBOSE,t.ReModule],[t.Compile,t.ReModule],[t.Search,t.ReModule],[t.Match,t.ReModule],[t.FullMatch,t.ReModule],[t.FindAll,t.ReModule],[t.FindIter,t.ReModule],[t.Sub,t.ReModule],[t.SubN,t.ReModule],[t.Escape,t.ReModule],[t.Purge,t.ReModule],[t.Split,t.ReModule],[t.AddAuditHook,t.Sys],[t.Audit,t.Sys],[t.CallTracing,t.Sys],[t.ClearTypeCache,t.Sys],[t.CurrentFrames,t.Sys],[t.CurrentExceptions,t.Sys],[t.BreakpointHook,t.Sys],[t.DebugMallocStats,t.Sys],[t.DisplayHook,t.Sys],[t.ExceptHook,t.Sys],[t.ExcInfo,t.Sys],[t.SysExit,t.Sys],[t.GetAllocatedBlocks,t.Sys],[t.GetAndroidApiLevel,t.Sys],[t.GetDefaultEncoding,t.Sys],[t.GetDLOpenFlags,t.Sys],[t.GetFileSystemEncoding,t.Sys],[t.GetFileSystemEncodeErrors,t.Sys],[t.GetRefCount,t.Sys],[t.GetRecursionLimit,t.Sys],[t.GetSizeOf,t.Sys],[t.GetSwitchInterval,t.Sys],[t.GetFrame,t.Sys],[t.GetProfile,t.Sys],[t.GetTrace,t.Sys],[t.GetWindowsVersion,t.Sys],[t.GetAsyncGenHooks,t.Sys],[t.GetCoroutineOriginTrackingDepth,t.Sys],[t.Intern,t.Sys],[t.IsFinalizing,t.Sys],[t.SetDLOpenFlags,t.Sys],[t.SetProfile,t.Sys],[t.SetRecursionLimit,t.Sys],[t.SetSwitchInterval,t.Sys],[t.SetTrace,t.Sys],[t.SetAsyncgenHooks,t.Sys],[t.EnableLegacyWindowsFSEncoding,t.Sys],[t.ABIFlags,t.Sys],[t.Argv,t.Sys],[t.BaseExecPrefix,t.Sys],[t.BasePrefix,t.Sys],[t.ByteOrder,t.Sys],[t.BuiltInModuleNames,t.Sys],[t.Copyright,t.Sys],[t.DllHandle,t.Sys],[t.DontWriteBytecode,t.Sys],[t.PycachePrefix,t.Sys],[t.ExecPrefix,t.Sys],[t.Executable,t.Sys],[t.Flags,t.Sys],[t.FloatInfo,t.Sys],[t.FloatReprStyle,t.Sys],[t.HashInfo,t.Sys],[t.HexVersion,t.Sys],[t.Implementation,t.Sys],[t.IntInfo,t.Sys],[t.LastType,t.Sys],[t.LastValue,t.Sys],[t.LastTraceback,t.Sys],[t.MaxSize,t.Sys],[t.MaxUnicode,t.Sys],[t.MetaPath,t.Sys],[t.Modules,t.Sys],[t.OrigArgv,t.Sys],[t.Path,t.Sys],[t.PathHooks,t.Sys],[t.PathImporterCache,t.Sys],[t.Platform,t.Sys],[t.Prefix,t.Sys],[t.PS1,t.Sys],[t.PS2,t.Sys],[t.StdIn,t.Sys],[t.StdOut,t.Sys],[t.StdErr,t.Sys],[t.StdLibModuleNames,t.Sys],[t.ThreadInfo,t.Sys],[t.TracebackLimit,t.Sys],[t.Version,t.Sys],[t.ApiVersion,t.Sys],[t.VersionInfo,t.Sys],[t.WarnOptions,t.Sys],[t.WinVer,t.Sys],[t.XOptions,t.Sys]]),Oi={assert:{entity:t.AssertFunction,category:c.BuiltInFunctions},random:{entity:t.RandomMethod,category:c.BuiltInMethods},exit:{entity:t.SysExit,category:c.ModuleFunctions}},Hn=new Map([[d.String,new Set([t.Capitalize,t.Casefold,t.Center,t.Count,t.Encode,t.ExpandTabs,t.Find,t.Format,t.Index,t.IsAlnum,t.IsAlpha,t.IsAscii,t.IsDecimal,t.IsDigit,t.IsIdentifier,t.IsLower,t.IsNumeric,t.IsPrintable,t.IsSpace,t.IsTitle,t.IsUpper,t.Join,t.LJust,t.Lower,t.LStrip,t.MakeTrans,t.Partition,t.Replace,t.RFind,t.RIndex,t.RJust,t.RPartition,t.RSplit,t.RStrip,t.Split,t.SplitLines,t.StartsWith,t.Strip,t.SwapCase,t.Title,t.Translate,t.Upper,t.ZFill])],[d.List,new Set([t.Append,t.Clear,t.Copy,t.Count,t.Extend,t.Index,t.Insert,t.Pop,t.Remove,t.Reverse,t.Sort,c.MagicMethods])],[d.Tuple,new Set([t.Count,t.Index])],[d.Set,new Set([t.Add,t.Clear,t.Copy,t.Difference,t.DifferenceUpdate,t.Discard,t.Intersection,t.IntersectionUpdate,t.IsDisjoint,t.IsSubset,t.IsSuperset,t.Pop,t.Remove,t.SymmetricDifference,t.SymmetricDifferenceUpdate,t.Union,t.Update])],[d.Dict,new Set([t.Clear,t.Copy,t.FromKeys,t.Get,t.Items,t.Keys,t.Pop,t.PopItem,t.SetDefault,t.Update,t.Values])],[d.File,new Set([t.Close,t.FileNo,t.Flush,t.IsAtty,t.Read,t.Readable,t.ReadLine,t.ReadLines,t.Seek,t.Seekable,t.Tell,t.Truncate,t.Writable,t.Write,t.WriteLines])],[d.Random,new Set([t.Seed,t.GetState,t.SetState,t.GetRandBits,t.RandRange,t.RandInt,t.Choice,t.Choices,t.Shuffle,t.Sample,t.RandomMethod,t.Uniform,t.Triangular,t.BetaVariate,t.ExpoVariate,t.GammaVariate,t.Gauss,t.LogNormVariate,t.NormalVariate,t.VonMisesVariate,t.ParetoVariate,t.WeibullVariate,c.MagicMethods])],[d.Math,new Set([t.Acos,t.Acosh,t.Asin,t.Asinh,t.Atan,t.Atan2,t.Atanh,t.Ceil,t.Comb,t.CopySign,t.Cos,t.Cosh,t.Degrees,t.Dist,t.Erf,t.Erfc,t.Exp,t.Expm1,t.Fabs,t.Factorial,t.Floor,t.Fmod,t.Frexp,t.Fsum,t.Gamma,t.Gcd,t.Hypot,t.IsClose,t.IsFinite,t.IsInf,t.IsNaN,t.ISqrt,t.Ldexp,t.LGamma,t.Log,t.Log10,t.Log1P,t.Log2,t.Perm,t.Pow,t.Prod,t.Radians,t.Remainder,t.Sin,t.Sinh,t.Sqrt,t.Tan,t.Tanh,t.Trunc])],[d.StringModule,new Set([t.Formatter,t.Template,t.Capwords])],[d.Re,new Set([t.Compile,t.Search,t.Match,t.FullMatch,t.FindAll,t.FindIter,t.Sub,t.SubN,t.Escape,t.Purge,t.Split])],[d.Sys,new Set([t.AddAuditHook,t.Audit,t.CallTracing,t.ClearTypeCache,t.CurrentFrames,t.CurrentExceptions,t.BreakpointHook,t.DebugMallocStats,t.DisplayHook,t.ExceptHook,t.ExcInfo,t.SysExit,t.GetAllocatedBlocks,t.GetAndroidApiLevel,t.GetDefaultEncoding,t.GetDLOpenFlags,t.GetFileSystemEncoding,t.GetFileSystemEncodeErrors,t.GetRefCount,t.GetRecursionLimit,t.GetSizeOf,t.GetSwitchInterval,t.GetFrame,t.GetProfile,t.GetTrace,t.GetWindowsVersion,t.GetAsyncGenHooks,t.GetCoroutineOriginTrackingDepth,t.Intern,t.IsFinalizing,t.SetDLOpenFlags,t.SetProfile,t.SetRecursionLimit,t.SetSwitchInterval,t.SetTrace,t.SetAsyncgenHooks,t.EnableLegacyWindowsFSEncoding])]]);class J{constructor(i,e,n,s,o,a="",h={}){b(this,Vt);b(this,Lt);b(this,vt);b(this,Rt);b(this,Et);b(this,ln);b(this,cn);y(this,Vt,i),y(this,Lt,e),y(this,cn,n),y(this,vt,s),y(this,Rt,o),y(this,Et,a),y(this,ln,h)}getID(){return u(this,Vt)}getLineNumber(){return u(this,Lt)}getBlock(){return u(this,cn)}getDocIndex(){return u(this,vt)}getLineIndex(){return u(this,Rt)}getAffectedText(){return u(this,Et)}getAdditionalInfo(){return u(this,ln)}toString(){return`{line: ${u(this,Lt)}, type: ${u(this,Vt)}, text: ${u(this,Et)}, docIndex: ${u(this,vt)}, lineIndex: ${u(this,Rt)}, additionalInfo: ${u(this,ln)}`}toJSON(){return{line:u(this,Lt),type:u(this,Vt),text:u(this,Et),block:u(this,cn),docIndex:u(this,vt),lineIndex:u(this,Rt)}}}Vt=new WeakMap,Lt=new WeakMap,vt=new WeakMap,Rt=new WeakMap,Et=new WeakMap,ln=new WeakMap,cn=new WeakMap;class eu extends J{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("parentText")&&(i.parentText=e.parentText),i}}class tu extends J{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();if(e.hasOwnProperty("expression")){let n=e.expression.getCategory().name;e.expression.getEntity()===t.VariableName?n=vc:e.expression.is(t.UserDefinedFunctionCall)?n=nn:e.expression.is(t.BuiltInFunctionCall)&&(n=sn),i.expressionNoValue={type:n,value:e.expression.getTextValue()}}return e.hasOwnProperty("usage")&&(i.usage=e.usage),e.hasOwnProperty("target")&&(i.target=e.target),i}}class nu extends J{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("assignedVariables")&&(i.assignedVariables=e.assignedVariables),i}}class su extends J{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("boolValue")&&(i.boolValue=e.boolValue),e.hasOwnProperty("operator")&&(i.operator=e.operator),e.hasOwnProperty("boolLiteral")&&(i.boolLiteral=e.boolLiteral),e.hasOwnProperty("usedIn")&&(i.usedIn=e.usedIn),i}}class iu extends J{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("definitionType")&&(i.boolValue=e.definitionType),e.hasOwnProperty("reservedWord")&&(i.reservedWord=e.reservedWord),i}}class ou extends J{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("definitionText")&&(i.definitionText=e.definitionText),e.hasOwnProperty("loopVarTypeAtDefinition")&&(i.loopVarTypeAtDefinition=e.loopVarTypeAtDefinition),e.hasOwnProperty("modificationText")&&(i.modificationText=e.modificationText),i}}class ru extends J{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("printLines")&&(i.printLines=e.printLines),e.hasOwnProperty("functionReturns")&&(i.functionReturns=e.functionReturns),i}}class au extends J{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("loopType")&&(i.loopType=e.loopType),e.hasOwnProperty("exitLevel")&&(i.exitLevel=e.exitLevel),e.hasOwnProperty("exitTypes")&&(i.exitTypes=e.exitTypes),i}}class lu extends J{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("modifiedIn")&&(i.modifiedIn=e.modifiedIn),i}}class cu extends J{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("unmodifiedVars")&&(i.unmodifiedVars=e.unmodifiedVars),e.hasOwnProperty("loopText")&&(i.loopText=e.loopText),i}}class uu extends J{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("form")&&(i.form=e.form),e.hasOwnProperty("leftSideType")&&(i.leftSideType=e.leftSideType.name),e.hasOwnProperty("leftSideText")&&(i.leftSideText=e.leftSideText),e.hasOwnProperty("leftSideEntity")&&(i.leftSideEntity=e.leftSideEntity.name),e.hasOwnProperty("operator")&&(i.operator=e.operator),e.hasOwnProperty("rightSideType")&&(i.rightSideType=e.rightSideType.name),e.hasOwnProperty("rightSideText")&&(i.rightSideText=e.rightSideText),e.hasOwnProperty("rightSideEntity")&&(i.rightSideEntity=e.rightSideEntity.name),e.hasOwnProperty("parentText")&&(i.parentText=e.parentText),e.hasOwnProperty("parentEntity")&&(i.parentEntity=e.parentEntity.name),e.hasOwnProperty("completeBooleanExpression")&&(i.completeBooleanExpression=e.completeBooleanExpression),i}}class du extends J{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("form")&&(i.form=e.form),e.hasOwnProperty("variableAssigned")&&(i.variableAssigned=e.variableAssigned),e.hasOwnProperty("condition")&&(i.condition=e.condition),i}}class hu extends J{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("isParameter")&&(i.isParameter=e.isParameter),e.hasOwnProperty("prevUsageIsDefinition")&&(i.prevUsageIsDefinition=e.prevUsageIsDefinition),e.hasOwnProperty("overwriteType")&&(i.overwriteType=e.overwriteType),e.hasOwnProperty("overwriteValue")&&(i.overwriteValue=e.overwriteValue),e.hasOwnProperty("overwrittenVar")&&(i.overwrittenVar=e.overwrittenVar),e.hasOwnProperty("functionBlock")&&(i.functionBlock=e.functionBlock),e.hasOwnProperty("usageText")&&(i.usageText=e.usageText),i}}class fu extends J{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("contents")&&(i.contents=e.contents),e.hasOwnProperty("textInParentheses")&&(i.textInParentheses=e.textInParentheses),i}}class gu extends J{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("branchMatches")&&(i.branchMatches=e.branchMatches),i}}class pu extends J{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("isUndefined")&&(i.isUndefined=e.isUndefined),e.hasOwnProperty("subscriptedType")&&(i.subscriptedType=e.subscriptedType.name),e.hasOwnProperty("varName")&&(i.varName=e.varName),i}}class mu extends J{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("boolValue")&&(i.boolValue=e.boolValue),e.hasOwnProperty("boolLiteralIfTrue")&&(i.boolLiteralIfTrue=e.boolLiteralIfTrue),e.hasOwnProperty("boolLiteralIfFalse")&&(i.boolLiteralIfFalse=e.boolLiteralIfFalse),e.hasOwnProperty("parentText")&&(i.parentText=e.parentText),e.hasOwnProperty("parentEntity")&&(i.parentEntity=e.parentEntity),i}}class wu extends J{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("parts")&&(i.parts=e.parts),i}}class Su extends J{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("convertedValue")&&(i.convertedValue=e.convertedValue),e.hasOwnProperty("argType")&&(i.argType=e.argType),e.hasOwnProperty("convertedType")&&(i.convertedType=e.convertedType),i}}class bu extends J{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("variable")&&(i.variable=e.variable.toJSON()),e.hasOwnProperty("localVariables")&&(i.localVariables=e.localVariables),i}}class Iu extends J{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("before")&&(i.before=e.before),e.hasOwnProperty("after")&&(i.after=e.after),i}}class yu extends J{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("objectType")&&(i.objectType=e.objectType),i}}class Fu extends J{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("exitKeyword")&&(i.exitKeyword=e.exitKeyword),e.hasOwnProperty("functionBlock")&&(i.functionBlock=e.functionBlock),i}}class Nu extends J{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("infiniteLoopLine")&&(i.infiniteLoopLine=e.infiniteLoopLine),i}}class Cu extends J{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();if(e.hasOwnProperty("expression")){let n=e.expression.getCategory().name;e.expression.getEntity()===t.FunctionName?n=nn:e.expression.getCategory()===c.BuiltInFunctions&&(n=sn),i.unusedFunc={type:n,value:e.expression.getTextValue(),returnType:e.expression.getDataType().name.replace(" (int or float)","")}}return i}}class Ou extends J{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("funcType")&&(i.funcType=e.funcType),e.hasOwnProperty("numArgsExpected")&&(i.numArgsExpected=e.numArgsExpected),e.hasOwnProperty("varIsParameter")&&(i.varIsParameter=e.varIsParameter),i}}class Tu extends J{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("expectedMinArgs")&&(i.expectedMinArgs=e.expectedMinArgs),e.hasOwnProperty("expectedMaxArgs")&&(i.expectedMinArgs=e.expectedMaxArgs),e.hasOwnProperty("receivedArgs")&&(i.receivedArgs=e.receivedArgs),i}}class Mu extends J{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("parentText")&&(i.parentText=e.parentText),e.hasOwnProperty("completeBooleanExpression")&&(i.completeBooleanExpression=e.completeBooleanExpression),i}}class xu extends J{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("before")&&(i.before=e.before),e.hasOwnProperty("after")&&(i.after=e.after),i}}class Du extends J{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("boolValue")&&(i.boolValue=e.boolValue),e.hasOwnProperty("usedIn")&&(i.usedIn=e.usedIn),i}}class Au extends J{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("functionBlock")&&(i.functionBlock=e.functionBlock),i}}class Bu extends J{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("usageText")&&(i.usageText=e.usageText),i}}class ku extends J{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("numArgs")&&(i.numArgs=e.numArgs),i}}class Pu extends J{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("isNestedInWhile")&&(i.isNestedInWhile=e.isNestedInWhile),e.hasOwnProperty("counterType")&&(i.counterType=e.counterType),i}}class Vu extends J{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("isParameter")&&(i.isParameter=e.isParameter),e.hasOwnProperty("definedInScope")&&(i.definedInScope=e.definedInScope),i}}class Lu extends J{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("loopVars")&&(i.loopVars=e.loopVars),i}}class vu extends J{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("assignedToVariable")&&(i.assignedToVariable=e.assignedToVariable),e.hasOwnProperty("expression")&&(i.expression=e.expression),i}}class Ru extends J{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("expression")&&(i.expression=e.expression),i}}class Eu extends J{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("expression")&&(i.expression=e.expression.toJSON()),e.hasOwnProperty("usage")&&(i.usage=e.usage),e.hasOwnProperty("usageType")&&(i.usageType=e.usageType),i}}class Uu extends J{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("expression")&&(i.expression=e.expression.toJSON()),i}}class Gu extends J{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("returnValue")&&(i.returnValue=e.returnValue),i}}class Ju extends J{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("branches")&&(i.branches=e.branches),i}}class $u extends J{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("loopType")&&(i.loopType=e.loopType),e.hasOwnProperty("loopBlock")&&(i.loopBlock=e.loopBlock),i}}const Ut=class Ut{static createStatementSymptom(i,e,n,s,o={},a="",h=!1){var E;const p=e[n].getStartLineNumber(),w=a===""?e[n].getBlockId():a,S=e[n].getDocumentStartIndex(),F=e[n].getIndexOnLine(),N=fe(e.slice(n,s+1),h);if(i instanceof k)return m(E=Ut,Zs,ir).call(E,i,p,w,S,F,N,o);switch(i){case I.AssignmentInBoolean:return new eu(i.name,p,w,S,F,N,o);case I.AssignedNone:return new tu(i.name,p,w,S,F,N,o);case I.AssignmentInReturn:return new nu(i.name,p,w,S,F,N,o);case I.CompareBoolLiteral:return new su(i.name,p,w,S,F,N,o);case I.DefinitionFollowedByReservedWord:return new iu(i.name,p,w,S,F,N,o);case I.FunctionPrints:return new ru(i.name,p,w,S,F,N,o);case I.ForLoopIteratorModified:return new ou(i.name,p,w,S,F,N,o);case I.LoopReturn:return new au(i.name,p,w,S,F,N,o);case I.LoopVarModifiedInChildLoop:return new lu(i.name,p,w,S,F,N,o);case I.LoopVarNotModified:return new cu(i.name,p,w,S,F,N,o);case I.NaturalLanguageBoolean:return new uu(i.name,p,w,S,F,N,o);case I.OneLineConditional:return new du(i.name,p,w,S,F,N,o);case I.OverwrittenVariable:return new hu(i.name,p,w,S,F,N,o);case I.ReturnInParentheses:return new fu(i.name,p,w,S,F,N,o);case I.SequentialIfs:return new gu(i.name,p,w,S,F,N,o);case I.SubscriptedNonSubscriptable:return new pu(i.name,p,w,S,F,N,o);case I.TernaryReturnsBool:return new mu(i.name,p,w,S,F,N,o);case I.TypeErrorInvalid:return new wu(i.name,p,w,S,F,N,o);case I.TypeUnnecessary:return new Su(i.name,p,w,S,F,N,o);case I.UndefinedVariable:return new bu(i.name,p,w,S,F,N,o);case I.UnexpectedColon:return new Iu(i.name,p,w,S,F,N,o);case I.UnknownMethod:return new yu(i.name,p,w,S,F,N,o);case I.UnreachableExit:return new Fu(i.name,p,w,S,F,N,o);case I.UnreachableInfiniteLoop:return new Nu(i.name,p,w,S,F,N,o);case I.UnusedReturn:return new Cu(i.name,p,w,S,F,N,o);case I.VariableWithSameNameAsFunction:return new Ou(i.name,p,w,S,F,N,o);case I.WrongArgNumber:return new Tu(i.name,p,w,S,F,N,o);default:return new J(i.name,p,w,S,F,N,o)}}};Zs=new WeakSet,ir=function(i,e,n,s,o,a,h){switch(i){case k.EqualityExpression:return new Mu(i.name,e,n,s,o,a,h);case k.ValidAssignment:return new xu(i.name,e,n,s,o,a,h);case k.StandaloneBooleanVariable:return new Du(i.name,e,n,s,o,a,h);case k.ReturnLast:return new Au(i.name,e,n,s,o,a,h);case k.NewForLoopVar:return new Bu(i.name,e,n,s,o,a,h);case k.ValidFunctionCall:return new ku(i.name,e,n,s,o,a,h);case k.CounterLoop:return new Pu(i.name,e,n,s,o,a,h);case k.FunctionScopeVariable:return new Vu(i.name,e,n,s,o,a,h);case k.ForLoopTargetNotModified:return new Lu(i.name,e,n,s,o,a,h);case k.NonLiteralBooleanAssigned:return new vu(i.name,e,n,s,o,a,h);case k.NonLiteralBooleanReturned:return new Ru(i.name,e,n,s,o,a,h);case k.UsedReturn:return new Eu(i.name,e,n,s,o,a,h);case k.NoReturnStandaloneCall:return new Uu(i.name,e,n,s,o,a,h);case k.ReturnNoParentheses:return new Gu(i.name,e,n,s,o,a,h);case k.IfElif:return new Ju(i.name,e,n,s,o,a,h);case k.LoopExitsSometimes:return new $u(i.name,e,n,s,o,a,h);default:return new J(i.name,e,n,s,o,a,h)}},b(Ut,Zs),l(Ut,"symptoms",[]),l(Ut,"counterSymptoms",[]),l(Ut,"text","");let O=Ut;class Ks{constructor(){b(this,Gt,[]);b(this,Jt,[]);b(this,Xn,!1);b(this,Zn,!1)}getRules(){return u(this,Gt)}getCounterRules(){return u(this,Jt)}checkRules(i){if(!u(this,Xn)){for(const e of u(this,Gt))O.symptoms.push(...e(i));y(this,Xn,!0)}}checkForCounterRules(i){if(!u(this,Zn)){for(const e of u(this,Jt))O.counterSymptoms.push(...e(i));y(this,Zn,!0)}}addRule(i){u(this,Gt).push(i)}addCounterRule(i){u(this,Jt).push(i)}addRules(i){u(this,Gt).push(...i)}addCounterRules(i){u(this,Jt).push(...i)}}Gt=new WeakMap,Jt=new WeakMap,Xn=new WeakMap,Zn=new WeakMap;class Ws extends Ks{constructor(){super();l(this,"observers");this.observers=new Set}addObserver(e,n=void 0){this.observers.add(e),e instanceof Ws&&n!==void 0&&e.typeUpdateReceived(n)}getObservers(){return this.observers}removeObserver(e){this.observers.delete(e)}sendUpdate(e){for(let n of this.observers)n instanceof Ws&&n.typeUpdateReceived(e)}typeUpdateReceived(e){}}class Eo extends Ks{constructor(e,n,s){super();b(this,Ie);b(this,$t);b(this,$e,[]);b(this,gt);b(this,lt);b(this,un,!1);b(this,Yn,[]);b(this,_n,[]);if(!e.getVariable().isOneOf([t.VariableName,t.PropertyName]))throw new Error("First expression of variable is not a variable.");y(this,$t,e.getVariable().getTextValue()),u(this,$e).push(e);const o=n.getExpressions();o.length>0&&o[0].is(t.FunctionDefinitionStatement)&&y(this,un,!0),y(this,gt,s),y(this,lt,s.getScope()),this.addRules([m(this,Ie,lr),m(this,Ie,rr)]),this.addCounterRules([m(this,Ie,cr),m(this,Ie,ur)])}getName(){return u(this,$t)}getUsages(){return u(this,$e)}addUsages(e){for(let n of e)this.addUsage(n)}insertUsages(e){const n=[...u(this,$e)];y(this,$e,e),this.addUsages(n)}addUsage(e){const n=e.getVariable();if(u(this,$e).length>0){let s=u(this,$e).length-1,o=!1;const a=new Set,h=[];for(;s>=0&&!o;){const p=u(this,$e)[s],w=p.getVariable();if(p.isInConditionalDefinition()){const S=p.getBodyOfConditional();if(a.has(S)){s--;continue}}if(e.isInSameBlock(p)||p.isInParentBlock(e)||m(this,Ie,or).call(this,w,n))n.addLastUsage(w),o=!0;else if(!e.isInAlternateBranch(p)&&!a.has(p.getBlock())){n.addLastUsage(w);const S=p.getBlock();a.add(S),S.isBranchBlock()&&S.isBranchOfConditional()&&(S.getBlockEntity()===t.ElseDefinition||S.getBlockEntity()===t.ExceptDefinition?h.push(new Set([...S.getSiblingConditionalBranches()])):S.isBranchOfExhaustiveConditional()&&(o=m(this,Ie,qi).call(this,S,e.getBlock(),h,a)))}s--}if(!o&&!n.isAssignedOrChanged()){const p=new an("Undefined Variable",t.VariableName,c.Identifiers,-1,-1,-1);p.setDataType(d.Undefined),n.addLastUsage(p)}}n.isProxy()||u(this,$e).push(e)}checkAndAdjustUndefined(){const e=this.getUsages();e[0].getVariable().isProxy()&&(e[0].getVariable().setDataType(d.Undefined),e.shift())}getDefinedInBlock(){return u(this,gt)}setDefinedInBlock(e){y(this,gt,e),e.isScopeBlock()||y(this,lt,e.getScope())}isSameVariable(e){return u(this,$t)===e.getName()&&u(this,gt).getId()===e.getDefinedInBlock().getId()&&u(this,lt).hasChild(e.getScope()||e.getScope().hasChild(u(this,lt)))}getScope(){return u(this,lt)}isParameter(){return u(this,un)}getChildScopesWithUsages(){return u(this,Yn)}addChildScopeWithUsages(e){u(this,Yn).push(e)}addChildScopeVariable(e){u(this,_n).push(e)}getChildScopeVariables(){return u(this,_n)}toJSON(){return{name:u(this,$t),definitionBlock:u(this,gt).getId(),scopeBlock:u(this,lt).getId(),isParameter:u(this,un),usages:u(this,$e).map(e=>e.toJSON())}}}$t=new WeakMap,$e=new WeakMap,gt=new WeakMap,lt=new WeakMap,un=new WeakMap,Yn=new WeakMap,_n=new WeakMap,Ie=new WeakSet,or=function(e,n){return e.is(t.VariableName)||n.is(t.VariableName)?!1:e.getOwnerType().name===n.getOwnerType().name},qi=function(e,n,s,o){for(const a of s)if(a.has(e)&&(a.delete(e),a.size===0)){if(e.getParentBlock().hasChild(n))return!0;o.add(e.getParentBlock());const h=e.getParentBlock();if(h.isBranchBlock()){if(h.getBlockEntity()===t.ElseDefinition||h.getBlockEntity()===t.ExceptDefinition)s.push(new Set([...h.getSiblingConditionalBranches()]));else if(h.isBranchOfExhaustiveConditional())return m(this,Ie,qi).call(this,h,n,s,o)}}return!1},rr=function(e){var o;const n=[],s=e.getUsages();if(s.length===1){const h=s[0].getVariable(),p=h.getParent()&&h.getParent().is(t.MethodDefinitionStatement)&&h.getParent().getClassVar().getTextValue()===h.getTextValue();s.length===1&&h.isAssignedOrChanged()&&!p&&!m(o=e,Ie,ar).call(o,h)&&h.getDataType()!==d.Undefined&&n.push(O.createStatementSymptom(I.UnusedVariable,[s[0].getVariable()],0,0))}return n},ar=function(e){if(e.getParent()===void 0)return!1;if(e.getParent().is(t.AssignmentStatement)){const n=e.getParent().getParent();return n===void 0?!1:n.isOneOf([c.FunctionCall,c.MethodCall])}return!1},lr=function(e){const n=[],s=e.getUsages();let o;for(const a of s)if(!a.isPrecededByGlobal()){o=a;break}return o!==void 0&&s.length>0&&o.getVariable().getDataType()===d.Undefined&&(n.push(O.createStatementSymptom(I.UndefinedVariable,[o.getVariable()],0,0,{variable:e})),Xe(o.getVariable().getTextValue()).category===c.BuiltInFunctions&&n.push(O.createStatementSymptom(I.VariableWithSameNameAsFunction,[o.getVariable()],0,0,{funcType:sn,varIsParameter:o.getVariable().isParameter()}))),n},cr=function(e){const n=[],s=e.getUsages();let o;for(const a of s)if(!a.isPrecededByGlobal()){o=a;break}return o!==void 0&&s.length>0&&(e.getScope().getBlockEntity()===t.FunctionDefinition?n.push(O.createStatementSymptom(k.FunctionScopeVariable,[o.getVariable()],0,0,{isParameter:e.isParameter(),definedInScope:e.getScope().getId()})):e.getScope().getBlockEntity()===t.DocumentDefinition&&o.getVariable().getDataType()!==d.Undefined&&n.push(O.createStatementSymptom(k.ValidGlobalVariable,[o.getVariable()],0,0))),n},ur=function(e){const n=[],s=e.getUsages();return e.isParameter()&&s.length>1&&!s[1].getVariable().isAssignedOrChanged()&&n.push(O.createStatementSymptom(k.ParameterCalled,[s[1].getVariable()],0,0)),n};class Uo{constructor(i,e,n=!1){b(this,mt);b(this,pt);b(this,ke);b(this,dn,!1);b(this,es);y(this,pt,i),y(this,es,n);const s=e.getStatements();e.isBranchBlock()&&e.getBlockEntity()!==t.ForDefinition&&e.getBlockEntity()!==t.WhileDefinition&&s.length>0?s[0].getDefinitionStatement().containsExpression(i)?(y(this,ke,e.getParentBlock()),y(this,dn,!0)):y(this,ke,e):(y(this,ke,e),s.length>0&&s[s.length-1].isBlockStatement()&&s[s.length-1].containsExpression(i)&&y(this,dn,!0))}getVariable(){return u(this,pt)}getBlock(){return u(this,ke)}isInConditionalDefinition(){return u(this,dn)}getBodyOfConditional(){const i=u(this,ke).getChildBlocks(),e=this.getVariable().getStartLineNumber();for(const n of i)if(n.isBranchBlock()&&n.isBranchOfConditional()&&n.getStatements()[0].getLineNumbers().has(e))return n;return u(this,ke)}isInSameBlock(i){return u(this,ke)===i.getBlock()}isInParentBlock(i){return!this.isInSameBlock(i)&&u(this,ke).hasChild(i.getBlock())}isInAlternateBranch(i){if(u(this,ke).getBlockEntity()===t.ExceptDefinition&&i.getBlock().getBlockEntity()===t.TryDefinition&&u(this,ke).getParentBlock()===i.getBlock().getParentBlock())return!1;const e=this.isInConditionalDefinition(),n=i.isInConditionalDefinition();let s=u(this,ke);e&&!n&&(s=this.getBodyOfConditional());let o=m(this,mt,fi).call(this,s);const a=m(this,mt,fi).call(this,i.getBlock());return o!==void 0&&a!==void 0?m(this,mt,dr).call(this,o,a,i.getBlock()):o!==void 0&&a===void 0||o===void 0&&a!==void 0?!1:!s.hasChild(i.getBlock())&&!i.getBlock().hasChild(s)}isPrecededByGlobal(){return u(this,es)}toJSON(){return{line:u(this,pt).getStartLineNumber(),docIndex:u(this,pt).getDocumentStartIndex(),type:u(this,pt).getDataType().name}}}pt=new WeakMap,ke=new WeakMap,dn=new WeakMap,es=new WeakMap,mt=new WeakSet,dr=function(i,e,n){for(;i!==void 0&&e!==void 0&&i!==e;){const s=i.getSiblingConditionalBranches();for(let o of s)if(o.hasChild(n))return!0;i=m(this,mt,fi).call(this,i.getParentBlock())}return!1},fi=function(i){return i!==void 0&&i.isBranchBlock()&&i.isBranchOfConditional()?i:i.getNearestParentOfAny([t.IfDefinition,t.ElifDefinition,t.ElseDefinition])};class Ku{constructor(i,e,n=i){b(this,ts);b(this,ns);b(this,hn);b(this,ct);b(this,Kt);y(this,ts,i),y(this,ns,e),y(this,hn,n),y(this,ct,new Map),y(this,Kt,!1)}getName(){return u(this,ts)}getEntity(){return u(this,ns)}getAlias(){return u(this,hn)}setAlias(i){y(this,hn,i)}addDirectImport(i,e){u(this,ct).set(i,e)}hasDirectImport(i){return u(this,ct).has(i)}getDirectImport(i){return u(this,ct).get(i)}getDirectImports(){return u(this,ct)}setImportAll(){y(this,Kt,!0)}didImportAll(){return u(this,Kt)}hasDirectImports(){return u(this,Kt)||u(this,ct).size>0}}ts=new WeakMap,ns=new WeakMap,hn=new WeakMap,ct=new WeakMap,Kt=new WeakMap;const Wu=(g,i)=>({entity:g,category:i});class Go{constructor(i){b(this,fn);b(this,wt,0);b(this,St,0);y(this,fn,i);for(let e=0;e<i.length;e++)i.charAt(e)==="	"?hi(this,St)._++:hi(this,wt)._++}getText(){return u(this,fn)}getSpaceCount(){return u(this,wt)}getTabCount(){return u(this,St)}noIndentation(){return u(this,fn).length===0}isAllSpaces(){return u(this,wt)>0&&u(this,St)===0}isAllTabs(){return u(this,St)>0&&u(this,wt)===0}isMixed(){return u(this,St)>0&&u(this,wt)>0}}fn=new WeakMap,wt=new WeakMap,St=new WeakMap;class Jo extends Ks{constructor(e=t.DocumentDefinition,n=void 0,s=0){super();b(this,$);b(this,Ke);b(this,bt);b(this,ge);b(this,ss);b(this,ee);y(this,Ke,e),y(this,bt,n),y(this,ge,[]),y(this,ss,s),y(this,ee,[]),this.addRules([m(this,$,Sr),m(this,$,mr),m(this,$,pr),m(this,$,hr)]),this.addCounterRules([m(this,$,fr),m(this,$,wr)])}getBlockEntity(){return u(this,Ke)}getId(){return`${u(this,Ke)===t.DocumentDefinition?0:u(this,ee).length>0?u(this,ee)[0].getFirstLineNumber():-1}-${u(this,Ke).name}`}getParentBlock(){return u(this,bt)}setParentBlock(e){y(this,bt,e)}getRootBlock(){return u(this,bt)===void 0?this:u(this,bt).getRootBlock()}getChildBlocks(){return u(this,ge)}getChildBlocksOfKind(e){let n=[];for(const s of u(this,ge))n=n.concat(s.getChildBlocksOfKind(e));return u(this,Ke)===e&&n.push(this),n}addChildBlock(e){u(this,ge).push(e),e.setParentBlock(this)}hasParentOfEntity(e){return this.stepsToParentBlockOfEntity(e)>=0}stepsToParentBlockOfEntity(e){if(u(this,Ke)===e)return 0;let n=this.getParentBlock(),s=1;for(;n!==void 0;){if(n.getBlockEntity()===e)return s;n=n.getParentBlock(),s++}return-1}getNearestParentOfAny(e){if(e.includes(u(this,Ke)))return this;let n=this.getParentBlock();for(;n!==void 0;){if(e.includes(n.getBlockEntity()))return n;n=n.getParentBlock()}}getNearestParentChildOf(e){if(this===e||!e.hasChild(this))return;let n=this.getParentBlock();for(;n!==void 0&&n.getParentBlock()!==e;)n=n.getParentBlock();return n}getIndentation(){return u(this,ss)}getStartLine(){return u(this,Ke)===t.DocumentDefinition?0:u(this,ee).length>0?u(this,ee)[0].getFirstLineNumber():-1}isScopeBlock(){return!1}isBranchBlock(){return!1}getScope(){if(this.isScopeBlock())return this;let e=this.getParentBlock();for(;e!==void 0&&!e.isScopeBlock();)e=e.getParentBlock();if(e!==void 0)return e;throw new Error("Could not find a scope block...block structure must be incorrect")}addStatement(e){u(this,ee).push(e);for(const n of e.getExpressions())n.setBlockId(this.getId()),n.setScopeId(this.getScope().getId());Q.makeGraphConnections(u(this,ee))}getLastStatement(){if(u(this,ee).length===0)throw new Error("No statements in the block. Could not get the last statement.");return u(this,ee)[u(this,ee).length-1]}replaceLastStatement(e){if(u(this,ee).length===0)throw new Error("No statements in block. Cannot replace last statement.");u(this,ee)[u(this,ee).length-1]=e}updateLastStatement(e){const n=this.getLastStatement();if(!n.isBlockStatement())throw new Error("The last statement is not a block statement.");for(const s of e.getExpressions())s.setBlockId(this.getId()),s.setScopeId(this.getScope().getId());n.addStatement(e)}getStatements(){return u(this,ee)}hasChild(e){if(this===e)return!0;{let n=e.getParentBlock();for(;n!==void 0;){if(n===this)return!0;n=n.getParentBlock()}return!1}}getBlockContainingLineNumber(e){if(u(this,ee).length===0&&console.log("stop"),!(u(this,ee)[0].getFirstLineNumber()>e||this.getLastStatement().getLastLineNumber()<e)){for(let n of u(this,ge))if(n.getBlockContainingLineNumber()!==void 0)return n;return this}}getLastExecutedStatements(){let e=[];for(let n of u(this,ge))n.isScopeBlock()||(e=e.concat(n.getLastExecutedStatements()));for(let n=0;n<u(this,ee).length;n++)if(!u(this,ee)[n].isBlockStatement()){if(n===u(this,ee).length-1)e.push(u(this,ee)[n]);else if(!u(this,ee)[n].isBlank()&&u(this,ee)[n].getFirstExpression().isOneOf([t.ReturnStatement,t.BreakKeyword])){e.push(u(this,ee)[n]);break}}return e}alwaysReturnsAValue(){if(u(this,Ke)===t.DocumentDefinition)return!1;if(u(this,ge).length===0){const e=this.getLastExecutedStatements();return e.length===1&&!e[0].isBlank()&&e[0].getFirstExpression().is(t.ReturnStatement)}else{if(this.hasTopLevelReturn())return!0;let e=!1,n=u(this,ge).length-1;for(;n>=0;){if(u(this,ge)[n].getBlockEntity()===t.ElseDefinition&&u(this,ge)[n].alwaysReturnsAValue())e=!0;else if(e&&u(this,ge)[n].getBlockEntity()===t.ElifDefinition&&u(this,ge)[n].alwaysReturnsAValue())e=!0;else{if(e&&u(this,ge)[n].getBlockEntity()===t.IfDefinition&&u(this,ge)[n].alwaysReturnsAValue())return!0;e=!1}n--}return!1}}hasTopLevelReturn(){for(let e of u(this,ee))if(!e.isBlockStatement()&&!e.isBlank()&&e.getFirstExpression().is(t.ReturnStatement))return!0;return!1}checkRules(e){super.checkRules(e);for(const n of e.getChildBlocks())n.checkRules(n)}checkForCounterRules(e){super.checkForCounterRules(e);for(const n of e.getChildBlocks())n.checkForCounterRules(n)}toJSON(){return{id:this.getId(),startLine:this.getStartLine(),children:u(this,ge).map(e=>e.toJSON())}}toTree(){return{id:this.getId(),statements:u(this,ee).map(e=>e.toJSON()),children:u(this,ge).map(e=>e.toTree())}}static blockFactory(e=t.DocumentDefinition,n=void 0,s=0){switch(e){case t.DocumentDefinition:case t.FunctionDefinition:case t.ClassDefinition:case t.ListComprehension:return new zn(e,n,s);default:return new $o(e,n,s)}}}Ke=new WeakMap,bt=new WeakMap,ge=new WeakMap,ss=new WeakMap,ee=new WeakMap,$=new WeakSet,hr=function(e){var o;const n=[];let s=e.getStatements();s.length===1&&s[0].isBlockStatement()&&(s=s[0].getStatements().slice(1));for(let a=0;a<s.length;a++){const h=s[a].getFirstExpression();if(h.is(t.WhileDefinitionStatement)&&m(o=e,$,gr).call(o,s[a])){const p=s[a].getDefinitionStatement().getFirstExpression();if(n.push(O.createStatementSymptom(I.InfiniteLoop,[p],0,0)),a<s.length-1){const w=qn(s.slice(a+1));n.push(O.createStatementSymptom(I.UnreachableInfiniteLoop,w,0,w.length-1,{infiniteLoopLine:h.getStartLineNumber()}))}}if(At(h)&&a<s.length-1){const p=s.slice(a+1),w=qn(p),S=h.getFirstExpressionOf([t.ReturnKeyword,t.BreakKeyword,t.ExitFunction,t.SysExit,t.QuitFunction]),F=e.getScope();n.push(O.createStatementSymptom(I.UnreachableExit,w,0,w.length-1,{exitKeyword:S!==void 0?S.getTextValue():"undefined",functionBlock:F!==void 0?F.getId():"undefined"}))}}return n},fr=function(e){const n=[];let s=e.getStatements();s.length===1&&s[0].isBlockStatement()&&(s=s[0].getStatements().slice(1));for(let o=0;o<s.length;o++){const a=s[o].getFirstExpression(),h=s[o].getExpressions();if(At(a)&&o===s.length-1){const p=a.getFirstExpressionOf([t.ReturnKeyword,t.BreakKeyword,t.ExitFunction,t.SysExit,t.QuitFunction]),w=e.getScope();p.getTextValue()==="return"&&n.push(O.createStatementSymptom(k.ReturnLast,h,0,h.length-1,{functionBlock:w!==void 0?w.getId():"undefined"}))}}return n},gr=function(e){const o=e.getDefinitionStatement().getFirstExpression().getVariableExpressions();for(const a of e.getStatements()){const h=a.getExpressions();for(const p of h){if(At(p))return!1;const w=p.getVariableExpressions().filter(F=>F.isAssignedOrChanged()),S=new Set(w.map(F=>F.getTextValue()));for(const F of o)if(S.has(F.getTextValue()))return!1}}return!0},pr=function(e){const n=[];for(const s of e.getChildBlocks())if(s.getBlockEntity()===t.IfDefinition&&s.isBranchOfExhaustiveConditional()&&s.hasTopLevelExit()){const o=s.getSiblingConditionalBranches();let a=!0,h=-1;for(const p of o){if(!p.hasTopLevelExit()){a=!1;break}p.getBlockEntity()===t.ElseDefinition&&(h=p.getStartLine())}if(a&&h>0){const p=e.getStatements().filter(w=>w.getFirstLineNumber()>h);if(p.length>0){const w=qn(p);n.push(O.createStatementSymptom(I.UnreachableExhaustiveConditional,w,0,w.length-1))}}}return n},mr=function(e){var a,h,p,w;const n=[];let s=e.getStatements();s.length===1&&s[0].isBlockStatement()&&(s=s[0].getStatements().slice(1));let o=[];for(let S=0;S<s.length-1;S++){const F=s[S].getFirstExpression(),N=s[S+1].getFirstExpression();if(F.is(t.IfDefinitionStatement)&&N.is(t.IfDefinitionStatement)&&!m(a=e,$,Hi).call(a,s[S])&&!m(h=e,$,Hi).call(h,s[S+1]))o.length===0&&o.push(s[S]),o.push(s[S+1]);else if(o.length>0){const E=m(p=e,$,zi).call(p,o);E!==void 0&&n.push(E),o=[]}}if(o.length>0){const S=m(w=e,$,zi).call(w,o);S!==void 0&&n.push(S)}return n},wr=function(e){var a,h;const n=[];let s=e.getStatements();s.length===1&&s[0].isBlockStatement()&&(s=s[0].getStatements().slice(1));let o=[];for(let p=0;p<s.length-1;p++){const w=s[p].getFirstExpression(),S=s[p+1].getFirstExpression();if(w.isOneOf([t.IfDefinitionStatement,t.ElifDefinitionStatement])&&S.isOneOf([t.ElifDefinitionStatement,t.ElseDefinitionStatement]))o.length===0&&o.push(s[p]),o.push(s[p+1]);else if(o.length>0){const F=m(a=e,$,ji).call(a,o);F!==void 0&&n.push(F),o=[]}}if(o.length>0){const p=m(h=e,$,ji).call(h,o);p!==void 0&&n.push(p)}return n},ji=function(e){if(e.length===0)return;const n=qn(e);return O.createStatementSymptom(k.IfElif,n,0,n.length-1,{branches:e.map(s=>({lineNumber:s.getFirstExpression().getStartLineNumber(),docIndex:s.getFirstExpression().getDocumentStartIndex(),text:s.getFirstExpression().getTextValue()}))})},Hi=function(e){const n=e.getStatements().slice(1);for(const s of n)if(!s.isBlockStatement()&&At(s.getFirstExpression()))return!0;return!1},zi=function(e){if(e.length===0)return;const n=[];let s=[];for(let a=0;a<e.length-1;a++){let h=e[a].getFirstExpression().getCondition();h=h.length===1&&h[0].is(t.GroupStatement)?h[0].getContents():h;let p=e[a+1].getFirstExpression().getCondition();p=p.length===1&&p[0].is(t.GroupStatement)?p[0].getContents():p,m(this,$,Qi).call(this,h,p)&&m(this,$,Qi).call(this,p,h)?((s.length===0||s[s.length-1].docIndex!==e[a].getFirstExpression().getDocumentStartIndex())&&s.push({lineNum:e[a].getFirstExpression().getStartLineNumber(),docIndex:e[a].getFirstExpression().getDocumentStartIndex()}),s.push({lineNum:e[a+1].getFirstExpression().getStartLineNumber(),docIndex:e[a+1].getFirstExpression().getDocumentStartIndex()})):s.length>0&&(n.push(s),s=[])}s.length>0&&(n.push(s),s=[]);const o=qn(e);return O.createStatementSymptom(I.SequentialIfs,o,0,o.length-1,{branchMatches:n})},Qi=function(e,n){if(e.length!==n.length)return!1;for(const s of e){let o=!1;for(const a of n)if(s.matchesPattern(a)){o=!0;break}if(!o)return!1}return!0},Sr=function(e){var a,h,p,w;const n=S=>{try{const N=S.getFirstExpression().getCondition();if(N.length>0)return N.map(E=>E.getTextValue()).join(" ")}catch{return""}},s=[];let o=e.getStatements();o.length===1&&o[0].isBlockStatement()&&o[0].getFirstExpression().getBlockId()===e.getId()&&(o=o[0].getStatements().slice(1));for(let S=0;S<o.length-1;S++){let F={};const N=o[S].getFirstExpression(),E=o[S+1].getFirstExpression();if(N.is(t.IfDefinitionStatement)){const G=o[S].getStatements();if(E.is(t.ElseDefinitionStatement)){const M=o[S+1].getStatements();if(G.length===2&&M.length===2&&m(a=e,$,Zi).call(a,G[1],M[1])){const ht=n(G[0]);F={form:wi,condition:ht}}else if(G.length===2&&M.length===2&&m(h=e,$,Xi).call(h,G[1],M[1])){const ht=n(G[0]);F={form:Si,variableAssigned:G[1].getFirstExpression().getTargetVariables()[0].getTextValue(),condition:ht}}}else if(G.length===2&&m(p=e,$,Zi).call(p,G[1],o[S+1])){const M=n(G[0]);F={form:wi,condition:M}}else if(G.length===2&&m(w=e,$,Xi).call(w,G[1],o[S+1])){const M=n(G[0]);F={form:Si,variableAssigned:G[1].getFirstExpression().getTargetVariables()[0].getTextValue(),condition:M}}if(F.hasOwnProperty("form")){const M=[...o[S].getExpressions(),...o[S+1].getExpressions()];s.push(O.createStatementSymptom(I.OneLineConditional,M,0,M.length-1,F))}}}return s},Xi=function(e,n){const s=e.getFirstExpression(),o=n.getFirstExpression();if(s.getDataType()===d.Bool&&o.getDataType()===d.Bool&&s.is(t.AssignmentStatement)&&o.is(t.AssignmentStatement)){const a=m(this,$,Rs).call(this,s.getAssignedValues()),h=m(this,$,Rs).call(this,o.getAssignedValues()),p=s.getTargetVariables(),w=o.getTargetVariables();return a.length!==1||h.length!==1||p.length!==1||w.length!==1?!1:p[0].getTextValue()===w[0].getTextValue()&&m(this,$,Yi).call(this,a[0],h[0])}return!1},Zi=function(e,n){const s=e.getFirstExpression(),o=n.getFirstExpression();if(s.getDataType()===d.Bool&&o.getDataType()===d.Bool&&s.is(t.ReturnStatement)&&o.is(t.ReturnStatement)){const a=m(this,$,Rs).call(this,s.getReturnedValue()),h=m(this,$,Rs).call(this,o.getReturnedValue());return a.length!==1||h.length!==1?!1:m(this,$,Yi).call(this,a[0],h[0])}return!1},Yi=function(e,n){return e.is(t.TrueType)&&n.is(t.FalseType)||e.is(t.FalseType)&&n.is(t.TrueType)},Rs=function(e){return e.length!==1?e:e[0].is(t.GroupStatement)?e[0].getContents():e};class zn extends Jo{constructor(e=t.DocumentDefinition,n=void 0,s=0){if(e!==t.DocumentDefinition&&e!==t.FunctionDefinition&&e!==t.ClassDefinition&&e!==t.ListComprehension)throw new Error(`${e.name} is not a scope block`);super(e,n,s);l(this,"variableMap",new Map);l(this,"globalVars",new Set);l(this,"moduleMap",new Map);l(this,"userDefinedFunctionMap",new Map);l(this,"unconnectedFunctionCalls",new Map);l(this,"userDefinedClassMap",new Map);l(this,"unconnectedMethodCalls",new Map);b(this,Li);b(this,vi)}isScopeBlock(){return!0}getScope(){return this}addStatement(e){super.addStatement(e),Q.connectVariableUsages(e,this);const n=this.getParentBlock()!==void 0&&this.getBlockEntity()!==t.ListComprehension?this.getParentBlock().getScope():this;Q.connectUserDefinedFunctions(e,n!==void 0?n:this),Q.connectUserDefinedMethods(e,n!==void 0?n:this)}getVariableMap(){return this.variableMap}getModuleMap(){return this.moduleMap}getStatementToUpdate(e,n){if(this.getStatements().length>0&&this.getLastStatement().isBlockStatement())return this.getLastStatement().getLastLineNumber()!==n?this.getLastStatement().getBlockStatementForIndent(e):this.getLastStatement().getLastBlockStatement()}addUserDefinedFunction(e){if(e!==void 0){const n=e.getTextValue();if(this.userDefinedFunctionMap.set(n,e),this.unconnectedFunctionCalls.has(n)){for(let s of this.unconnectedFunctionCalls.get(n))e.addObserver(s);this.unconnectedFunctionCalls.delete(n)}}}addUserDefinedClass(e){this.userDefinedClassMap.set(e.name,e)}getUserDefinedFunctions(){return this.userDefinedFunctionMap}getUserDefinedClasses(){return this.userDefinedClassMap}getUnconnectedFunctionCalls(){return this.unconnectedFunctionCalls}getUnconnectedMethodCalls(){return this.unconnectedMethodCalls}addUnconnectedFunctionCall(e){const n=e.getFunctionName();this.unconnectedFunctionCalls.has(n)||this.unconnectedFunctionCalls.set(n,[]),this.unconnectedFunctionCalls.get(n).push(e)}addUnconnectedMethodCall(e){const n=e.getMethodName();this.unconnectedMethodCalls.has(n)||this.unconnectedMethodCalls.set(n,[]),this.unconnectedMethodCalls.get(n).push(e)}addGlobalVar(e){this.globalVars.add(e)}getGlobalVars(){return this.globalVars}findAllFunctions(){const e=new Map(this.getUserDefinedFunctions());let n=this.getParentBlock();for(;n!==void 0&&n.getScope()!==void 0;){n=n.getScope();const s=n.getUserDefinedFunctions();for(const[o,a]of s)e.set(o,a);n=n.getParentBlock()}return e}findAllModules(){const e=new Map(this.getModuleMap());let n=this.getParentBlock();for(;n!==void 0&&n.getScope()!==void 0;){n=n.getScope();const s=n.getModuleMap();for(const[o,a]of s)e.set(o,a);n=n.getParentBlock()}return e}}Li=new WeakMap,vi=new WeakMap;class qu extends zn{constructor(e,n){super(t.ClassDefinition,e,n.getIndentation());b(this,gn);y(this,gn,n.getFirstExpression().getDataType()),e.getScope().addUserDefinedClass(u(this,gn)),this.addStatement(n)}getClassType(){return u(this,gn)}toTree(){const e=this.getStatements();return{id:this.getId(),definition:e.length>0?e[0].toJSON():{},statements:e.slice(1).map(n=>n.toJSON())}}}gn=new WeakMap;const _s=class _s extends zn{constructor(e,n){super(t.FunctionDefinition,e,n.getIndentation());b(this,Ys);b(this,Ri);b(this,is);const s=n.getFirstExpression(),o=s.getEntity()===t.FunctionDefinitionStatement?s.getFunctionNameExpression():s.getMethodNameExpression();if(y(this,is,o!==void 0?o.getTextValue():"not parsed"),e.getScope().addUserDefinedFunction(o),s.is(t.MethodDefinitionStatement)&&s.getClassVar()&&e.getBlockEntity()===t.ClassDefinition){const h=e.getStatements()[0].getFirstExpression().getDataType();s.getClassVar().setDataType(h)}this.addStatement(n),this.addRules([m(this,Ys,br)])}getReturnType(){const n=this.getLastExecutedStatements().filter(s=>!s.isBlank()&&s.getFirstExpression().is(t.ReturnStatement)).map(s=>s.getFirstExpression().getDataType());return this.alwaysReturnsAValue()||n.push(d.None),Dt(n)}getFunctionName(){return u(this,is)}getFunctionExpression(){const e=this.getStatements();if(e.length>0&&e[0].getFirstExpression().is(t.FunctionDefinitionStatement))return e[0].getFirstExpression().getFunctionNameExpression()}toTree(){const e=this.getStatements();return{id:this.getId(),definition:e.length>0?e[0].toJSON():{},statements:e.slice(1).map(n=>n.toJSON())}}};Ri=new WeakMap,is=new WeakMap,Ys=new WeakSet,br=function(e){var o;const n=[],s=e.getFunctionExpression();if(s!==void 0){const a=e.getStatements(),h=m(o=_s,os,_i).call(o,a);h.length>0&&n.push(O.createStatementSymptom(I.FunctionPrints,[s],0,0,{printLines:h,functionReturns:s.getReturnType()!==d.None}))}return n},os=new WeakSet,_i=function(e){let n=[];for(let s=0;s<e.length;s++)if(e[s].isBlockStatement())n=n.concat(m(this,os,_i).call(this,e[s].getStatements()));else{const o=e[s].getFirstExpression();o.is(t.BuiltInFunctionCall)&&o.getFunctionEntity()===t.PrintFunction?n.push({lineNumber:o.getStartLineNumber(),followsReturn:s>0&&e[s].getFirstExpression().is(t.ReturnStatement),precedesReturn:s<e.length-1&&e[s+1].getFirstExpression().is(t.ReturnStatement),isReturned:!1,isEndOfExitBranch:s===e.length-1,blockId:o.getBlockId()}):o.is(t.ReturnStatement)&&o.getExpressionsOfKind(t.PrintFunction).length>0&&n.push({lineNumber:o.getStartLineNumber(),followsReturn:!1,precedesReturn:!1,isReturned:!0,isEndOfExitBranch:s===e.length-1,blockId:o.getBlockId()})}return n},b(_s,os);let Ti=_s;class ju extends zn{constructor(i,e){super(t.ListComprehension,i);const n=new Pt(e.getTextValue(),e.getStartLineNumber(),new Go(""),[e]);this.addStatement(n)}getId(){const i=this.getStatements();return`${super.getId()}-${i.length>0&&!i[0].isBlank()?i[0].getFirstExpression().getDocumentStartIndex():"-1"}`}}class $o extends Jo{constructor(e,n){const s=n.getFirstExpression().getBlockEntity();if(s===t.DocumentDefinition||s===t.FunctionDefinition||s===t.ClassDefinition||s===t.ListComprehension)throw new Error(`${s.name} is a scope block`);super(s,e,n.getIndentation());b(this,z);l(this,"conditionalSiblings",new Set);this.addStatement(n),this.addRules([m(this,z,Fr),m(this,z,Or),m(this,z,yr),m(this,z,Cr)]),this.addCounterRules([m(this,z,Mr),m(this,z,Nr),m(this,z,Tr)])}isScopeBlock(){return!1}isBranchBlock(){return!0}getLastExecutedStatements(){let e=[];for(let s of this.getChildBlocks())e=e.concat(s.getLastExecutedStatements());const n=m(this,z,Qe).call(this);for(let s=0;s<n.length;s++)if(!n[s].isBlockStatement()){if(s===n.length-1&&this.isBranchOfExhaustiveConditional())e.push(n[s]);else if(!n[s].isBlank()&&n[s].getFirstExpression().isOneOf([t.ReturnStatement,t.BreakKeyword])){e.push(n[s]);break}}return e}hasTopLevelReturn(){const e=m(this,z,Qe).call(this);for(let n of e)if(!n.isBlockStatement()&&!n.isBlank()&&n.getFirstExpression().is(t.ReturnStatement))return!0;return!1}hasTopLevelExit(){const e=m(this,z,Qe).call(this);for(let n of e)if(!n.isBlockStatement()&&!n.isBlank()&&n.getExpressions().filter(s=>At(s)).length>0)return!0;return!1}isBranchOfConditional(){return this.getBlockEntity()===t.IfDefinition||this.getBlockEntity()===t.ElifDefinition||this.getBlockEntity()===t.ElseDefinition||this.getBlockEntity()===t.TryDefinition||this.getBlockEntity()===t.ExceptDefinition||this.getBlockEntity()===t.FinallyDefinition}isBranchOfExhaustiveConditional(){if(this.getBlockEntity()===t.ElseDefinition)return m(this,z,Es).call(this,t.IfDefinition);if(this.getBlockEntity()===t.ElifDefinition){let e=!1,n=!1;for(const s of this.conditionalSiblings)if(s.getBlockEntity()===t.IfDefinition?e=!0:s.getBlockEntity()===t.ElseDefinition&&(n=!0),e&&n)return!0}else{if(this.getBlockEntity()===t.IfDefinition)return m(this,z,Es).call(this,t.ElseDefinition);if(this.getBlockEntity()===t.TryDefinition)return m(this,z,Es).call(this,t.ExceptDefinition);if(this.getBlockEntity()===t.ExceptDefinition)return m(this,z,Es).call(this,t.TryDefinition)}return!1}getSiblingConditionalBranches(){return this.conditionalSiblings}addSibling(e){if(!this.isBranchOfConditional())throw new Error("Cannot add a sibling to a branch that is not a conditional");if(!e.isBranchOfConditional())throw new Error("Trying to add a non-conditional branch as a sibling.");this.conditionalSiblings.add(e)}}z=new WeakSet,Qe=function(){const e=this.getStatements();return e.length,e[0].getStatements()},Es=function(e){for(const n of this.conditionalSiblings)if(n.getBlockEntity()===e)return!0;return!1},Ir=function(){const e=m(this,z,Qe).call(this).flatMap(s=>s.getExpressions());return fe(e,!0)},yr=function(e){return[]},Fr=function(e){var s;const n=[];if(e.getBlockEntity()===t.ForDefinition||e.getBlockEntity()===t.WhileDefinition&&e.hasTopLevelExit())for(const o of m(s=e,z,Qe).call(s))!o.isBlockStatement()&&!o.isBlank()&&At(o.getFirstExpression())&&n.push(O.createStatementSymptom(I.LoopReturn,[o.getFirstExpression()],0,0,{loopType:e.getBlockEntity().name,exitLevel:qc,exitTypes:[o.getFirstExpression().isOneOf([t.ReturnKeyword,t.ReturnStatement])?"return":o.getFirstExpression().getTextValue()]},e.getId()));else if(e.isBranchOfExhaustiveConditional()&&e.getBlockEntity()===t.IfDefinition&&e.hasTopLevelExit()&&(e.getParentBlock()!==void 0&&e.getParentBlock().getBlockEntity()===t.ForDefinition||e.getParentBlock().getBlockEntity()===t.WhileDefinition)){for(const p of e.getSiblingConditionalBranches())if(!p.hasTopLevelExit())return n;const a=e.getParentBlock().getStatements()[0].getExpressions(),h=a.flatMap(p=>p.getExpressionsOfKind(t.ReturnKeyword).concat(p.getExpressionsOfKind(t.BreakKeyword),p.getExpressionsOfKind(t.ExitFunction),p.getExpressionsOfKind(t.SysExit),p.getExpressionsOfKind(t.QuitFunction))).map(p=>p.getTextValue());n.push(O.createStatementSymptom(I.LoopReturn,[a[0]],0,0,{loopType:e.getParentBlock().getBlockEntity().name,exitLevel:jc,exitTypes:h},e.getParentBlock().getId()))}return n},Nr=function(e){const n=[],s=e.getParentBlock()!==void 0&&e.getParentBlock().getBlockEntity()===t.ForDefinition||e.getParentBlock().getBlockEntity()===t.WhileDefinition;if(e.hasTopLevelReturn()&&e.isBranchOfConditional()&&s){if(e.isBranchOfExhaustiveConditional()){let a=!0;for(const h of e.getSiblingConditionalBranches())if(!h.hasTopLevelReturn()){a=!1;break}if(a)return n}const o=e.getParentBlock().getStatements()[0].getExpressions();n.push(O.createStatementSymptom(k.LoopExitsSometimes,o,0,o.length-1,{loopType:e.getParentBlock().getBlockEntity().name,loopBlock:e.getParentBlock().getId()}))}return n},Cr=function(e){var s,o;const n=[];if(e.getBlockEntity()===t.WhileDefinition){const a=m(s=e,z,Qe).call(s)[0].getFirstExpression(),h=new Set(a.getVariableExpressions().map(F=>F.getTextValue())),p=m(o=e,z,Qe).call(o).slice(1),w=new Map,S=new Map;for(const F of h)w.set(F,!1),S.set(F,[]);for(const F of p)for(const N of F.getExpressions()){const E=N.getExpressionsOfKind(t.ChangeStatement).flatMap(M=>M.getTargetVariables()).filter(M=>h.has(M.getTextValue())),G=N.getExpressionsOfKind(t.AssignmentStatement).flatMap(M=>M.getTargetVariables()).filter(M=>h.has(M.getTextValue()));for(const M of E)w.has(M.getTextValue())&&w.set(M.getTextValue(),!0);for(const M of G)S.has(M.getTextValue())&&S.get(M.getTextValue()).push(M)}for(const F of h)if(!w.get(F)&&S.get(F).length>0){let N=[],E=!1;for(const G of S.get(F)){const M=G.getParent().getAssignedValues();if(M.length===1&&M[0].is(t.IntLiteral))N.push(G);else{E=!0;break}}if(!E)for(const G of N)n.push(O.createStatementSymptom(I.WhileLoopVarAssignedIntLiteral,[G],0,0))}}return n},Or=function(e){var s,o,a;const n=[];if(e.getBlockEntity()===t.WhileDefinition){const h=m(s=e,z,Qe).call(s)[0].getFirstExpression(),p=new Set(h.getVariableExpressions());if(p.size>0){const w=m(o=e,z,gi).call(o,p),S=new Set,F=new Map;for(const N of p){const E=w.get(N);for(const G of E){G===e&&S.add(N);const M=G.getNearestParentOfAny([t.WhileDefinition,t.ForDefinition]);M!==void 0&&M!==e&&e.hasChild(M)?(F.has(N)||F.set(N,new Set),F.get(N).add(M)):M!==void 0&&M===e&&S.add(N)}}S.size===0&&n.push(O.createStatementSymptom(I.LoopVarNotModified,[h],0,0,{unmodifiedVars:Array.from(p).map(N=>N.getTextValue()),loopText:m(a=e,z,Ir).call(a)},e.getId()));for(const[N,E]of F){const G=O.createStatementSymptom(I.LoopVarModifiedInChildLoop,[N],0,0,{modifiedIn:[],varDataType:[]},e.getId());for(const M of E)G.getAdditionalInfo().modifiedIn.push({loopType:M.getBlockEntity().name,startLine:M.getStatements()[0].getFirstLineNumber(),varDataType:N.getDataType().name});n.push(G)}}}return n},Tr=function(e){var s,o;const n=[];if(e.getBlockEntity()===t.WhileDefinition){const a=m(s=e,z,Qe).call(s)[0].getFirstExpression(),h=new Set(a.getVariableExpressions());if(h.size>0){const p=m(o=e,z,gi).call(o,h),w=new Set;for(const S of h){const F=p.get(S);for(const N of F)N===e&&w.add(S)}w.size>0&&n.push(O.createStatementSymptom(k.WhileLoopVarModified,[a],0,0,{},e.getId()))}}return n},gi=function(e){var o;const n=m(this,z,Qe).call(this).filter(a=>!a.isBlockStatement()),s=new Map;for(const a of e)s.set(a,new Set);for(const a of n){const h=a.getExpressions();for(const p of h){const w=p.getVariableExpressions().filter(F=>F.isAssignedOrChanged()),S=new Set(w.map(F=>F.getTextValue()));for(const F of e)S.has(F.getTextValue())&&s.get(F).add(this)}}for(const a of this.getChildBlocks().filter(h=>h.isBranchBlock())){const h=m(o=a,z,gi).call(o,e);for(const p of e)h.get(p).size>0&&s.get(p).add(...h.get(p))}return s},Mr=function(e){var s;const n=[];if(e.getBlockEntity()===t.ForDefinition){const o=m(s=e,z,Qe).call(s)[0].getFirstExpression();if(o.hasChildExpressions()){const a=o.getExpressionsOfKind(t.RangeFunction).length>0,h=o.getExpressionsOfKind(t.EnumerateFunction).length>0;(a||h)&&n.push(O.createStatementSymptom(k.CounterLoop,[o],0,0,{isNestedInWhile:e.hasParentOfEntity(t.WhileDefinition),counterType:a?t.RangeFunction.name:t.EnumerateFunction.name}))}}return n};class Qn{constructor(i,e,n,{multilineCommentDelimiter:s=void 0,stringLiteralDelimiter:o=void 0,groupCharCounts:a={"(":0,"[":0,"{":0},lastLineExpressions:h=[],startFrom:p=0,moduleNames:w=[],varsWithTypeNames:S=[],classDefinitionInProgress:F=!1}={}){b(this,C);b(this,se,[]);b(this,Wt,[]);b(this,rs,!1);b(this,pn,!1);b(this,Ze);b(this,Pe);b(this,K);b(this,qt);b(this,as);b(this,Ve);b(this,Ee);b(this,ye);b(this,It);b(this,Ei,[]);y(this,K,i),y(this,It,u(this,K).length-1),y(this,Ve,e),y(this,Ee,n),y(this,Ze,s),y(this,Pe,o),y(this,ye,a),y(this,qt,m(this,C,Dr).call(this,i)),y(this,as,new Go(i.substring(0,u(this,qt)))),y(this,Wt,h),u(this,K).length>0?m(this,C,xr).call(this,p>0?p:u(this,qt),S,w,F):m(this,C,eo).call(this)}getText(){return u(this,K)}getLineNumber(){return u(this,Ve)}getExpressions(){return u(this,se)}getDocumentStartIndex(){return u(this,Ee)}getLineEndIndex(){return u(this,It)}getIndentation(){return u(this,qt)}getIndent(){return u(this,as)}continuesOnNextLine(){return u(this,rs)}followedBySeparateStatement(){return u(this,pn)}hasOpenComment(){return u(this,Ze)!==void 0}getCommentDelimiter(){if(!this.hasOpenComment())throw new Error("This line of source code does not have an open multiline comment delimiter. Line",u(this,Ve));return u(this,Ze)}hasOpenString(){return u(this,Pe)!==void 0}getStringLiteralDelimiter(){if(!this.hasOpenString())throw new Error("This line of source code does not have an open string literal delimiter. Line",u(this,Ve));return u(this,Pe)}hasOpenGroupChars(){return Object.entries(u(this,ye)).filter(([i,e])=>e>0).length>0}getOpenGroupChars(){return u(this,ye)}}se=new WeakMap,Wt=new WeakMap,rs=new WeakMap,pn=new WeakMap,Ze=new WeakMap,Pe=new WeakMap,K=new WeakMap,qt=new WeakMap,as=new WeakMap,Ve=new WeakMap,Ee=new WeakMap,ye=new WeakMap,It=new WeakMap,Ei=new WeakMap,C=new WeakSet,xr=function(i,e,n,s){u(this,Ze)!==void 0?i=m(this,C,to).call(this,u(this,Ze),0)+1:u(this,Pe)!==void 0&&(i=m(this,C,no).call(this,A.getCategory(u(this,Pe).charCodeAt(0)),0)+1);for(let o=i;o<u(this,K).length;o++){const a=A.getCategory(u(this,K).charCodeAt(o));if(a===A.Hash)o=u(this,K).length-1;else if(a.isQuote())o=m(this,C,Br).call(this,a,o);else if(m(this,C,Er).call(this,a))o=m(this,C,Ur).call(this,o,e,n,s);else if(m(this,C,Hr).call(this,a,o,o===0||A.getCategory(u(this,K).charCodeAt(o-1))===A.Space))o=m(this,C,Qr).call(this,o);else if(m(this,C,Xr).call(this,a))o=m(this,C,Zr).call(this,o);else if(m(this,C,Lr).call(this,a))o=m(this,C,Rr).call(this,o);else if(m(this,C,Yr).call(this,a)&&(m(this,C,_r).call(this,o),o<u(this,It)&&m(this,C,ea).call(this,a))){y(this,It,o),m(this,C,Ar).call(this);break}}m(this,C,eo).call(this)},Dr=function(i){return Math.max(i.search(/\S/),0)},eo=function(){(u(this,Ze)!==void 0||u(this,Pe)!==void 0||this.hasOpenGroupChars()||m(this,C,tt).call(this)&&m(this,C,Re).call(this).isOneOf([t.ContinuationLine,t.AddOperator,t.Comma]))&&y(this,rs,!0)},Ar=function(){const i=u(this,K).substring(u(this,It)+1).trim();i.length===0||A.getCategory(i.charCodeAt(0))===A.Hash?y(this,pn,!1):y(this,pn,!0)},en=function(i){for(let e of u(this,se))if(e.is(i))return!0;return!1},tt=function(){return u(this,se).length>0},Re=function(){if(u(this,se).length===0)throw new Error("Attempted to get last expression when there are no expressions.");return u(this,se)[u(this,se).length-1]},Br=function(i,e){return m(this,C,Vr).call(this,i,e)?m(this,C,kr).call(this,e):m(this,C,no).call(this,i,e)},kr=function(i){const e=u(this,K).substring(i,i+3);let n=i+3;return m(this,C,to).call(this,e,n)},to=function(i,e){if(e<u(this,K).length){const s=m(this,C,so).call(this,u(this,K)).substring(e).indexOf(i);if(s>-1)return y(this,Ze,void 0),e+s+2}return y(this,Ze,i),u(this,K).length-1},no=function(i,e){const n=m(this,C,so).call(this,u(this,K)),s=u(this,Pe)===void 0?m(this,C,Pr).call(this,i,e,n):u(this,Pe);let o=u(this,Pe)===void 0?e+s.length:e,a=o+n.substring(o).indexOf(s);a===-1||a<o?(y(this,Pe,s),a=u(this,K).length):y(this,Pe,void 0);const h=Math.min(u(this,K).length-1,a+s.length-1),p=u(this,K).substring(e,h+1),w=new qo(p,u(this,Ve),u(this,Ee)+e,e,u(this,Ee)+h);if(m(this,C,tt).call(this)&&m(this,C,Re).call(this).is(t.F)){const S=[m(this,C,Re).call(this),w],F=new nd(fe(S),S);u(this,se)[u(this,se).length-1]=F}else u(this,se).push(w);return h},Pr=function(i,e,n){const s=i===A.SingleQuote?"'":'"';return e<n.length-2&&A.getCategory(n.charCodeAt(e))===i&&A.getCategory(n.charCodeAt(e+1))===i&&A.getCategory(n.charCodeAt(e+2))===i?s+s+s:s},so=function(i){return i.replace(/\\.{1}/g,"  ")},Vr=function(i,e){return m(this,C,tt).call(this)&&m(this,C,Re).call(this).is(t.AssignmentOperator)||u(this,ye)["("]>0||u(this,ye)["["]>0||u(this,ye)["{"]>0?!1:i.isQuote()&&u(this,K).length>e+2&&A.getCategory(u(this,K).charCodeAt(e))===i&&A.getCategory(u(this,K).charCodeAt(e+1))===i&&A.getCategory(u(this,K).charCodeAt(e+2))===i},Lr=function(i){return i===A.At},vr=function(i){let e=i;for(let n=i+1;n<u(this,K).length;n++){const s=A.getCategory(u(this,K).charCodeAt(n));if(s!==A.Space&&s!==A.NewLine)e=n;else break}return u(this,K).substring(i,e+1)},Rr=function(i){const e=m(this,C,vr).call(this,i),n=new X(t.Decorator,c.SyntacticSugar),s=rn(e,n,u(this,Ve),u(this,Ee)+i,i);return u(this,se).push(s),i+e.length-1},Er=function(i){return i===A.Underscore||i===A.Letter},Ur=function(i,e,n,s){let o=m(this,C,Gr).call(this,i),a=m(this,C,Jr).call(this,o,m(this,C,jr).call(this,i+o.length),e,n,s);const h=rn(o,a,u(this,Ve),u(this,Ee)+i,i);return m(this,C,tt).call(this)&&(a.entity===t.InKeyword&&m(this,C,Re).call(this).is(t.NotOperator)||a.entity===t.NotOperator&&m(this,C,Re).call(this).is(t.IsKeyword))?(o=fe([m(this,C,Re).call(this),h]),a=new X(a.entity===t.InKeyword?t.NotInKeyword:t.IsNotKeyword,c.ComparisonOperators),i=m(this,C,Re).call(this).getDocumentStartIndex()-u(this,Ee),u(this,se)[u(this,se).length-1]=rn(o,a,u(this,Ve),m(this,C,Re).call(this).getDocumentStartIndex())):u(this,se).push(h),i+o.length-1},Gr=function(i){let e=i;for(let n=i+1;n<u(this,K).length;n++){const s=A.getCategory(u(this,K).charCodeAt(n));if(s===A.Underscore||s===A.Letter||s===A.Digit)e=n;else break}return u(this,K).substring(i,e+1)},Jr=function(i,e,n,s,o){const a=Xe(i);if(m(this,C,tt).call(this)){const h=m(this,C,Re).call(this);if(h.is(t.FunctionDefinition))return o?new X(t.MethodName,c.Identifiers):new X(t.FunctionName,c.Identifiers);if(h.is(t.ClassDefinition))return new X(t.ClassName,c.Identifiers);if(h.is(t.FromKeyword)||m(this,C,en).call(this,t.ImportKeyword)&&!m(this,C,en).call(this,t.FromKeyword))if(h.is(t.AsKeyword)&&u(this,se).length>1){const p=u(this,se)[u(this,se).length-2];return new X(p.getEntity(),p.getCategory())}else return a.entity===t.Unknown?new X(t.ModuleName,c.Identifiers):a;else if(m(this,C,Kn).call(this)){if(e!=="(")return a.category===c.Unknown?new X(t.PropertyName,c.ModuleProperties):a;{const p=this.getExpressions();if(p.length>=2){const w=p[p.length-2];return w.is(c.BuiltInModules)&&a.category===c.ModuleFunctions||a.category===c.BuiltInMethods?a:w.is(t.ModuleName)?new X(t.MethodName,c.ModuleFunctions):new X(t.MethodName,c.OtherMethods)}}}else{if(m(this,C,en).call(this,t.FromKeyword)&&m(this,C,en).call(this,t.ImportKeyword))return m(this,C,qr).call(this,i);if((i==="sep"||i==="end")&&!(h.is(t.Comma)&&e==="="))return new X(t.VariableName,c.Identifiers);if(a.entity!==t.VariableName&&Qc(i)&&m(this,C,en).call(this,t.FunctionDefinition)&&h.isOneOf([t.OpenParenthesis,t.Comma]))return new X(t.VariableName,c.Identifiers)}}else if(i==="sep"||i==="end")return new X(t.VariableName,c.Identifiers);return e===t.OpenParenthesis.name?m(this,C,$r).call(this,a,i):(a.entity===t.R||a.entity===t.F)&&e!=="'"&&e!=='"'?new X(t.VariableName,c.Identifiers):a.category===c.Types&&n.includes(i)?new X(t.VariableName,c.Identifiers):a.category===c.BuiltInModules&&!s.includes(i)?new X(t.VariableName,c.Identifiers):a.category===c.BuiltInFunctions&&vo(i).entity!==t.Unknown&&e!=="="?n.includes(i)?new X(t.VariableName,c.Identifiers):vo(i):a.category===c.OtherKeywords||a.category===c.BlockDefinitions||a.category===c.LogicalOperators||a.category===c.BuiltInExceptions||a.category===c.BuiltInModules||a.category===c.Types||a.category===c.SpecialVariables||a.category===c.ComparisonOperators?a:a.category===c.Unknown&&s.includes(i)?new X(t.ModuleName,c.Identifiers):new X(t.VariableName,c.Identifiers)},$r=function(i,e){return m(this,C,Kr).call(this,i)||m(this,C,Wr).call(this,i)?i:i.entity===t.Format?m(this,C,Kn).call(this)?new X(t.Format,c.BuiltInMethods):new X(t.FormatFunction,c.BuiltInFunctions):m(this,C,Kn).call(this)?e==="exit"?Oi[e]:new X(t.MethodName,c.OtherMethods):Oi.hasOwnProperty(e)?Oi[e]:i.category!==c.BuiltInFunctions&&i.category!==c.BuiltInMethods&&i.category!==c.Unknown&&i.category!==c.ModuleFunctions?i:new X(t.FunctionName,c.Identifiers)},Kr=function(i){return i.category===c.BuiltInFunctions&&!m(this,C,Kn).call(this)},Wr=function(i){return(i.category===c.BuiltInMethods||i.category===c.MagicMethods||i.category===c.ModuleFunctions)&&m(this,C,Kn).call(this)},Kn=function(){return m(this,C,tt).call(this)&&m(this,C,Re).call(this).is(t.Dot)||!m(this,C,tt).call(this)&&u(this,Wt).length>0&&u(this,Wt)[u(this,Wt).length-1].is(t.Dot)},qr=function(i){if(u(this,se).length>=2&&u(this,se)[1].is(c.BuiltInModules)){let e=Xe(i);if(e.category===c.ModuleFunctions||e.category===c.ModuleProperties){const n=Ro.has(e.entity)?Ro.get(e.entity):void 0;return n&&m(this,C,en).call(this,n)?e:new X(t.NamedImport,c.Identifiers)}return e.entity===t.Unknown?new X(t.NamedImport,c.Identifiers):e}return new X(t.NamedImport,c.Identifiers)},rf=function(i,e){return new X(t.ModuleName,c.Identifiers)},jr=function(i){for(;A.getCategory(u(this,K).charCodeAt(i))===A.Space;)i++;return u(this,K).charAt(i)},Hr=function(i,e,n){if(i===A.Minus&&m(this,C,tt).call(this)&&!n&&m(this,C,Re).call(this).isOneOf([c.Identifiers,t.CloseBrace,t.CloseParenthesis,t.CloseSquareBracket,c.Properties,c.ModuleProperties]))return!1;let s=0,o=0,a=0,h=e;for(;h<u(this,K).length&&(i===A.Digit||i===A.Decimal||i===A.Minus&&h===e);)i===A.Digit?s++:i===A.Decimal?o++:a++,h++,i=A.getCategory(u(this,K).charCodeAt(h));return s>=1&&o<=1&&a<=1},zr=function(i){let e=i;for(let n=i+1;n<u(this,K).length;n++){const s=A.getCategory(u(this,K).charCodeAt(n));if(s===A.Digit||s===A.Decimal)e=n;else break}return u(this,K).substring(i,e+1)},Qr=function(i){const e=m(this,C,zr).call(this,i);return u(this,se).push(new Mi(e,u(this,Ve),u(this,Ee)+i,i)),i+e.length-1},Xr=function(i){return i===A.Equals||i===A.Exclamation||i===A.Minus||i===A.Plus||i===A.Asterisk||i===A.ForwardSlash||i===A.Modulo||i===A.GreaterThan||i===A.LessThan},Zr=function(i){let e=u(this,K).charAt(i),n=e,s=i;for(;(n==="!"||Xe(n).entity!==t.Unknown)&&s<u(this,K).length;)e=n,s++,n+=u(this,K).charAt(s);let o=Xe(e);return e==="*"&&m(this,C,tt).call(this)&&m(this,C,Re).call(this).is(t.ImportKeyword)&&(o=new X(t.ImportAll,c.OtherKeywords)),u(this,se).push(rn(e,o,u(this,Ve),u(this,Ee)+i,i)),i+e.length-1},Yr=function(i){return i!==A.Space&&i!==A.Tab},_r=function(i){let e=u(this,K).charAt(i);m(this,C,ta).call(this,e);const n=Xe(e);u(this,se).push(rn(e,n,u(this,Ve),u(this,Ee)+i,i))},ea=function(i){return i===A.Semicolon?!0:!!(i===A.Colon&&m(this,C,tt).call(this)&&u(this,se)[0].isOneOf([t.IfDefinition,t.ElifDefinition,t.ElseDefinition,t.FunctionDefinition,t.ClassDefinition,t.ForDefinition,t.WhileDefinition,t.TryDefinition,t.ExceptDefinition])&&u(this,ye)["{"]<=0&&u(this,ye)["("]<=0&&u(this,ye)["["]<=0)},ta=function(i){u(this,ye).hasOwnProperty(i)?u(this,ye)[i]++:i===")"?u(this,ye)["("]--:i==="]"?u(this,ye)["["]--:i==="}"&&u(this,ye)["{"]--};const ls=class ls{static createTree(i){let e=i.filter(n=>!n.is(t.ContinuationLine));return m(this,x,oa).call(this,i)?[m(this,x,aa).call(this,i)]:(e.length>1&&(e=m(this,x,ma).call(this,e),e=m(this,x,pa).call(this,e),e=m(this,x,ca).call(this,e),e=m(this,x,ga).call(this,e),e=m(this,x,wa).call(this,e),e=m(this,x,Sa).call(this,e),e=m(this,x,ba).call(this,e),e=m(this,x,Ia).call(this,e),e=m(this,x,ya).call(this,e),e=m(this,x,Na).call(this,e)),e)}static split(i,e){return this.splitMultiple(i,[e])}static splitMultiple(i,e){const n=[];let s=0,o=0,a=0,h=0;for(let p=0;p<i.length;p++)if(p===h&&i[p].isOneOf(e))h++;else if(i[p].isOneOf(e)&&p>h||p===i.length-1){if(s===0&&o===0&&a===0||p===i.length-1&&(s===1&&i[p].is(t.CloseParenthesis)||a===1&&i[p].is(t.CloseSquareBracket)||o===1&&i[p].is(t.CloseBrace))){const w=i.slice(h,i[p].isOneOf(e)?p:p+1);n.push(w),h=p+1}}else i[p].is(t.OpenParenthesis)?s++:i[p].is(t.CloseParenthesis)?s--:i[p].is(t.OpenBrace)?o++:i[p].is(t.CloseBrace)?o--:i[p].is(t.OpenSquareBracket)?a++:i[p].is(t.CloseSquareBracket)&&a--;return n}static connectVariableUsages(i,e){var w,S;const n=e.getScope();!i.isBlank()&&i.getFirstExpression().is(t.ImportStatement)&&m(w=ls,x,ia).call(w,i,n),i.isBlockStatement()&&!i.isBlank()&&i.getFirstExpression().is(t.ForDefinitionStatement)&&(e=m(S=ls,x,sa).call(S,e));const s=i.getVariableUsages(),o=n.getVariableMap(),a=n.findAllModules(),h=new Map(Array.from(a.values()).flatMap(F=>Array.from(F.getDirectImports()))),p=!i.isBlank()&&i.getFirstExpression().is(t.GlobalStatement);for(let[F,N]of s){if(e.getBlockEntity()===t.ClassDefinition&&N.length>0&&(N[0].getParent()===void 0||N[0].getParent().is(t.AssignmentStatement)&&N[0].getParent().getTargetVariables().includes(N[0]))){m(this,x,io).call(this,N[0],e.getClassType(),i,e,n);continue}let E=N.map(G=>new Uo(G,e,p));if(p&&n.addGlobalVar(F),o.has(F)){o.get(F).addUsages(E);for(const G of E){const M=G.getVariable().getParent();if(M&&M.is(t.PropertyCallExpression)&&M.getObject().getDataType().isCustom){const ht=M.getObject().getDataType();m(this,x,io).call(this,M.getProperty(),ht,i,e,n)}}}else{if(a.has(F))E[0].getVariable().setDataType(Js(a.get(F).getEntity()));else if(h.has(F)){const M=kt.has(h.get(F).entity)?kt.get(h.get(F).entity):d.Unknown;E[0].getVariable().setDataType(M)}const G=new Eo(E[0],i,e);if(E.length>1&&G.addUsages(E.slice(1)),m(this,x,na).call(this,e,F,G.getUsages()[0].getVariable())&&this.checkIfVariableExistsInParent(G,e))continue;o.set(F,G)}}}static makeGraphConnections(i){const e=i.filter(s=>!s.isBlank());if(e.length<=1)return;const n=e[e.length-1];if(!n.isBlank()){let s=e[e.length-2],o;if(s.isBlockStatement()){o=s.getDefinitionStatement().getExpressions();let a=s.getFirstExpression(),h=n.getFirstExpression();if(!(a.isOneOf([t.IfDefinitionStatement,t.ElifDefinitionStatement])&&h.isOneOf([t.ElseDefinitionStatement,t.ElifDefinitionStatement]))){const p=s.getExpressions();p[p.length-1].addConnection(n.getFirstExpression());const w=s.getStatements();w.length>1&&w[w.length-1].isBlockStatement()&&w[w.length-1].getDefinitionStatement().getFirstExpression().addConnection(n.getFirstExpression())}if(!h.isOneOf([t.ElifDefinitionStatement,t.ElseDefinitionStatement,t.ReturnStatement])&&a.isOneOf([t.IfDefinitionStatement,t.ElifDefinitionStatement,t.ElseDefinitionStatement])){const p=[];for(let w=e.length-2;w>=0;w--){const S=e[w].getFirstExpression();if(S.isOneOf([t.IfDefinitionStatement,t.ElifDefinitionStatement,t.ElseDefinitionStatement])&&(p.push(e[w]),S.is(t.IfDefinitionStatement)))break}for(const w of p)try{const S=w.getStatements();S[S.length-1].getFirstExpression().addConnection(n.getFirstExpression())}catch(S){console.log(S),console.log(w)}}}else o=s.getExpressions();o[0].addConnection(n.getFirstExpression())}}static connectUserDefinedFunctions(i,e){const n=e.findAllFunctions(),s=e.getRootBlock().getUserDefinedClasses(),o=i.getExpressions();for(let a of o){const h=a.getExpressionsOfKind(t.UserDefinedFunctionCall);for(let p of h){const w=p.getFunctionName();if(n.has(w)){const S=n.get(w);p.setDataType(S.getDataType()),S.addObserver(p)}else if(s.has(w)){const S=s.get(w);p.setDataType(S)}else e.addUnconnectedFunctionCall(p)}}}static connectUserDefinedMethods(i,e){const n=e.findAllFunctions();for(const[o,a]of n.entries())a.is(t.MethodName)||n.delete(o);const s=i.getExpressions();for(let o of s){const a=o.getExpressionsOfKind(t.UserDefinedMethodCall);for(let h of a){const p=h.getMethodName();if(n.has(p)){const w=n.get(p);h.setDataType(w.getDataType()),w.addObserver(h)}else e.addUnconnectedMethodCall(h)}}}static checkIfVariableExistsInParent(i,e){let n=e.getScope().getParentBlock();const s=i.getUsages()[0].getVariable();if(!i.isParameter()&&(e.getScope().getGlobalVars().has(i.getName())||!s.isAssignedOrChanged()||s.isObjectOfMethodCall()||s.isSubscripted()))for(;n!==void 0&&n.getScope()!==void 0;){const o=n.getScope().getVariableMap();if(o.has(i.getName())){const a=o.get(i.getName());i.setDefinedInBlock(a.getDefinedInBlock());const h=a.getUsages();return i.insertUsages(h),!0}n=n.getScope().getParentBlock()}return!1}static checkForListComp(i){const e=this.split(i,t.Comma);let n=[];for(let s=0;s<e.length;s++)s<e.length-1&&jn(e[s],t.ForDefinition)&&jn(e[s+1],t.InKeyword)?(n.push(e[s].concat(i[n.length+e[s].length],e[s+1])),s++):n.push(e[s]);return n}};x=new WeakSet,io=function(i,e,n,s,o){const a=i.getTextValue(),h=new Uo(i,s);if(e.attributes.has(a))e.attributes.get(a).addUsage(h);else{const p=o.getNearestParentOfAny([t.ClassDefinition]),w=new Eo(h,n,s);p&&p.getClassType().name===e.name?e.attributes.set(a,w):console.log("add to unconnected attribute tracking")}},na=function(i,e,n){let s=i.getScope();for(;s!==void 0;){if(s.getVariableMap().has(e)){if(!n.isAssignedOrChanged()||n.isObjectOfMethodCall()||n.isSubscripted())return!0}else if(s.getGlobalVars().has(e))return!0;s=s.getParentBlock(),s!==void 0&&(s=s.getScope())}return!1},sa=function(i){const e=i.getChildBlocks();return e.length>0&&e[e.length-1].getBlockEntity()===t.ForDefinition&&(i=e[e.length-1]),i},ia=function(i,e){const n=i.getRawExpressions(),s=e.getModuleMap(),o=[];let a=!1;for(const h of n)if(h.isOneOf([t.ModuleName,c.BuiltInModules]))if(a)for(const p of o)p.getEntity()===h.getEntity()&&p.setAlias(h.getTextValue());else{const p=new Ku(h.getTextValue(),h.getEntity());o.push(p)}else if(h.is(t.AsKeyword))a=h;else if(h.isOneOf([c.ModuleProperties,t.NamedImport]))for(const p of o)p.addDirectImport(h.getTextValue(),Wu(h.getEntity(),h.getCategory()));else if(h.is(t.ImportAll))for(const p of o)p.setImportAll();for(const h of o)s.set(h.getAlias(),h)},oa=function(i){return i.length>0&&i[0].is(c.BlockDefinitions)&&!m(this,x,ra).call(this,i)},ra=function(i){if(i.length===1)return!1;const e=on(i,t.AssignmentOperator);return e===-1?!1:e===1?!0:!!(i[1].is(t.Comma)&&e%2===1)},aa=function(i){const e=fe(i);switch(i[0].getEntity()){case t.FunctionDefinition:return m(this,x,la).call(this,e,i);case t.IfDefinition:return new at(e,i,t.IfDefinitionStatement);case t.ElifDefinition:return new at(e,i,t.ElifDefinitionStatement);case t.WhileDefinition:return new at(e,i,t.WhileDefinitionStatement);case t.ForDefinition:return new at(e,i,t.ForDefinitionStatement);case t.ExceptDefinition:return new at(e,i,t.ExceptDefinitionStatement);case t.ElseDefinition:return new at(e,i,t.ElseDefinitionStatement);case t.TryDefinition:return new at(e,i,t.TryDefinitionStatement);case t.FinallyDefinition:return new at(e,i,t.FinallyDefinitionStatement);case t.ClassDefinition:return new Qu(e,i);case t.LambdaDefinition:return new hd(e,i);case t.WithKeyword:return new at(e,i,t.WithDefinitionStatement);default:return i}},la=function(i,e){return e.length<2||e[1].is(t.FunctionName)?new Hu(i,e):new zu(i,e)},ca=function(i){let e=m(this,x,oo).call(this,i);if(e.sort((o,a)=>o[0]-a[0]),e.length===0)return i;let n=i,s;for(;e.length>0&&(s===void 0||e.length!==s.length);){const o=n[e[0][0]];o.is(t.OpenParenthesis)?n=m(this,x,ua).call(this,e[0],n):o.is(t.OpenSquareBracket)?n=m(this,x,da).call(this,e[0],n):n=m(this,x,fa).call(this,e[0],n),s=e,e=m(this,x,oo).call(this,n),e.sort((a,h)=>a[0]-h[0])}return n},oo=function(i){let e=[],n=[];for(let s=0;s<i.length;s++)if(Lo(i[s].getEntity()))n.push({openEntity:i[s].getEntity(),closeEntity:Yc(i[s].getEntity()),openIndex:s,closeIndex:-1});else if(Zc(i[s].getEntity())){let o=n.length-1;for(;o>=0;){if(n[o].closeEntity===i[s].getEntity()){n[o].closeIndex=s,e.push([n[o].openIndex,n[o].closeIndex]),n.splice(o,1);break}o--}}return e},ua=function(i,e){const n=i[0],s=i[1];if(n>0&&e[n-1].isOneOf([c.BuiltInFunctions,t.FunctionName])){const a=e[n-1].is(c.BuiltInFunctions)?t.BuiltInFunctionCall:t.UserDefinedFunctionCall,h=m(this,x,be).call(this,e.slice(n-1,s+1),a);return e.slice(0,n-1).concat([h],e.slice(s+1))}else if(n>2&&e[n-1].isOneOf([c.BuiltInMethods,t.MethodName,c.MagicMethods,c.ModuleFunctions])&&e[n-2].is(t.Dot)){const a=e[n-1].is(t.MethodName)&&!e[n-1].is(c.ModuleFunctions)?t.UserDefinedMethodCall:t.BuiltInMethodCall,h=m(this,x,be).call(this,e.slice(n-3,s+1),a);return e.slice(0,n-3).concat([h],e.slice(s+1))}else if(n>0&&e[n-1].is(t.ExceptionName)){const a=m(this,x,be).call(this,e.slice(n-1,s+1),t.ExceptionCall);return e.slice(0,n-1).concat([a],e.slice(s+1))}else if(s>n+1){const a=e.slice(n+1,s),h=this.split(a,t.Comma);if(h.length>1){const p=m(this,x,be).call(this,e.slice(n,s+1),t.TupleDefinition,h);return e.slice(0,n).concat([p],e.slice(s+1))}}const o=m(this,x,be).call(this,e.slice(n,s+1),t.GroupStatement);return e.slice(0,n).concat([o],e.slice(s+1))},da=function(i,e){const n=i[0],s=i[1];let o=[],a=[];if(s>n+1&&(a=e.slice(n+1,s),o=this.checkForListComp(a)),n===0||o.length===0||e[n-1].isOneOf([c.ComparisonOperators,c.LogicalOperators,c.MathsOperators,t.OpenParenthesis,t.OpenSquareBracket,t.OpenBrace,t.Comma,t.Colon,t.Separator,c.OtherKeywords,t.ContinuationLine])){const h=m(this,x,be).call(this,e.slice(n,s+1),t.ListDefinition,o);return e.slice(0,n).concat([h],e.slice(s+1))}else{let h=this.split(a,t.Colon);const p=m(this,x,ha).call(this,h,e,n,s)?m(this,x,be).call(this,e.slice(n,s+1),t.Slice,h):m(this,x,be).call(this,e.slice(n,s+1),t.IndexKey);let w=n-1;for(;w>=0&&!e[w].isOneOf([c.Identifiers,c.BuiltInFunctions,c.CompoundTypes,t.BuiltInFunctionCall,t.BuiltInMethodCall,t.UserDefinedFunctionCall,t.UserDefinedMethodCall,t.SubscriptedExpression,t.PropertyCallExpression]);)w--;w=Math.max(w,0);const S=m(this,x,be).call(this,[...e.slice(w,n),p],t.SubscriptedExpression);return e.slice(0,w).concat([S],e.slice(s+1))}},ha=function(i,e,n,s){return i.length>1||e[n+1].is(t.Colon)||e[s-1].is(t.Colon)},fa=function(i,e){const n=i[0],s=i[1];let o;if(s===n+1)o=m(this,x,be).call(this,e.slice(n,s+1),t.DictDefinition);else{const a=e.slice(n+1,s),h=this.split(a,t.Comma),p=[];for(let w of h){const S=this.split(w,t.Colon);S.length===2&&p.push(S)}p.length===h.length?o=m(this,x,be).call(this,e.slice(n,s+1),t.DictDefinition,p):o=m(this,x,be).call(this,e.slice(n,s+1),t.SetDefinition,h)}return e.slice(0,n).concat([o],e.slice(s+1))},be=function(i,e,n=[]){const s=fe(i);switch(e){case t.BuiltInFunctionCall:return new Xu(s,i);case t.UserDefinedFunctionCall:return new Zu(s,i);case t.BuiltInMethodCall:return new _u(s,i);case t.UserDefinedMethodCall:return new ed(s,i);case t.ExceptionCall:return new Yu(s,i);case t.TupleDefinition:case t.ListDefinition:case t.SetDefinition:case t.DictDefinition:return new Hs(s,i,e,n);case t.GroupStatement:return new dd(s,i);case t.Slice:return new Zo(s,i,n);case t.IndexKey:return new Yo(s,i);case t.SubscriptedExpression:return new zs(s,i);case t.CalculatedExpression:return new Qs(s,i);case t.ComparisonExpression:return new Ai(s,i);case t.IteratorExpression:return new ki(s,i);case t.BooleanExpression:return new Bi(s,i);default:throw new Error("Unknown multipart expression type")}},ga=function(i){let e=m(this,x,ro).call(this,i);for(;e>-1;){const n=e>0&&!i[e-1].isOneOf([c.MathsOperators,c.LogicalOperators,c.ComparisonOperators,c.OtherKeywords])?e-1:e,s=m(this,x,be).call(this,i.slice(n,e+2),t.CalculatedExpression);i=i.slice(0,n).concat([s],i.slice(e+2)),e=m(this,x,ro).call(this,i)}return i},pa=function(i){if(i.length<3)return i;let e=1;for(;e<i.length-1;)if(i[e].is(t.Dot)&&i[e+1].isOneOf([t.PropertyName,c.ModuleProperties])){const n=fe([i[e-1],i[e],i[e+1]]),s=new Wo(n,[i[e-1],i[e],i[e+1]],t.PropertyCallExpression,c.MultipartValue);i=i.slice(0,e-1).concat([s],i.slice(e+2)),e--}else if(i[e].is(t.Dot)&&!i[e+1].isOneOf([t.PropertyName,c.ModuleProperties])&&(e+2>=i.length||!i[e+2].isOneOf([t.OpenParenthesis]))){const n=fe([i[e-1],i[e],i[e+1]]),s=new Wo(n,[i[e-1],i[e],i[e+1]],t.PropertyCallExpression,c.MultipartValue);i=i.slice(0,e-1).concat([s],i.slice(e+2)),e--}else e++;return i},ma=function(i){if(i.length<2)return i;let e=0;for(;e<i.length-1;)if(i[e].isStringLiteral()&&i[e+1].isStringLiteral()){const n=fe([i[e],i[e+1]]),s=new sd(n,[i[e],i[e+1]]);i=i.slice(0,e).concat([s],i.slice(e+2))}else e++;return i},ro=function(i){const e=[],n=[];for(let s=0;s<i.length;s++){if(i[s].is(t.ExponentOperator))return s;i[s].isOneOf([t.MultiplyOperator,t.DivideOperator,t.IntDivideOperator,t.ModulusOperator])?e.push(s):i[s].isOneOf([t.AddOperator,t.SubtractOperator])&&n.push(s)}return e.length>0?e[0]:n.length>0?n[0]:-1},wa=function(i){let e=m(this,x,ao).call(this,i);for(;e>0;){let n=e-1,s;i[e].is(t.InKeyword)&&n>1&&i[n-1].is(t.Comma)?(n=n-2,s=m(this,x,be).call(this,i.slice(n,e+2),t.IteratorExpression)):i[e].is(t.InKeyword)&&e===1&&e+1<i.length&&i[e+1].is(t.BuiltInFunctionCall)&&i[e+1].getFunctionExpression().isOneOf([t.EnumerateFunction])?(n=0,s=m(this,x,be).call(this,i.slice(n,e+2),t.IteratorExpression)):s=m(this,x,be).call(this,i.slice(n,e+2),t.ComparisonExpression),i=i.slice(0,n).concat([s],i.slice(e+2)),e=m(this,x,ao).call(this,i)}return i},ao=function(i){for(let e=0;e<i.length;e++)if(i[e].is(c.ComparisonOperators))return e;return-1},Sa=function(i){let e=m(this,x,lo).call(this,i);for(;e>-1;){const s=(i[e].is(t.NotOperator)?2:3)===2?e:e-1,o=s>=0?i.slice(s,e+2):i.slice(e,e+2),a=m(this,x,be).call(this,o,t.BooleanExpression);i=s>=0?i.slice(0,s).concat([a],i.slice(e+2)):i.slice(0,e).concat([a],i.slice(e+2)),e=m(this,x,lo).call(this,i)}return i},lo=function(i){let e=[],n=[];for(let s=0;s<i.length;s++){if(i[s].is(t.NotOperator))return s;i[s].is(t.AndOperator)?e.push(s):i[s].is(t.OrOperator)&&n.push(s)}return e.length>0?e[0]:n.length>0?n[0]:-1},ba=function(i){let e=on(i,t.IfDefinition);for(;e>-1&&i.length>=e+3&&i[e+2].is(t.ElseDefinition);){const s=i.slice(e-1,e+4),o=fe(s),a=new Pi(o,s);i=i.slice(0,e-1).concat([a],i.slice(e+4)),e=on(i,t.IfDefinition)}return i},Ia=function(i){for(;i.length>=3&&i[1].is(t.ForDefinition);){const e=i.length>=5&&i[3].is(t.IfDefinition),n=i.slice(0,e?5:3),s=fe(n);n[2].is(t.ComparisonExpression)&&(n[2]=i[2].convertToIterator()),i=[new Vi(s,n)].concat(i.slice(e?5:3))}return i},ya=function(i){let e=m(this,x,co).call(this,i);for(;e>-1;){const n=m(this,x,Fa).call(this,i,e-1),s=i.slice(n),o=fe(s),a=i[e].is(t.AssignmentOperator)?new Xo(o,s):new ud(o,s);i=i.slice(0,n).concat([a]),e=m(this,x,co).call(this,i)}return i},Fa=function(i,e){let n=-1;for(let s=e;s>=0&&!(i[s].isChangeOperator()||i[s].isOneOf([c.OtherKeywords,c.BlockDefinitions]));s--)n=s;return Math.max(n,0)},co=function(i){for(let e=i.length-1;e>0;e--)if(i[e].isChangeOperator())return e;return-1},Na=function(i){return i.length>0&&(i[0].is(t.ReturnKeyword)?i=[new fd(fe(i),i)]:i[0].isOneOf([t.ImportKeyword,t.FromKeyword])?i=[new gd(fe(i),i)]:i[0].isOneOf([t.GlobalKeyword,t.AssertKeyword,t.RaiseKeyword])&&(i=[new pd(fe(i),i)])),i},b(ls,x);let Q=ls;function rn(g,i,e,n,s,o=n+g.length,a=e){switch(i.entity){case t.ExceptionName:return new ld(g,i.entity,i.category,e,n,s);case t.VariableName:return new an(g,i.entity,i.category,e,n,s);case t.FunctionName:return new Qo(g,i.entity,i.category,e,n,s);case t.MethodName:return new id(g,i.entity,i.category,e,n,s);case t.ClassName:return new cd(g,i.entity,i.category,e,n,s);case t.PropertyName:return new xi(g,i.entity,i.category,e,n,s);case t.ModuleName:return new Ho(g,i.entity,i.category,e,n,s);case t.StringLiteral:return new qo(g,e,n,s,o,a);case t.TrueType:case t.FalseType:case t.NoneType:return new rd(g,i.entity,i.category,e,n,s);case t.ListDefinition:case t.TupleDefinition:case t.SetDefinition:case t.DictDefinition:return new Hs(g,[],i.entity,[]);case t.IndexKey:return new Yo(g,[]);case t.Slice:return new Zo(g,[],[]);case t.NamedImport:return new xi(g,i.entity,i.category,e,n,s)}switch(i.category){case c.BuiltInFunctions:case c.BuiltInMethods:case c.ModuleFunctions:case c.MagicMethods:return new od(g,i.entity,i.category,e,n,s);case c.BuiltInModules:return new Ho(g,i.entity,i.category,e,n,s);case c.Types:return new ad(g,i.entity,i.category,e,n,s);case c.SpecialVariables:return new an(g,i.entity,i.category,e,n,s);case c.ModuleProperties:return new xi(g,i.entity,i.category,e,n,s);case c.LogicalOperators:case c.MathsOperators:case c.ComparisonOperators:case c.OtherKeywords:case c.BlockDefinitions:case c.Other:case c.TypeHint:return new jo(g,i.entity,i.category,e,n,s);default:return new nt(g,i.entity,i.category,e,n,s,d.Unknown)}}class nt extends Ws{constructor(e,n,s,o,a,h,p=d.NotParsed,w=a+e.length-1,S=o){super();b(this,yt);b(this,Ft);b(this,Nt);b(this,ut);b(this,mn);b(this,wn);b(this,Sn);b(this,cs);b(this,bn);b(this,xe);b(this,jt,"unknown");b(this,In,"unknown");b(this,us,[]);if(w<a)throw new Error("Could not create expression: end index cannot be less than start index");y(this,yt,e),y(this,Ft,n),y(this,Nt,s),y(this,mn,o),y(this,Sn,a),y(this,cs,h),y(this,bn,w),y(this,wn,S),y(this,xe,p)}getTextValue(){return u(this,yt)}setTextValue(e){y(this,yt,e)}getEntity(){return u(this,Ft)}setEntity(e){y(this,Ft,e)}getCategory(){return u(this,Nt)}setCategory(e){y(this,Nt,e)}getStartLineNumber(){return u(this,mn)}getEndLineNumber(){return u(this,wn)}setEndLineNumber(e){y(this,wn,e)}getDocumentStartIndex(){return u(this,Sn)}getIndexOnLine(){return u(this,cs)}getDocumentEndIndex(){return u(this,bn)}setDocumentEndIndex(e){y(this,bn,e)}getDataType(){return u(this,xe)}setDataType(e){e!==u(this,xe)&&(y(this,xe,e),super.sendUpdate(e))}setBlockId(e){u(this,jt)!==e&&y(this,jt,e)}getBlockId(){return u(this,jt)==="unknown"&&u(this,ut)!==void 0?u(this,ut).getBlockId():u(this,jt)}setScopeId(e){u(this,In)==="unknown"&&y(this,In,e)}getScopeId(){return u(this,In)}typeUpdateReceived(e){this.setDataType(e)}getParent(){return u(this,ut)}setParent(e){y(this,ut,e)}hasParentOfKind(e){let n=this.getParent();for(;n!==void 0;)if(n.is(e))return!0;return!1}getParentOfKind(e){let n=this.getParent();for(;n!==void 0;)if(n.is(e))return n}getContextOfUse(){return u(this,ut)===void 0?"none":u(this,ut).getEntity().name}contains(e){return this===e}is(e){return u(this,Ft)===e||u(this,Nt)===e||u(this,yt)===e}isOneOf(e){try{for(let n of e)if(this.is(n))return!0}catch{try{return this.is(e)}catch{return!1}}return!1}isSubscriptable(){return!1}isNumeric(){return u(this,xe)===d.Int||u(this,xe)===d.Float||u(this,xe)===d.Number||u(this,xe)===d.Bool}isIntLike(){return u(this,xe)===d.Int||u(this,xe)===d.Bool}isNonFloatNumeric(){return this.isIntLike()||u(this,xe)===d.Number}isChangeOperator(){return this.isOneOf([t.AssignmentOperator,t.IncrementOperator,t.DecrementOperator,t.MultiplyAssignOperator,t.DivideAssignOperator,t.ExponentAssignOperator,t.IntDivideAssignOperator,t.RemainderAssignOperator])}matchesPattern(e){return this.getTextValue()===e.getTextValue()&&this.getEntity()===e.getEntity()}isStringLiteral(){return!1}hasChildExpressions(){return!1}getExpressionsOfKind(e){const n=[];return this.is(e)&&n.push(this),n}getFirstExpressionOf(e){if(this.isOneOf(e))return this}getVariableExpressions(){return[]}getAllNestedExpressions(){return[this]}checkForSymptoms(){this.checkRules(this)}getConnectedTo(){return u(this,us)}addConnection(e){u(this,us).push(e)}toJSON(){return{entity:u(this,Ft).name,category:u(this,Nt).name,textValue:u(this,yt),dataType:u(this,xe).name,lineNumber:u(this,mn),docIndex:u(this,Sn)}}}yt=new WeakMap,Ft=new WeakMap,Nt=new WeakMap,ut=new WeakMap,mn=new WeakMap,wn=new WeakMap,Sn=new WeakMap,cs=new WeakMap,bn=new WeakMap,xe=new WeakMap,jt=new WeakMap,In=new WeakMap,us=new WeakMap;class ne extends nt{constructor(e,n,s,o,a=d.NotParsed){super(e,s,o,n.length>0?n[0].getStartLineNumber():-1,n.length>0?n[0].getDocumentStartIndex():-1,n.length>0?n[0].getIndexOnLine():-1,a,n.length>0?n[n.length-1].getDocumentEndIndex():-1,n.length>0?n[n.length-1].getEndLineNumber():-1);b(this,ei);b(this,Ue);y(this,Ue,n),m(this,ei,Ca).call(this,u(this,Ue))}isSubscriptable(){return $s(this.getDataType())}hasChildExpressions(){return u(this,Ue).length>0}getVariableExpressions(){let e=[];for(let n of u(this,Ue))n.getTextValue()!=="Placeholder"&&(e=e.concat(n.getVariableExpressions()));return e}matchesPattern(e){return this.getEntity()===e.getEntity()}getExpressionsOfKind(e){let n=super.getExpressionsOfKind(e);for(let s of u(this,Ue))s.is(e)?n.push(s):n=n.concat(s.getExpressionsOfKind(e));return n}getFirstExpressionOf(e){let n=super.getFirstExpressionOf(e);if(n===void 0)for(const s of u(this,Ue)){if(s.isOneOf(e))return s;if(n=s.getFirstExpressionOf(e),n!==void 0)return n}return n}contains(e){if(super.contains(e))return!0;for(let n of u(this,Ue))if(n.contains(e))return!0;return!1}checkForSymptoms(){this.checkRules(this);for(const e of this.getChildren())e.checkForSymptoms()}checkForCounterRules(e){super.checkForCounterRules(e);for(const n of this.getChildren())n.checkForCounterRules(n)}setBlockId(e){super.setBlockId(e);for(const n of this.getChildren())n.setBlockId(e)}setScopeId(e){super.setScopeId(e);for(const n of this.getChildren())n.setScopeId(e)}getChildren(){return u(this,Ue)}setChildren(e){y(this,Ue,e)}addChild(e){u(this,Ue).push(e)}isComplete(){return this.hasChildExpressions()}}Ue=new WeakMap,ei=new WeakSet,Ca=function(e){for(const n of e)n.setParent(this)};const hs=class hs extends ne{constructor(e,n,s){var p;const o=m(p=hs,Fn,Ma).call(p,n);super(e,o,s,c.BlockDefinitionStatement,d.NA);b(this,yn);b(this,Se);b(this,ds,0);const a=3,h=o.length-3;if(h<a)y(this,Se,[]);else{const w=o.slice(a,h+1);y(this,Se,Q.split(w,t.Comma)),m(this,yn,xa).call(this)}this.addRule(m(this,yn,Oa))}isComplete(){const e=this.getChildren();return e.length>=5&&e[0].is(t.FunctionDefinition)&&e[1].isOneOf([t.FunctionName,t.MethodName])&&e[2].is(t.OpenParenthesis)&&e[e.length-2].is(t.CloseParenthesis)&&e[e.length-1].is(t.Colon)&&Ni(e,t.OpenParenthesis,t.CloseParenthesis)}getVariableExpressions(){let e=[];for(let n of u(this,Se))for(let s of n)s.is(t.VariableName)?e.push(s):e=e.concat(s.getVariableExpressions());return e}getExpressionsOfKind(e){let n=super.getExpressionsOfKind(e);for(let s of u(this,Se))for(const o of s)o.is(e)?n.push(o):n=n.concat(o.getExpressionsOfKind(e));return n}getFirstExpressionOf(e){let n=super.getFirstExpressionOf(e);if(n===void 0)for(const s of u(this,Se)){if(s.isOneOf(e))return s;if(n=s.getFirstExpressionOf(e),n!==void 0)return n}return n}checkForSymptoms(){this.checkRules(this);for(const e of u(this,Se))for(const n of e)n.checkForSymptoms()}checkForCounterRules(e){super.checkForCounterRules(e);for(const n of u(this,Se))for(const s of n)s.checkForCounterRules(s)}getParameters(){return u(this,Se)}getOptionalParameterCount(){return u(this,ds)}};Se=new WeakMap,ds=new WeakMap,yn=new WeakSet,Oa=function(e){const n=[],s=e.getChildren();if(s.length>1){const o=Xe(s[1].getTextValue()).category;(o===c.BlockDefinitions||o===c.LogicalOperators||o===c.Types||o===c.OtherKeywords)&&n.push(O.createStatementSymptom(I.DefinitionFollowedByReservedWord,s,0,1,{definitionType:s[0].getTextValue(),reservedWord:s[1].getTextValue()}))}return n},Fn=new WeakSet,Ta=function(e){let n=-1,s=-1,o=0;for(let a=0;a<e.length;a++)if(e[a].is(t.OpenParenthesis))o++,n===-1&&(n=a);else if(e[a].is(t.CloseParenthesis)&&(o--,o===0)){s=a;break}return[n,s]},Ma=function(e){var a;let s=m(a=hs,Fn,Ta).call(a,e)[1]+1,o=-1;for(;s<e.length;){if(e[s].is(t.Colon)){o>=0&&e.splice(o,s-o);break}else e[s].is(t.TypeHintReturn)&&(o=s);s++}return e},xa=function(){for(let e=0;e<u(this,Se).length;e++){if(u(this,Se)[e]=Q.createTree(u(this,Se)[e]),u(this,Se)[e].length>1){const n=Q.split(u(this,Se)[e],t.Colon);u(this,Se)[e]=n[0]}for(let n of u(this,Se)[e])if(n.is(t.VariableName))n.setDataType(d.Unknown),n.setAssignedOrChanged(),n.setIsParameter();else if(n.is(t.AssignmentStatement)){const s=n.getVariableExpressions();hi(this,ds)._++;for(let o of s)o.setDataType(d.Unknown),o.setAssignedOrChanged(),o.setIsParameter()}}},b(hs,Fn);let qs=hs;class Hu extends qs{constructor(i,e){if(super(i,e,t.FunctionDefinitionStatement,c.BlockDefinitionStatement,d.NA),this.addConnection(this.getFunctionNameExpression()),this.getFunctionNameExpression()!==void 0){this.getFunctionNameExpression().addConnection(this);for(const n of this.getParameters())for(const s of n)this.getFunctionNameExpression().addConnection(s)}}isComplete(){return super.isComplete()&&this.getChildren()[1].is(t.FunctionName)}getFunctionNameExpression(){return this.getChildren()[1]}getConnectedTo(){return this.getFunctionNameExpression().getConnectedTo()}addConnection(i){this.getFunctionNameExpression()!==void 0&&this.getFunctionNameExpression().addConnection(i)}getAllNestedExpressions(){try{return[...super.getAllNestedExpressions(),...this.getFunctionNameExpression().getAllNestedExpressions(),...this.getParameters().flatMap(e=>e.flatMap(n=>n.getAllNestedExpressions()))]}catch{return[]}}toJSON(){const i=super.toJSON();return i.functionName=this.getFunctionNameExpression().getTextValue(),i.parameters=this.getParameters().map(e=>e.map(n=>n.toJSON())),i}}class zu extends qs{constructor(e,n){super(e,n,t.MethodDefinitionStatement,c.BlockDefinitionStatement,d.NA);b(this,fs);const s=super.getParameters();s.length>0&&y(this,fs,s[0][0]),this.addConnection(this.getMethodNameExpression()),this.getMethodNameExpression().addConnection(this);for(const o of this.getParameters())for(const a of o)this.getMethodNameExpression().addConnection(a)}isComplete(){return super.isComplete()&&this.getChildren()[1].is(t.MethodName)}getMethodNameExpression(){return this.getChildren()[1]}getParameters(){return super.getParameters().slice(1)}getClassVar(){return u(this,fs)}getConnectedTo(){return this.getMethodNameExpression().getConnectedTo()}addConnection(e){this.getMethodNameExpression().addConnection(e)}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...this.getMethodNameExpression().getAllNestedExpressions(),...this.getParameters().flatMap(n=>n.flatMap(s=>s.getAllNestedExpressions()))]}toJSON(){const e=super.toJSON();return e.methodName=this.getMethodNameExpression().getTextValue(),e.parameters=this.getParameters().map(n=>n.map(s=>s.toJSON())),e}}fs=new WeakMap;class Qu extends ne{constructor(i,e){super(i,e,t.ClassDefinitionStatement,c.BlockDefinitionStatement,e.length>=2&&e[1].is(t.ClassName)?d.createCustomType(e[1].getTextValue()):d.Class)}isComplete(){return super.isComplete()&&this.getChildren()[1].is(t.ClassName)}getAllNestedExpressions(){return super.getAllNestedExpressions()+[this.getChildren()[1]]}getClassNameExpression(){return this.getChildren()[1]}toJSON(){const i=super.toJSON();return i.className=this.getClassNameExpression().getTextValue(),i}}const ti=class ti extends ne{constructor(e,n,s,o){super(e,n,s,o);b(this,ue);b(this,pe);if(m(this,ue,pi).call(this),this.isComplete()){const h=n.length-2;if(h<2)y(this,pe,[]);else{const p=n.slice(2,h+1);y(this,pe,Q.checkForListComp(p));for(let w=0;w<u(this,pe).length;w++)u(this,pe)[w].length>1&&(u(this,pe)[w]=Q.createTree(u(this,pe)[w]))}}else y(this,pe,[]);m(this,ue,Aa).call(this),this.addRules([m(this,ue,Va),m(this,ue,Ba)]),this.addCounterRules([m(this,ue,La),m(this,ue,ka),m(this,ue,Pa)]),m(this,ue,Da).call(this)}isComplete(){const e=this.getChildren();return e.length>=3&&e[0].isOneOf([c.BuiltInFunctions,t.FunctionName])&&e[1].is(t.OpenParenthesis)&&e[e.length-1].is(t.CloseParenthesis)&&Ni(e,t.OpenParenthesis,t.CloseParenthesis)}addChild(e){super.addChild(e),m(this,ue,pi).call(this)}setChildren(e){super.setChildren(e),m(this,ue,pi).call(this)}getVariableExpressions(){let e=[];for(let n of u(this,pe))for(let s of n)s.is(t.VariableName)?e.push(s):e=e.concat(s.getVariableExpressions());return e}getExpressionsOfKind(e){let n=super.getExpressionsOfKind(e);if(this.getChildren()[0].is(e))return[this.getChildren()[0]];for(let s of u(this,pe))for(let o of s)o.is(e)?n.push(o):n=n.concat(o.getExpressionsOfKind(e));return n}getFirstExpressionOf(e){let n=super.getFirstExpressionOf(e);if(this.getChildren()[0].isOneOf(e))return this.getChildren()[0];if(n===void 0)for(const s of u(this,pe)){if(s.isOneOf(e))return s;if(n=s.getFirstExpressionOf(e),n!==void 0)return n}return n}checkForSymptoms(){this.checkRules(this);for(const e of u(this,pe))for(const n of e)n.checkForSymptoms()}checkForCounterRules(e){super.checkForCounterRules(e);for(const n of u(this,pe))for(const s of n)s.checkForCounterRules(s)}matchesPattern(e){return super.matchesPattern(e)&&this.getFunctionName()===e.getFunctionName()&&this.getTextValue()===e.getTextValue()}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...this.getFunctionExpression().getAllNestedExpressions(),...u(this,pe).flatMap(n=>n.flatMap(s=>s.getAllNestedExpressions()))]}toJSON(){const e=super.toJSON();return e.functionName=this.getFunctionName(),e.arguments=this.getArguments().map(n=>n.map(s=>s.toJSON())),e}getFunctionEntity(){const e=this.getChildren();if(e.length<1)throw new Error("No function expression available");return e[0].getEntity()}getFunctionName(){const e=this.getChildren();if(e.length<1)throw new Error("No function expression available");return e[0].getTextValue()}getFunctionExpression(){const e=this.getChildren();if(e.length<1)throw new Error("No function expression available");return e[0]}getArguments(){return u(this,pe)}};pe=new WeakMap,ue=new WeakSet,Da=function(){for(const e of u(this,pe))for(const n of e)n.addConnection(this);this.addConnection(this.getFunctionExpression())},Aa=function(){for(const e of u(this,pe))for(const n of e)n.setParent(this)},pi=function(){this.getChildren()[0].addObserver(this),this.isComplete()?Wi(ti.prototype,this,"setDataType").call(this,this.getChildren()[0].getDataType()):Wi(ti.prototype,this,"setDataType").call(this,d.NotParsed)},Ba=function(e){const n=[];return e.getDataType()!==d.None&&e.getDataType()!==d.Undefined&&e.getDataType()!==d.Invalid&&e.getDataType()!==d.NA&&e.getDataType()!==d.NotParsed&&(e.getParent()===void 0||e.getParent().is(t.GroupStatement)&&e.getParent().getParent()===void 0)&&(e.is(t.BuiltInFunctionCall)||e.getFunctionExpression().getReturnStatements().length>0)&&n.push(O.createStatementSymptom(I.UnusedReturn,[e],0,0,{expression:e.getFunctionExpression()})),n},ka=function(e){const n=[];if(e.getDataType()!==d.None&&e.getParent()!==void 0&&(!e.getParent().is(t.GroupStatement)||e.getParent().getParent()!==void 0)&&(e.is(t.BuiltInFunctionCall)||e.getFunctionExpression().getReturnStatements().length>0)){let s=e.getParent();s.is(t.GroupStatement)&&(s=s.getParent()),n.push(O.createStatementSymptom(k.UsedReturn,[e],0,0,{expression:e.getFunctionExpression(),usage:s.getTextValue(),usageType:s.getEntity().name}))}return n},Pa=function(e){const n=[];return e.getDataType()===d.None&&e.getParent()===void 0&&n.push(O.createStatementSymptom(k.NoReturnStandaloneCall,[e],0,0,{expression:e.getFunctionExpression()})),n},Va=function(e){const n=[],s=e.getArguments();for(const o of s){const h=o.flatMap(p=>p.is(t.GroupStatement)?p.getContents():p).filter(p=>Bt(p)||p.getDataType()===d.None&&!p.isOneOf([t.NoneType,t.VariableName]));h.length>0&&n.push(...h.map(p=>O.createStatementSymptom(I.AssignedNone,[p],0,0,{expression:p,usage:e.getFunctionEntity()===t.PrintFunction?"print":Vo})))}return n},La=function(e){const n=[];return e.isComplete()&&n.push(O.createStatementSymptom(k.ValidFunctionCall,[e],0,0,{numArgs:e.getArguments().length})),n};let js=ti;class Xu extends js{constructor(e,n){super(e,n,t.BuiltInFunctionCall,c.FunctionCall);b(this,ni);n.length>0&&n[0].isOneOf([t.StrFunction,t.IntFunction,t.FloatFunction,t.BoolFunction,t.ListFunction,t.TupleFunction,t.SetFunction,t.DictFunction])&&this.addRule(m(this,ni,va))}isComplete(){return super.isComplete()&&this.getChildren()[0].is(c.BuiltInFunctions)}convertToUserDefinedFunction(e){this.setEntity(t.UserDefinedFunctionCall);const n=this.getChildren()[0];n.setEntity(t.FunctionName),n.setCategory(c.Identifiers),n.setDataType(e.getReturnType()),n.addReturns=(s,o=!1)=>e.addReturns(s,o),n.getReturnType=()=>e.getReturnType(),n.getReturnStatements=()=>e.getReturnStatements()}}ni=new WeakSet,va=function(e){const n=[],s=e.getDataType(),o=e.getArguments(),a=e.getChildren();return o.length===1&&o[0].length===1&&(o[0][0].getDataType()===s||s===d.List&&o[0][0].getDataType()===d.String)&&n.push(O.createStatementSymptom(I.TypeUnnecessary,a,0,a.length-1,{convertedValue:o[0][0].getTextValue(),argType:o[0][0].getDataType().name,convertedType:s.name})),n};class Zu extends js{constructor(i,e){super(i,e,t.UserDefinedFunctionCall,c.FunctionCall);const n=this.getFunctionExpression(),s=this.getArguments();if(s.length>0&&n.getParent().is(c.FunctionCall)&&s.length<=n.getParent().getArguments().length){const o=n.getParent().getArguments();for(let a=0;a<s.length;a++)s[a][0].addConnection(o[a][0])}}isComplete(){return super.isComplete()&&this.getChildren()[0].is(t.FunctionName)}convertToImportedFunction(){this.setEntity(t.BuiltInFunctionCall);const i=this.getChildren()[0];i.setEntity(t.Unknown),i.setCategory(c.ModuleFunctions),i.setDataType(d.Unknown)}}class Yu extends ne{constructor(i,e){super(i,e,t.ExceptionCall,c.ExceptionCall,d.Exception)}isComplete(){return super.isComplete()&&this.getChildren()[0].is(c.BuiltInExceptions)}getAllNestedExpressions(){return this.getChildren()[0].getAllNestedExpressions()}}class Ko extends ne{constructor(e,n,s,o){super(e,n,s,o);b(this,Fe);b(this,me);if(m(this,Fe,Us).call(this),this.isComplete()){const h=n.length-2;if(h<4)y(this,me,[]);else{let p=n.slice(4,h+1);y(this,me,Q.checkForListComp(p));for(let w=0;w<u(this,me).length;w++)u(this,me)[w].length>1&&(u(this,me)[w]=Q.createTree(u(this,me)[w]))}}else y(this,me,[]);m(this,Fe,Ea).call(this),m(this,Fe,Ra).call(this),this.addRules([m(this,Fe,Ja),m(this,Fe,Ua)]),this.addCounterRules([m(this,Fe,Ga)])}isComplete(){const e=this.getChildren();return e.length>=5&&e[1].is(t.Dot)&&e[3].is(t.OpenParenthesis)&&e[e.length-1].is(t.CloseParenthesis)&&Ni(e,t.OpenParenthesis,t.CloseParenthesis)}addChild(e){super.addChild(e),m(this,Fe,Us).call(this)}setChildren(e){super.setChildren(e),m(this,Fe,Us).call(this)}getVariableExpressions(){let e=[];for(let n of this.getChildren()){if(n.is(t.Dot))break;n.is(t.VariableName)?e.push(n):e=e.concat(n.getVariableExpressions())}for(let n of u(this,me))for(let s of n)s.is(t.VariableName)?e.push(s):e=e.concat(s.getVariableExpressions());return e}getExpressionsOfKind(e){let n=super.getExpressionsOfKind(e);for(let s of u(this,me))for(let o of s)o.is(e)?n.push(o):n=n.concat(o.getExpressionsOfKind(e));return n}getFirstExpressionOf(e){let n=super.getFirstExpressionOf(e);if(n===void 0)for(const s of u(this,me)){if(s.isOneOf(e))return s;if(n=s.getFirstExpressionOf(e),n!==void 0)return n}return n}checkForSymptoms(){this.checkRules(this),this.isComplete()&&this.getChildren()[0].checkForSymptoms();for(const e of u(this,me))for(const n of e)n.checkForSymptoms()}checkForCounterRules(e){super.checkForCounterRules(e),this.isComplete()&&this.getChildren()[0].checkForCounterRules(this.getChildren()[0]);for(const n of u(this,me))for(const s of n)s.checkForCounterRules(s)}typeUpdateReceived(e){m(this,Fe,Us).call(this)}matchesPattern(e){return super.matchesPattern(e)&&this.getMethodName()===e.getMethodName()}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),this.getMethodExpression(),...u(this,me).flatMap(n=>n.flatMap(s=>s.getAllNestedExpressions()))]}toJSON(){const e=super.toJSON();return e.methodName=this.getMethodName(),e.arguments=this.getArguments().map(n=>n.map(s=>s.toJSON())),e.object=this.getObject().toJSON(),e}getMethodEntity(){const e=this.getChildren();if(e.length<3)throw new Error("No method expression available");return e[2].getEntity()}getMethodExpression(){const e=this.getChildren();if(e.length<3)throw new Error("No method expression available");return e[2]}getMethodName(){const e=this.getChildren();if(e.length<3)throw new Error("No method expression available");return e[2].getTextValue()}getMethod(){const e=this.getChildren();if(e.length<3)throw new Error("No method expression available");return e[2]}getObject(){const e=this.getChildren();if(e.length===0)throw new Error("No children");return e[0]}getArguments(){return u(this,me)}}me=new WeakMap,Fe=new WeakSet,Ra=function(){for(const e of u(this,me))for(const n of e)n.addConnection(this);this.addConnection(this.getMethodExpression())},Ea=function(){for(const e of u(this,me))for(const n of e)n.setParent(this)},Us=function(){if(this.isComplete()){const e=this.getObject(),n=this.getMethod();Hn.has(e.getDataType())&&Hn.get(e.getDataType()).has(n.getEntity())?this.setDataType(n.getDataType()):n.is(c.BuiltInMethods)&&e.getDataType()===d.NotParsed?e.addObserver(this):this.setDataType(d.Unknown)}else this.setDataType(d.NotParsed)},Ua=function(e){const n=[],s=e.getMethod();return s.getDataType()!==d.None&&s.getDataType()!==d.NotParsed&&s.getDataType()!==d.Unknown&&e.getDataType()!==d.Unknown&&e.getDataType()!==d.None&&e.getDataType()!==d.NotParsed&&(e.getParent()===void 0||e.getParent().is(t.GroupStatement)&&e.getParent().getParent()===void 0)&&n.push(O.createStatementSymptom(I.UnusedReturn,[e],0,0,{expression:e.getMethodExpression()})),n},Ga=function(e){const n=[],s=e.getMethod();if(s.getDataType()!==d.None&&s.getDataType()!==d.NotParsed&&e.getParent()!==void 0&&(!e.getParent().is(t.GroupStatement)||e.getParent().getParent()!==void 0)){let o=e.getParent();o.is(t.GroupStatement)&&(o=o.getParent()),n.push(O.createStatementSymptom(k.UsedReturn,[e],0,0,{expression:s,usage:o.getTextValue(),usageType:o.getEntity().name}))}return n},Ja=function(e){const n=[],s=e.getArguments();for(const o of s){const h=o.flatMap(p=>p.is(t.GroupStatement)?p.getContents():p).filter(p=>Bt(p)||p.getDataType()===d.None&&!p.isOneOf([t.NoneType,t.VariableName]));h.length>0&&n.push(...h.map(p=>O.createStatementSymptom(I.AssignedNone,[p],0,0,{expression:p,usage:Vo})))}return n};class _u extends Ko{constructor(e,n){super(e,n,t.BuiltInMethodCall,c.MethodCall);b(this,Nn);m(this,Nn,$a).call(this),this.addRule(m(this,Nn,Ka))}isComplete(){return super.isComplete()&&this.getChildren()[2].isOneOf([c.BuiltInMethods,c.MagicMethods,c.ModuleFunctions])}isStringLiteral(){return this.getMethodEntity()===t.Format}}Nn=new WeakSet,$a=function(){if(_c.has(this.getMethodEntity())){const e=this.getObject();e.is(t.VariableName)?e.setAssignedOrChanged():e.is(t.SubscriptedExpression)&&e.getChildren()[0].is(t.VariableName)&&e.getChildren()[0].setAssignedOrChanged()}},Ka=function(e){const n=[],o=e.getObject().getDataType(),a=e.getMethod();let h=!0;switch(o){case d.Number:case d.Int:case d.Float:case d.Bool:case d.None:h=!1}if(h&&Hn.has(o)&&(h=Hn.get(o).has(a.getEntity())||a.is(c.MagicMethods)),!h){const p=e.getChildren();n.push(O.createStatementSymptom(I.UnknownMethod,p,0,p.length-1,{objectType:o.name}))}return n};class ed extends Ko{constructor(e,n){super(e,n,t.UserDefinedMethodCall,c.MethodCall);b(this,si);this.addRule(m(this,si,Wa))}isComplete(){return super.isComplete()&&this.getChildren()[2].is(t.MethodName)}}si=new WeakSet,Wa=function(e){const n=[],o=e.getObject().getDataType();if(Hn.has(o)){const a=e.getChildren();n.push(O.createStatementSymptom(I.UnknownMethod,a,0,a.length-1,{objectType:o.name}))}return n};class Wo extends ne{constructor(e,n,s,o){super(e,n,s,o);b(this,Cn);b(this,st);b(this,Le);this.isComplete()&&(y(this,st,n[0]),y(this,Le,n[2])),m(this,Cn,ja).call(this),this.addRule(m(this,Cn,qa))}isComplete(){const e=this.getChildren();return e.length==3&&e[1].is(t.Dot)}getVariableExpressions(){let e=[];return u(this,st).is(t.VariableName)?e.push(u(this,st)):e=e.concat(u(this,st).getVariableExpressions()),e}getExpressionsOfKind(e){let n=super.getExpressionsOfKind(e);for(let s of this.getChildren())s.is(e)?n.push(s):n=n.concat(s.getExpressionsOfKind(e));return n}getFirstExpressionOf(e){let n=super.getFirstExpressionOf(e);if(n===void 0)for(const s of this.getChildren()){if(s.isOneOf(e))return s;if(n=s.getFirstExpressionOf(e),n!==void 0)return n}return n}matchesPattern(e){return super.matchesPattern(e)&&this.getTextValue()===e.getTextValue()}setDataType(e){if((e!==this.getDataType()||e!==u(this,Le).getDataType())&&(super.setDataType(e),!u(this,Le).is(c.ModuleProperties)))try{u(this,Le).setDataType(e)}catch{}}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...u(this,st).getAllNestedExpressions(),...u(this,Le).getAllNestedExpressions()]}toJSON(){const e=super.toJSON();return e.object=u(this,st).toJSON(),e.propertyName=u(this,Le).getTextValue(),e}getObject(){return u(this,st)}getProperty(){return u(this,Le)}}st=new WeakMap,Le=new WeakMap,Cn=new WeakSet,qa=function(e){const n=[];return(e.getParent()===void 0||e.getParent().is(t.GroupStatement)&&e.getParent().getParent()===void 0)&&n.push(O.createStatementSymptom(I.UnusedValue,[e],0,0)),n},ja=function(){if(this.isComplete())if(u(this,Le).getCategory()===c.ModuleProperties){const e=kt.get(u(this,Le).getEntity());this.setDataType(e||u(this,Le).getDataType())}else this.setDataType(d.Unknown);else this.setDataType(d.NotParsed);u(this,Le).addObserver(this)};class td extends nt{isSubscriptable(){return!0}}class qo extends td{constructor(e,n,s,o,a=s+e.length,h=n){super(e,t.StringLiteral,c.Literals,n,s,o,d.String,a,h);b(this,ii);this.addRule(m(this,ii,Ha))}isStringLiteral(){return!0}matchesPattern(e){return e.getEntity()===t.StringLiteral||e.getEntity()===t.CombinedStringLiteral||e.getEntity()===t.FString}setDataType(e){throw new Error(`Cannot change the data type of a String literal. Attempted to change the type to: ${e.name}.`)}update(e,n,s){this.setEndLineNumber(e),this.documentEndIndex(n),this.setTextValue(this.getTextValue+s)}}ii=new WeakSet,Ha=function(e){const n=[];return(e.getParent()===void 0||e.getParent().is(t.GroupStatement)&&e.getParent().getParent()===void 0)&&n.push(O.createStatementSymptom(I.UnusedValue,[e],0,0)),n};class Mi extends nt{constructor(e,n,s,o){const a=e.indexOf(".")>=0?t.FloatLiteral:t.IntLiteral;super(e,a,c.Literals,n,s,o,a===t.FloatLiteral?d.Float:d.Int);b(this,oi);this.addRule(m(this,oi,za))}setDataType(e){throw new Error(`Cannot change the data type of a bumber literal. Attempted to change the type to: ${e.name}.`)}matchesPattern(e){return e.getEntity()===t.FloatLiteral||e.getEntity()===t.IntLiteral}}oi=new WeakSet,za=function(e){const n=[];return(e.getParent()===void 0||e.getParent().is(t.GroupStatement)&&e.getParent().getParent()===void 0)&&n.push(O.createStatementSymptom(I.UnusedValue,[e],0,0)),n};class nd extends ne{constructor(e,n){super(e,n,t.FString,c.Literals,d.String);b(this,On);b(this,Ye);y(this,Ye,m(this,On,Qa).call(this));for(const s of u(this,Ye))for(const o of s)o.setParent(this),this.addConnection(o);this.addRule(m(this,On,Xa))}isStringLiteral(){return!0}matchesPattern(e){return e.getEntity()===t.StringLiteral||e.getEntity()===t.CombinedStringLiteral||e.getEntity()===t.FString}getVariableExpressions(){let e=[];for(let n of u(this,Ye))for(let s of n)s.is(t.VariableName)?e.push(s):e=e.concat(s.getVariableExpressions());return e}checkForSymptoms(){this.checkRules(this);for(const e of u(this,Ye))for(const n of e)n.checkForSymptoms()}checkForCounterRules(e){super.checkForCounterRules(e);for(const n of u(this,Ye))for(const s of n)s.checkForCounterRules(s)}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...u(this,Ye).flatMap(e=>e.flatMap(n=>n.getAllNestedExpressions()))]}toJSON(){const e=super.toJSON();return e.values=u(this,Ye).map(n=>n.map(s=>s.toJSON())),e}getValues(){return u(this,Ye)}}Ye=new WeakMap,On=new WeakSet,Qa=function(){const e=[];if(this.isComplete()){const n=this.getChildren()[1],s=n.getTextValue();let o=0,a=0,h=-1,p=-1;for(let w=0;w<s.length;w++)if(s.charAt(w)==="{")o===0&&(h=w+1),o++;else if(o>0)if(s.charAt(w)==="}"){if(o--,o===0){const S=p===-1?s.substring(h,w):s.substring(h,p),F=new Qn(S,n.getStartLineNumber(),n.getDocumentStartIndex());e.push(Q.createTree(F.getExpressions()))}}else s.charAt(w)==="["?a++:s.charAt(w)==="]"?a--:a===0&&s.charAt(w)===":"&&(p=w)}return e},Xa=function(e){const n=[];return(e.getParent()===void 0||e.getParent().is(t.GroupStatement)&&e.getParent().getParent()===void 0)&&n.push(O.createStatementSymptom(I.UnusedValue,[e],0,0)),n};class sd extends ne{constructor(e,n){super(e,n,t.CombinedStringLiteral,c.Literals,d.String);b(this,ri);this.addRule(m(this,ri,Za))}isStringLiteral(){return!0}matchesPattern(e){return e.getEntity()===t.StringLiteral||e.getEntity()===t.CombinedStringLiteral||e.getEntity()===t.FString}getVariableExpressions(){let e=[];for(let n of this.getChildren())e=e.concat(n.getVariableExpressions());return e}}ri=new WeakSet,Za=function(e){const n=[];return(e.getParent()===void 0||e.getParent().is(t.GroupStatement)&&e.getParent().getParent()===void 0)&&n.push(O.createStatementSymptom(I.UnusedValue,[e],0,0)),n};class jo extends nt{constructor(i,e,n,s,o,a){super(i,e,n,s,o,a,d.NA)}setDataType(i){throw new Error(`Cannot change the data type of a keyword or operator. Attempted to change the type to: ${i.name}.`)}setTextValue(i){throw new Error(`Cannot change the value of a keyword or operator. Attempted to change the value to ${i}.`)}matchesPattern(i){return this.getEntity()===i.getEntity()?!0:this.isOneOf([c.ComparisonOperators,c.LogicalOperators,c.MathsOperators])?i.getCategory():!1}}class Ho extends nt{constructor(e,n,s,o,a,h){super(e,n,s,o,a,h,Js(n));b(this,Ct);y(this,Ct,e)}hasAlias(){return u(this,Ct)!==this.getTextValue()}getModuleName(){return u(this,Ct)}setModuleName(e){y(this,Ct,e)}setDataType(e){throw new Error(`The data type of a module cannot be changed. Attempted to change the data type to ${e}.`)}setTextValue(e){throw new Error(`The text value of a module cannot be changed. Attempted to change the value to ${e}.`)}matchesPattern(e){return this.getEntity()===e.getEntity()===this.getTextValue()&&e.getTextValue()}toJSON(){const e=super.toJSON();return e.moduleAlias=u(this,Ct),e}}Ct=new WeakMap;class an extends nt{constructor(e,n,s,o,a,h,p=!1){var i=(...cf)=>(super(...cf),b(this,ce),b(this,Ot,[]),b(this,gs,!1),b(this,ps),b(this,ms,!1),this);if(s===c.Identifiers)i(e,n,s,o,a,h);else if(s===c.SpecialVariables)i(e,n,s,o,a,h,Js(n));else if(s===c.ModuleProperties)i(e,n,s,o,a,h,kt.has(n)?kt.get(n):d.Unknown);else throw new Error(`No constructor for VariableExpression with ${n.name}`);y(this,ps,p),this.addRules([m(this,ce,el),m(this,ce,_a)]),this.addCounterRules([m(this,ce,Ya)])}setTextValue(e){throw new Error(`Cannot change the text value of a variable (its name). Attempted to change the value to ${e}.`)}setIsParameter(){y(this,ms,!0)}isParameter(){return u(this,ms)}isSubscriptable(){return $s(this.getDataType())}getVariableExpressions(){return this.is(t.VariableName)?[this]:[]}setDataType(e){(!this.isAssignedOrChanged()||this.isObjectOfMethodCall()||this.isSubscripted())&&u(this,Ot).length>0&&(e=m(this,ce,mi).call(this)),super.setDataType(e),e.isCustom&&this.getParent()&&this.getParent().is(t.PropertyCallExpression)&&(this.getParent().getProperty().setCategory(c.ClassAttributes),this.getParent().getProperty().setOwnerType(e))}matchesPattern(e){let n=e;return n.is(t.BooleanExpression)&&e.getChildren().length===2&&e.getChildren()[0].is(t.NotOperator)&&e.getChildren()[1].is(t.VariableName)&&(n=e.getChildren()[1]),this.getEntity()===n.getEntity()&&this.getTextValue()===n.getTextValue()}getLastUsages(){return u(this,Ot)}addLastUsage(e){u(this,Ot).push(e),e.addConnection(this),(!this.isAssignedOrChanged()||this.isObjectOfMethodCall()||this.isSubscripted())&&(this.setDataType(m(this,ce,mi).call(this)),e.addObserver(this))}isSubscripted(){const e=this.getParent();return e===void 0?!1:e.is(t.SubscriptedExpression)}isObjectOfMethodCall(){const e=this.getParent();return e===void 0?!1:e.is(t.BuiltInMethodCall)&&e.getChildren()[0].getTextValue()===this.getTextValue()}setLastUsages(e){y(this,Ot,e),this.setDataType(m(this,ce,mi).call(this));for(let n of e)n.addObserver(this),n.addConnection(this)}isAssignedOrChanged(){return u(this,gs)}setAssignedOrChanged(){y(this,gs,!0)}isProxy(){return u(this,ps)}compareValues(e,n){const s=e.getParent();if(s===void 0)return Gs;const o=s.is(t.AssignmentStatement)?m(this,ce,uo).call(this,e):s.is(t.IteratorExpression)?m(this,ce,sl).call(this,e):void 0,a=m(this,ce,nl).call(this,o,n);return a.size===1?Array.from(a)[0]:Gs}}Ot=new WeakMap,gs=new WeakMap,ps=new WeakMap,ms=new WeakMap,ce=new WeakSet,mi=function(){return Dt(u(this,Ot).map(e=>e.getDataType()))},Ya=function(e){const n=[],s=e.getParent();if(e.isAssignedOrChanged()&&e.getLastUsages().length===0&&s&&s.is(t.IteratorExpression)){const o=s.getParent().getTextValue();n.push(O.createStatementSymptom(k.NewForLoopVar,[e],0,0,{usageText:o}))}return n},_a=function(e){const n=[];return(e.getParent()===void 0||e.getParent().is(t.GroupStatement)&&e.getParent().getParent()===void 0)&&n.push(O.createStatementSymptom(I.UnusedValue,[e],0,0)),n},el=function(e){var a;const n=[],s=e.getLastUsages(),o=e.getParent();if(!e.getScopeId().includes("listComprehension")&&!e.isProxy()&&e.isAssignedOrChanged()&&s.length>0&&o!==void 0&&o.isOneOf([t.AssignmentStatement,t.IteratorExpression])){if(o.is(t.AssignmentStatement)&&m(a=e,ce,tl).call(a,e.getTextValue(),o))return n;let h=!0;const p=e.getBlockId().split("-")[1];for(const w of s)if(w.getScopeId()===e.getScopeId()&&(!w.isAssignedOrChanged()||p!=="for"&&w.getBlockId()!==e.getBlockId())){h=!1;break}if(h){const w=s.length===1&&s[0].isParameter(),S=o.is(t.IteratorExpression)?o.getParent().getTextValue():o.getTextValue();n.push(O.createStatementSymptom(I.OverwrittenVariable,[e],0,0,{isParameter:w,functionBlock:w?s[0].getBlockId():"",prevUsageIsDefinition:s.length===1&&s[0].getLastUsages().length===0,overwriteType:o.is(t.AssignmentStatement)?yi:Ii,overwriteValue:e.compareValues(e,s),usageText:S,overwrittenVar:s.map(F=>({lineNum:F.getStartLineNumber(),block:F.getBlockId(),docIndex:F.getDocumentStartIndex(),forLoopDefinition:F.getParent().is(t.IteratorExpression)&&F.getParent().getLoopVariables().filter(N=>N.getTextValue()===F.getTextValue()).length>0}))}))}}return n},tl=function(e,n){const s=n.getAssignedValues();for(const o of s)if(o.getExpressionsOfKind(e).length>0)return!0;return!1},nl=function(e,n){const s=new Set;if(e!==void 0&&e.isOneOf([c.Literals,c.Types]))for(const o of n)if(o.getParent()!==void 0&&o.getParent().is(t.AssignmentStatement)){const a=m(this,ce,uo).call(this,o);a!==void 0&&a.isOneOf([c.Literals,c.Types])?s.add(e.getTextValue()===a.getTextValue()?Fi:Po):s.add(Gs)}else s.add(Gs);return s},sl=function(e){const n=e.getParent(),s=n.getIterable();if(s.is(t.BuiltInFunctionCall)){const o=s.getFunctionExpression();if(o.is(t.RangeFunction)){const a=s.getArguments();if(a.length===1)return new Mi("0",-1,-1,-1);if(a.length>1)return a[0][0]}else if(o.is(t.EnumerateFunction)){const a=n.getLoopVariables();if(a.length===2&&a[0].getTextValue()===e.getTextValue())return new Mi("0",-1,-1,-1)}}},uo=function(e){const n=e.getParent();if(n===void 0)return;const s=n.getTargetVariables(),o=n.getAssignedValues();let a=-1;for(let h=0;h<s.length;h++)if(s[h].getTextValue()===e.getTextValue()){a=h;break}if(a>-1&&a<o.length)return o[a]};class xi extends an{constructor(e,n,s,o,a,h){super(e,n,s,o,a,h);b(this,ws)}setDataType(e){if(this.is(t.PropertyName))super.setDataType(e);else throw new Error(`Cannot change the data type of an attribute of a built-in module. Attempted to change the data type to ${e.name}.`)}getVariableExpressions(){return[]}getOwnerType(){return u(this,ws)}setOwnerType(e){y(this,ws,e)}matchesPattern(e){return this.getEntity()===e.getEntity()&&this.getTextValue()===e.getTextValue()}}ws=new WeakMap;class zo extends nt{constructor(i,e,n,s,o,a,h=d.NotParsed){super(i,e,n,s,o,a,h)}setTextValue(i){throw new Error(`Cannot change the name of a function node. Attempted to change the name to ${i}.`)}isSubscriptable(){return $s(this.getDataType())}matchesPattern(i){return this.getEntity()===i.getEntity()&&this.getTextValue()===i.getTextValue()}}class Qo extends zo{constructor(e,n,s,o,a,h){super(e,n,s,o,a,h,d.NotParsed);b(this,Ss);b(this,it,[])}setDataType(e){const n=u(this,it).map(s=>s.getDataType());super.setDataType(Dt(n))}toJSON(){const e=this.getReturnStatements(),n=this.getParent(),s=n!==void 0&&n.isOneOf([t.FunctionDefinitionStatement,t.MethodDefinitionStatement])?n.getParameters().length:-1,o=n!==void 0&&n.isOneOf([t.FunctionDefinitionStatement,t.MethodDefinitionStatement])?n.getOptionalParameterCount():-1;return{name:this.getTextValue(),block:this.getBlockId(),callLineNumbers:Array.from(this.getObservers()).filter(a=>a.is(t.UserDefinedFunctionCall)).map(a=>a.getStartLineNumber()),hasReturn:e.length>0,hasBranchWithoutReturn:u(this,it).length>e.length,numOptionalParameters:o,parameters:s>-1?n.getParameters().flatMap(a=>a).map(a=>a.getTextValue()):[],returnDetail:e.map(a=>({line:a.getStartLineNumber(),dataType:a.getDataType().name})),returnTypes:e.length>0?Array.from(new Set(e.map(a=>a.getDataType().name))):["none"]}}addReturns(e,n=!1){for(const s of e)if(s.getFirstExpression().is(t.ReturnStatement)){const o=s.getFirstExpression();u(this,it).push(o);for(const a of this.getObservers())a.is(t.UserDefinedFunctionCall)&&(u(a.getFunctionExpression(),it).push(o),o.addConnection(a));o.addObserver(this)}else m(this,Ss,ho).call(this);n&&m(this,Ss,ho).call(this),this.setDataType()}getReturnType(){const e=u(this,it).map(n=>n.getDataType());return Dt(e)}getReturnStatements(){return u(this,it).filter(e=>e.is(t.ReturnStatement))}}it=new WeakMap,Ss=new WeakSet,ho=function(){const e=new an("proxy",t.VariableName,c.Identifiers,-1,-1,-1,!0);e.setDataType(d.None),u(this,it).push(e)};class id extends Qo{constructor(){super(...arguments);b(this,Tn,d.Class)}getContainingClass(){return u(this,Tn)}setContainingClass(e){y(this,Tn,e)}toJSON(){const e=super.toJSON();return e.containingClass=u(this,Tn).name,this.getTextValue()==="__init__"&&(e.hasReturn=!0,e.hasBranchWithoutReturn=!1,e.returnTypes=[e.containingClass]),e}}Tn=new WeakMap;class od extends zo{constructor(i,e,n,s,o,a){super(i,e,n,s,o,a,kt.get(e))}setDataType(i){if(this.getEntity()!==t.FunctionName)throw new Error(`Cannot set the data type of a built-in function. Attempted to set the data type to ${i}`);super.setDataType(i)}}class rd extends nt{constructor(e,n,s,o,a,h){var i=(...uf)=>(super(...uf),b(this,ai),this);if(n===t.TrueType||n===t.FalseType)i(e,n,s,o,a,h,d.Bool);else if(n===t.NoneType)i(e,n,s,o,a,h,d.None);else throw new Error(`Not a valid type value: ${n.name}`);this.addRule(m(this,ai,il))}setTextValue(e){throw new Error(`The text value of a built-in function cannot be changed. Attempted to change the value to ${e}.`)}setDataType(e){throw new Error(`Cannot set the data type of a built-in function. Attempted to set the data type to ${e}`)}matchesPattern(e){return e.getEntity()===t.TrueType||e.getEntity()===t.FalseType||e.getEntity()===t.NoneType}}ai=new WeakSet,il=function(e){const n=[];return(e.getParent()===void 0||e.getParent().is(t.GroupStatement)&&e.getParent().getParent()===void 0)&&n.push(O.createStatementSymptom(I.UnusedValue,[e],0,0)),n};class Di extends nt{constructor(i,e,n,s,o,a,h){super(i,e,n,s,o,a,h)}setTextValue(i){throw new Error(`The text value of a class or type cannot be changed. Attempted to change the value to ${i}.`)}matchesPattern(i){return this.getEntity()===i.getEntity()&&this.getTextValue()===i.getTextValue()}}class ad extends Di{constructor(i,e,n,s,o,a){super(i,e,n,s,o,a,d.Unknown)}setDataType(i){throw new Error(`Cannot change the data type of a built-in type. Attempted to set the data type to ${i}.`)}}class ld extends Di{constructor(i,e,n,s,o,a){super(i,e,n,s,o,a,d.Exception)}setDataType(i){throw new Error(`Cannot change the data type of a built-in type. Attempted to set the data type to ${i}.`)}}class cd extends Di{constructor(i,e,n,s,o,a){super(i,e,n,s,o,a,d.Class)}matchesPattern(i){return this.getEntity()===i.getEntity()&&this.getTextValue()===i.getTextValue()}}class Hs extends ne{constructor(e,n,s,o){const a=Js(s);super(e,n,s,c.CompoundTypes,a);b(this,li);b(this,ie);y(this,ie,o);for(let h=0;h<u(this,ie).length;h++)if(s!==t.DictDefinition){u(this,ie)[h].length>1&&(u(this,ie)[h]=Q.createTree(u(this,ie)[h]));for(const p of u(this,ie)[h])p.setParent(this),this.addConnection(p)}else for(let p=0;p<u(this,ie)[h].length;p++){u(this,ie)[h][p].length>1&&(u(this,ie)[h][p]=Q.createTree(u(this,ie)[h][p]));for(const w of u(this,ie)[h][p])w.setParent(this),this.addConnection(w)}this.addRule(m(this,li,ol))}isComplete(){this.getChildren().length>1}getVariableExpressions(){let e=[];for(let n of u(this,ie))for(let s of n)if(this.getEntity()!==t.DictDefinition)s.is(t.VariableName)?e.push(s):e=e.concat(s.getVariableExpressions());else for(let o of s)o.is(t.VariableName)?e.push(o):e=e.concat(o.getVariableExpressions());return e}contains(e){if(super.contains(e))return!0;for(let n of u(this,ie))for(let s of n)if(this.getEntity()!==t.DictDefinition){if(s.contains(e))return!0}else for(let o of s)if(o.contains(e))return!0;return!1}getExpressionsOfKind(e){let n=super.getExpressionsOfKind(e);for(let s of u(this,ie))for(let o of s)if(this.getEntity()!==t.DictDefinition)o.is(e)?n.push(o):n=n.concat(o.getExpressionsOfKind(e));else for(let a of o)a.is(e)?n.push(a):n=n.concat(a.getExpressionsOfKind(e));return n}getFirstExpressionOf(e){let n=super.getFirstExpressionOf(e);if(n===void 0)for(const s of u(this,ie))for(const o of s)if(this.getEntity()!==t.DictDefinition){if(o.isOneOf(e))return o;if(n=o.getFirstExpressionOf(e),n!==void 0)return n}else for(const a of o){if(a.isOneOf(e))return a;if(n=a.getFirstExpressionOf(e),n!==void 0)return n}return n}setDataType(e){throw new Error("Can't update the type of a compound expression")}checkForSymptoms(){this.checkRules(this);for(const e of u(this,ie))for(const n of e)if(this.getEntity()!==t.DictDefinition)n.checkForSymptoms();else for(const s of n)s.checkForSymptoms()}checkForCounterRules(e){super.checkForCounterRules(e);for(const n of u(this,ie))for(const s of n)if(this.getEntity()!==t.DictDefinition)s.checkForCounterRules(s);else for(const o of s)o.checkForCounterRules(o)}matchesPattern(e){return this.getEntity()===e.getEntity()}getAllNestedExpressions(){return this.getEntity()!==t.DictDefinition?[...super.getAllNestedExpressions(),...u(this,ie).flatMap(e=>e.flatMap(n=>n.getAllNestedExpressions()))]:[...super.getAllNestedExpressions(),...u(this,ie).flatMap(e=>e.flatMap(n=>n.flatMap(s=>s.getAllNestedExpressions())))]}toJSON(){const e=super.toJSON();try{e.elements=u(this,ie).map(n=>n.map(s=>s.toJSON()))}catch{e.elements=u(this,ie).map(s=>s.map(o=>o.map(a=>a.toJSON())))}return e}getElements(){return u(this,ie)}}ie=new WeakMap,li=new WeakSet,ol=function(e){const n=[];return(e.getParent()===void 0||e.getParent().is(t.GroupStatement)&&e.getParent().getParent()===void 0)&&n.push(O.createStatementSymptom(I.UnusedValue,[e],0,0)),n};class at extends ne{constructor(e,n,s){super(e,n,s,c.BlockDefinitionStatement,d.NA);b(this,Mn);b(this,de,[]);if(n.length>1){const o=m(this,Mn,rl).call(this);let a=Q.createTree(n.slice(1,o));if(s===t.ForDefinitionStatement&&a.length>0)if(a[0].is(t.IteratorExpression))y(this,de,a);else if(a[0].is(t.ComparisonExpression)){a[0]=a[0].convertToIterator(),y(this,de,[a[0]]);const h=a.slice(1).filter(p=>!p.is(t.Colon));h.length>0&&y(this,de,u(this,de).concat(h))}else a=[new ki(e,a)],y(this,de,a);else s===t.WithDefinitionStatement||s===t.ExceptDefinitionStatement?a.length===3&&a[1].is(t.AsKeyword)&&a[2].is(t.VariableName)&&y(this,de,[new Xo(e,a)]):y(this,de,a);for(const h of a)h.setParent(this),this.addConnection(h)}s===t.WhileDefinitionStatement&&this.addRule(m(this,Mn,al))}isComplete(){const e=this.getChildren();return e.length>=2?e[0].is(c.BlockDefinitions)&&e[e.length-1].is(t.Colon):!1}setDataType(e){throw new Error("Can't update the type of a block definition")}getVariableExpressions(){let e=[];for(let n of u(this,de))n.is(t.VariableName)?e.push(n):e=e.concat(n.getVariableExpressions());return e}getExpressionsOfKind(e){let n=super.getExpressionsOfKind(e);for(let s of u(this,de))s.is(e)?n.push(s):n=n.concat(s.getExpressionsOfKind(e));return n}getFirstExpressionOf(e){let n=super.getFirstExpressionOf(e);if(n===void 0)for(const s of u(this,de)){if(s.isOneOf(e))return s;if(n=s.getFirstExpressionOf(e),n!==void 0)return n}return n}checkForSymptoms(){this.checkRules(this);for(const e of u(this,de))e.checkForSymptoms()}checkForCounterRules(e){super.checkForCounterRules(e);for(const n of u(this,de))n.checkForCounterRules(n)}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...u(this,de).flatMap(n=>n.getAllNestedExpressions())]}getCondition(){return u(this,de)}toJSON(){const e=super.toJSON();return e.keyword=this.getChildren()[0].getTextValue(),e.condition=u(this,de).map(n=>n.toJSON()),e}getCondition(){return u(this,de)}getBlockEntity(){return this.getChildren()[0].getEntity()}}de=new WeakMap,Mn=new WeakSet,rl=function(){const e=this.getChildren();for(let n=e.length-1;n>=0;n--)if(e[n].is(t.Colon))return n;return e.length},al=function(e){const n=[],s=e.getChildren();if(e.is(t.WhileDefinitionStatement)){const o=u(e,de);fe(s,!0),o.length===1&&(o[0].is(t.TrueType)||o[0].is(t.GroupStatement)&&o[0].getContents().length===1&&o[0].getContents()[0].is(t.TrueType))&&n.push(O.createStatementSymptom(I.WhileTrue,s,0,s.length-1))}return n};class Xo extends ne{constructor(e,n){super(e,n,t.AssignmentStatement,c.Assignment,d.NotParsed);b(this,Z);b(this,te,[]);b(this,Te,[]);m(this,Z,ll).call(this),this.addRules([m(this,Z,ml),m(this,Z,hl),m(this,Z,fl)]),this.addCounterRules([m(this,Z,gl),m(this,Z,pl)])}getVariableExpressions(){let e=[];for(let n of u(this,Te))e=e.concat(n.getVariableExpressions());for(let n of u(this,te))e=e.concat(n.getVariableExpressions());return e}setDataType(e){e=Dt(u(this,te).map(n=>n.getDataType())),super.setDataType(e)}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...u(this,te).flatMap(n=>n.getAllNestedExpressions()),...u(this,Te).flatMap(n=>n.getAllNestedExpressions())]}toJSON(){const e=super.toJSON();return e.targets=u(this,te).map(n=>n.toJSON()),e.values=u(this,Te).map(n=>n.toJSON()),e}getTargetVariables(){return u(this,te)}getAssignedValues(){return u(this,Te)}}te=new WeakMap,Te=new WeakMap,Z=new WeakSet,ll=function(){const e=this.getChildren();on(e,t.AssignmentOperator)>0?m(this,Z,ul).call(this,e):on(e,t.AsKeyword)>0&&m(this,Z,cl).call(this,e)},cl=function(e){const n=Q.split(e,t.AsKeyword),s=[];for(let o=0;o<n.length;o++)s.push(Q.split(n[o],t.Comma));if(n.length===2&&s.length===2){for(let o of s[1])o[0].is(t.VariableName)?o[0].setAssignedOrChanged():o[0].is(t.PropertyCallExpression)&&o[0].getProperty().is(t.PropertyName)&&o[0].getProperty().setAssignedOrChanged(),u(this,te).push(o[0]);for(let o of s[0])u(this,Te).push(o[0])}u(this,te).length===u(this,Te).length?m(this,Z,fo).call(this):u(this,te).length>u(this,Te).length?m(this,Z,go).call(this):m(this,Z,po).call(this)},ul=function(e){const n=Q.split(e,t.AssignmentOperator),s=[];for(let o=0;o<n.length;o++){const a=Q.split(n[o],t.Comma);s.push(a)}if(n.length===2&&s.length===2){for(let o of s[0])o[0].is(t.VariableName)?o[0].setAssignedOrChanged():o[0].is(t.SubscriptedExpression)&&o[0].getChildren()[0].is(t.VariableName)?o[0].getChildren()[0].setAssignedOrChanged():o[0].is(t.PropertyCallExpression)&&o[0].getProperty().is(t.PropertyName)&&o[0].getProperty().setAssignedOrChanged(),u(this,te).push(o[0]);for(let o of s[1])u(this,Te).push(o[0])}u(this,te).length===u(this,Te).length?m(this,Z,fo).call(this):u(this,te).length>u(this,Te).length?m(this,Z,go).call(this):m(this,Z,po).call(this);for(const o of u(this,te))o.addObserver(this),this.addConnection(o);this.setDataType(Dt(u(this,te).map(o=>o.getDataType())))},fo=function(){for(let e=0;e<u(this,te).length;e++)u(this,te)[e].isOneOf([t.VariableName,t.SubscriptedExpression,t.PropertyCallExpression])?(u(this,te)[e].setDataType(u(this,Te)[e].getDataType()),u(this,Te)[e].addObserver(u(this,te)[e]),u(this,Te)[e].addConnection(u(this,te)[e])):u(this,te)[e].is(t.TupleDefinition)?m(this,Z,dl).call(this,u(this,te)[e]):u(this,te)[e].is(c.SpecialVariables)||this.setDataType(d.Invalid)},dl=function(e){for(let n of e.getElements())n[0].isOneOf([t.VariableName,t.SubscriptedExpression])&&n[0].setDataType(d.Unknown)},go=function(){for(let e of u(this,te))e.isOneOf([t.VariableName,t.SubscriptedExpression])?e.setDataType(d.Unknown):console.log("stop")},po=function(){for(let e of u(this,te))e.isOneOf([t.VariableName,t.SubscriptedExpression])?e.setDataType(d.Tuple):console.log("stop")},hl=function(e){const n=[];for(const s of e.getTargetVariables()){const o=Xe(s.getTextValue()).category;s.is(t.VariableName)&&s.getLastUsages().length===0&&o===c.BuiltInFunctions?n.push(O.createStatementSymptom(I.VariableWithSameNameAsFunction,[s],0,0,{funcType:sn,varIsParameter:s.isParameter()})):(o===c.BlockDefinitions||o===c.LogicalOperators||o===c.Types||o===c.OtherKeywords)&&s.getTextValue()!=="f"&&s.getTextValue()!=="r"&&n.push(O.createStatementSymptom(I.ReservedWordAssigned,[s],0,0))}return n},fl=function(e){const n=[],s=e.getAssignedValues();for(let o=0;o<s.length;o++)s[o].is(t.Colon)&&n.push(O.createStatementSymptom(I.UnexpectedColon,s,0,s.length-1,{before:o>0?s[o-1].getTextValue():we,after:o<s.length-1?s[o+1].getTextValue():we}));return n},gl=function(e){const n=[],s=e.getTargetVariables(),o=e.getAssignedValues();return s.length>0&&o.length>0&&n.push(O.createStatementSymptom(k.ValidAssignment,e.getChildren(),0,e.getChildren().length-1,{before:s[s.length-1].getTextValue(),after:o[0].getTextValue()})),n},pl=function(e){const n=[],s=e.getTargetVariables(),o=e.getAssignedValues();return s.length===1&&o.length===1&&o[0].getDataType()===d.Bool&&!o[0].isOneOf([t.TrueType,t.FalseType])&&n.push(O.createStatementSymptom(k.NonLiteralBooleanAssigned,e.getChildren(),0,e.getChildren().length-1,{assignedToVariable:s[0].getTextValue(),expression:o[0].getTextValue()})),n},ml=function(e){const n=[],a=e.getAssignedValues().flatMap(h=>h.is(t.GroupStatement)?h.getContents():h).filter(h=>Bt(h)||h.getDataType()===d.None&&!h.isOneOf([t.NoneType,t.VariableName]));return a.length>0&&n.push(...a.map(h=>O.createStatementSymptom(I.AssignedNone,[h],0,0,{expression:h,usage:yi,target:u(e,te)[0].getTextValue()}))),n};class ud extends ne{constructor(e,n){super(e,n,t.ChangeStatement,c.Assignment,d.NA);b(this,qe);b(this,We,[]);b(this,Ge,-1);b(this,xn,[]);b(this,dt);m(this,qe,wl).call(this),this.addRule(m(this,qe,yl))}getVariableExpressions(){let e=[];for(let n of u(this,xn))e=e.concat(n.getVariableExpressions());for(let n of u(this,We))e=e.concat(n.getVariableExpressions());return e}getAssignedValue(){return u(this,dt)}getTargetVariables(){return u(this,We)}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...u(this,We).flatMap(n=>n.getAllNestedExpressions()),...u(this,dt).getAllNestedExpressions()]}toJSON(){const e=super.toJSON();return e.target=u(this,We)[0].toJSON(),e.operator=this.getChildren()[u(this,Ge)].toJSON(),e.changeValue=u(this,dt).toJSON(),e}}We=new WeakMap,Ge=new WeakMap,xn=new WeakMap,dt=new WeakMap,qe=new WeakSet,wl=function(){m(this,qe,Il).call(this);const e=this.getChildren();if(u(this,Ge)===1&&e.length===3)e[0].is(t.VariableName)?e[0].setAssignedOrChanged():e[0].is(t.SubscriptedExpression)&&e[0].getChildren()[0].is(t.VariableName)?e[0].getChildren()[0].setAssignedOrChanged():e[0].is(t.PropertyCallExpression)&&e[0].getProperty().is(t.PropertyName)&&e[0].getProperty().setAssignedOrChanged(),u(this,We).push(e[0]),y(this,dt,e[2]),this.addConnection(e[0]),e[2].addConnection(e[0]),e[0].isOneOf([t.VariableName,t.SubscriptedExpression])?m(this,qe,Sl).call(this):this.setDataType(d.Invalid);else if(u(this,Ge)===1&&e.length>3&&jn(e,t.Comma)){this.setDataType(d.Tuple);const n=e.slice(2),s=Q.split(n,t.Comma),o=new Hs(fe(n),n,t.TupleDefinition,s);for(o.setParent(this);e.length>2;)e.pop();e.push(o),u(this,We).push(e[0]),y(this,dt,e[2])}else this.setDataType(d.Invalid),y(this,dt,e[u(this,Ge)-1]),y(this,We,u(this,Ge)>-1?e.slice(0,u(this,Ge)):[]),y(this,xn,u(this,Ge)>-1?e.slice(u(this,Ge)+1):[])},Sl=function(){const e=m(this,qe,bl).call(this),n=u(this,We)[0],s=[new jo(e.entity.name,e.entity,e.category,-1,-1),this.getChildren()[2]];if(n.is(t.VariableName)){const a=new an(n.getTextValue(),n.getEntity(),n.getCategory(),-1,-1,-1,!0);s.unshift(a)}else{const a=n.getChildren(),h=new zs("Placeholder",[a[0],a[1]]);s.unshift(h)}const o=new Qs("Placeholder",s);u(this,xn).push(o),n.setDataType(o.getDataType()),o.addObserver(n)},bl=function(){const n=this.getChildren()[u(this,Ge)].getTextValue().replace("=","");return Xe(n)},Il=function(){const e=this.getChildren();for(let n=0;n<e.length;n++)if(e[n].isChangeOperator()){y(this,Ge,n);break}},yl=function(e){const n=[],s=e.getAssignedValue();return(s.getDataType()===d.None&&!s.isOneOf([t.NoneType,t.VariableName])||Bt(s))&&n.push(O.createStatementSymptom(I.AssignedNone,[s],0,0,{expression:s,usage:yi,target:u(e,We)[0].getTextValue()})),n};class dd extends ne{constructor(e,n){super(e,n,t.GroupStatement,c.Group,d.NotParsed);b(this,Dn);b(this,re);if(n.length>2){const s=n.slice(1,n.length-1);s.length>1?y(this,re,Q.createTree(n.slice(1,n.length-1))):y(this,re,[s[0]])}else y(this,re,[]);m(this,Dn,Fl).call(this),this.setDataType(u(this,re).length===1?u(this,re)[0].getDataType():d.Unknown),u(this,re).length===1?u(this,re)[0].addObserver(this):this.setDataType(d.Invalid),this.addRule(m(this,Dn,Nl))}getContents(){return u(this,re)}getVariableExpressions(){let e=[];for(let n of u(this,re))e=e.concat(n.getVariableExpressions());return e}getExpressionsOfKind(e){let n=super.getExpressionsOfKind(e);for(let s of u(this,re))s.is(e)?n.push(s):n=n.concat(s.getExpressionsOfKind(e));return n}getFirstExpressionOf(e){let n=super.getFirstExpressionOf(e);if(n===void 0)for(const s of u(this,re)){if(s.isOneOf(e))return s;if(n=s.getFirstExpressionOf(e),n!==void 0)return n}return n}checkForSymptoms(){this.checkRules(this);for(const e of u(this,re))e.checkForSymptoms()}checkForCounterRules(e){super.checkForCounterRules(e);for(const n of u(this,re))n.checkForCounterRules(n)}matchesPattern(e){const n=this.getContents();for(const s of n)if(!s.matchesPattern(e))return!1;return!0}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...u(this,re).flatMap(n=>n.getAllNestedExpressions())]}toJSON(){const e=super.toJSON();return e.contents=u(this,re).map(n=>n.toJSON()),e}}re=new WeakMap,Dn=new WeakSet,Fl=function(){for(let e=0;e<u(this,re).length;e++)e<u(this,re).length-1&&u(this,re)[e].addConnection(u(this,re)[e+1]),u(this,re)[e].setParent(this),this.addConnection(u(this,re)[e])},Nl=function(e){const n=[],s=e.getContents();for(let o=0;o<s.length;o++)s[o].is(t.Colon)&&n.push(O.createStatementSymptom(I.UnexpectedColon,s,0,s.length-1,{before:o>0?s[o-1].getTextValue():we,after:o<s.length-1?s[o+1].getTextValue():we}));return n};class Zo extends ne{constructor(e,n,s=[]){super(e,n,t.Slice,c.Other,d.NA);b(this,De);y(this,De,s);for(let o=0;o<u(this,De).length;o++){u(this,De)[o].length>1&&(u(this,De)[o]=Q.createTree(u(this,De)[o]));for(const a of u(this,De)[o])a.setParent(this),this.addConnection(a)}}isComplete(){const e=this.getChildren();return e.length>=4&&e[0].is(t.OpenSquareBracket)&&e[e.length-1].is(t.CloseSquareBracket)&&jn(e,t.Colon)}getVariableExpressions(){let e=[];for(let n of u(this,De))for(let s of n)e=e.concat(s.getVariableExpressions());return e}checkForSymptoms(){this.checkRules(this);for(const e of u(this,De))for(const n of e)n.checkForSymptoms()}checkForCounterRules(e){super.checkForCounterRules(e);for(const n of u(this,De))for(const s of n)s.checkForCounterRules(s)}matchesPattern(e){return this.getEntity()===e.getEntity()}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...u(this,De).flatMap(n=>n.flatMap(s=>s.getAllNestedExpressions()))]}toJSON(){const e=super.toJSON();return e.indices=u(this,De).map(n=>n.map(s=>s.toJSON())),e}getIndices(){return u(this,De)}}De=new WeakMap;class Yo extends ne{constructor(e,n){super(e,n,t.IndexKey,c.Other,d.NA);b(this,ot,[]);n.length>2&&y(this,ot,Q.createTree(n.slice(1,n.length-1)));for(const s of u(this,ot))s.setParent(this),this.addConnection(s)}isComplete(){const e=this.getChildren();return e.length>=3&&e[0].is(t.OpenSquareBracket)&&e[e.length-1].is(t.CloseSquareBracket)}getVariableExpressions(){let e=[];for(let n of u(this,ot))e=e.concat(n.getVariableExpressions());return e}checkForSymptoms(){this.checkRules(this);for(const e of u(this,ot))e.checkForSymptoms()}checkForCounterRules(e){super.checkForCounterRules(e);for(const n of u(this,ot))n.checkForCounterRules(n)}matchesPattern(e){return this.getEntity()===e.getEntity()}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...u(this,ot).flatMap(n=>n.getAllNestedExpressions())]}toJSON(){const e=super.toJSON();return e.index=u(this,ot).map(n=>n.toJSON()),e}}ot=new WeakMap;const Is=class Is extends ne{constructor(e,n){var o;let s=m(o=Is,bs,mo).call(o,n);super(e,n,t.SubscriptedExpression,c.MultipartValue,s);b(this,An);n[0].addObserver(this);for(const a of n)this.addConnection(a);this.addRules([m(this,An,Ol),m(this,An,Cl)])}matchesPattern(e){if(this.getEntity()!==e.getEntity())return!1;const n=this.getChildren(),s=e.getChildren();return n.length>0&&s.length>0&&n[0].matchesPattern(s[0])}isComplete(){const e=this.getChildren();return e.length===2&&e[1].isOneOf(t.IndexKey,t.Slice)}setDataType(e){var s;const n=m(s=Is,bs,mo).call(s,this.getChildren());super.setDataType(n)}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...this.getChildren().flatMap(n=>n.getAllNestedExpressions())]}toJSON(){const e=super.toJSON();return e.nodes=this.getChildren().map(n=>n.toJSON()),e}};An=new WeakSet,Cl=function(e){const n=[];return(e.getParent()===void 0||e.getParent().is(t.GroupStatement)&&e.getParent().getParent()===void 0)&&n.push(O.createStatementSymptom(I.UnusedValue,[e],0,0)),n},Ol=function(e){const n=[],s=e.getChildren();return s.length>0&&!$s(s[0].getDataType())&&n.push(O.createStatementSymptom(I.SubscriptedNonSubscriptable,s,0,s.length-1,{isUndefined:s[0].getDataType()===d.Undefined,subscriptedType:s[0].getDataType(),varName:s[0].getTextValue()})),n},bs=new WeakSet,mo=function(e){if(e.length!==2)return d.Unknown;if(e[0].getDataType()===d.String)return d.String;if(e[1].is(t.Slice)){const n=e[0].getDataType();return n===d.NotParsed||n===d.Unknown||n===d.List||n===d.Tuple||n===d.String?n:d.Invalid}return d.Unknown},b(Is,bs);let zs=Is;const Ht=class Ht extends ne{constructor(e,n){var o,a;let s=n.length===3?m(o=Ht,rt,wo).call(o,...n):n.length===2?m(a=Ht,rt,So).call(a,n[1]):d.Unknown;super(e,n,t.CalculatedExpression,c.MultipartValue,s);b(this,je);n.length===3?(n[0]!==void 0&&n[0].addObserver(this),n[2]!==void 0&&n[2].addObserver(this)):n.length>0&&n[1]!==void 0&&n[1].addObserver(this),m(this,je,Tl).call(this),this.addRules([m(this,je,Bl),m(this,je,Al),m(this,je,Dl),m(this,je,xl)])}setDataType(e){var s,o;const n=this.getChildren();e=n.length===3?m(s=Ht,rt,wo).call(s,...n):m(o=Ht,rt,So).call(o,n[1]),super.setDataType(e)}matchesPattern(e){if(this.getEntity()!==e.getEntity())return!1;const n=this.getChildren(),s=e.getChildren();if(n.length!==s.length)return!1;const o=new Map;for(const a of n){let h=!1;for(const p of s)if(a.matchesPattern(p)){h=!0;break}if(!h&&!a.is(t.VariableName))return!1;a.is(t.VariableName)&&o.set(a.getTextValue(),h)}return o.size===0?!0:Array.from(o.values()).filter(a=>a===!0).length>0}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...this.getChildren().flatMap(n=>n.getAllNestedExpressions())]}toJSON(){const e=super.toJSON();return e.nodes=this.getChildren().map(n=>n.toJSON()),e}};je=new WeakSet,Tl=function(){const e=this.getChildren();for(let n=0;n<e.length;n++)this.addConnection(e[n]),n<e.length-1&&e[n].addConnection(e[n+1])},rt=new WeakSet,wo=function(e,n,s){const o=e.getDataType(),a=s.getDataType();return e.is(t.StringLiteral)&&n.is(t.ModulusOperator)?d.String:o===d.NotParsed||a===d.NotParsed?d.NotParsed:o===d.Undefined&&e.is(t.VariableName)&&e.isProxy()||a===d.Undefined&&s.is(t.VariableName)&&s.isProxy()?d.Undefined:o===d.Unknown||a===d.Unknown?d.Unknown:o===d.Invalid||a===d.Invalid||o===d.NA||a===d.NA?d.Invalid:e.isNumeric()&&s.isNumeric()?m(this,rt,Ml).call(this,e,n,s):n.isOneOf([t.ExponentOperator,t.DivideOperator,t.IntDivideOperator])?d.Invalid:n.is(t.MultiplyOperator)?e.isNonFloatNumeric()&&(a===d.String||a===d.List||a===d.Tuple)?a:s.isNonFloatNumeric()&&(o===d.String||o===d.List||o===d.Tuple)?o:d.Invalid:n.is(t.ModulusOperator)?o===d.String?d.String:d.Invalid:n.is(t.AddOperator)?o===a&&(o===d.String||o===d.List||o===d.Tuple)||o===d.List&&(a===d.String||a===d.Dict||a===d.Set||a===d.Tuple)?o:d.Invalid:n.is(t.SubtractOperator)&&o===d.Set&&o===a?o:d.Invalid},So=function(e){const n=e.getDataType();return n===d.Float||n===d.Int||n===d.Number||n===d.NotParsed||n===d.Unknown?n:n===d.Bool?d.Int:d.Invalid},Ml=function(e,n,s){return n.is(t.DivideOperator)?d.Float:e.getDataType()===s.getDataType()&&e.getDataType()!==d.Bool?e.getDataType():e.isIntLike()&&s.isIntLike()?d.Int:e.getDataType()===d.Float||s.getDataType()===d.Float?d.Float:d.Number},xl=function(e){const n=[];return(e.getParent()===void 0||e.getParent().is(t.GroupStatement)&&e.getParent().getParent()===void 0)&&n.push(O.createStatementSymptom(I.UnusedValue,[e],0,0)),n},Dl=function(e){const n=[],s=e.getChildren();for(let o=0;o<s.length;o++)s[o].is(t.Colon)&&n.push(O.createStatementSymptom(I.UnexpectedColon,s,0,s.length-1,{before:o>0?s[o-1].getTextValue():we,after:o<s.length-1?s[o+1].getTextValue():we}));return n},Al=function(e){const n=[],s=e.getChildren();return e.getDataType()===d.Invalid&&s.filter(o=>o.getDataType()===d.Undefined||o.getDataType()===d.Invalid).length===0&&n.push(O.createStatementSymptom(I.TypeErrorInvalid,s,0,s.length-1,{parts:s.map(o=>o.getDataType()===d.NA?o.getTextValue():o.getDataType().name)})),n},Bl=function(e){const n=[],a=e.getChildren().flatMap(h=>h.is(t.GroupStatement)?h.getContents():h).filter(h=>Bt(h)||h.getDataType()===d.None&&!h.isOneOf([t.NoneType,t.VariableName]));return a.length>0&&n.push(...a.map(h=>O.createStatementSymptom(I.AssignedNone,[h],0,0,{expression:h,usage:Hc}))),n},b(Ht,rt);let Qs=Ht;const Fs=class Fs extends ne{constructor(e,n){var o;let s=n.length===3?m(o=Fs,ys,bo).call(o,...n):d.Unknown;super(e,n,t.ComparisonExpression,c.MultipartValue,s);b(this,He);n.length===3&&(n[0].addObserver(this),n[2].addObserver(this)),m(this,He,kl).call(this),this.addRules([m(this,He,vl),m(this,He,Ll),m(this,He,Vl),m(this,He,Pl)])}setDataType(e){var s;const n=m(s=Fs,ys,bo).call(s,...this.getChildren());n!==this.getDataType()&&super.setDataType(n)}matchesPattern(e){if(this.getEntity()!==e.getEntity())return!1;const n=this.getChildren(),s=e.getChildren();if(n.length!==s.length)return!1;const o=new Map;for(let a=0;a<n.length;a++){if(n[a].isOneOf([t.InKeyword,t.NotInKeyword])){const p=n[a].is(t.InKeyword)?t.NotInKeyword:t.InKeyword;for(let w=0;w<s.length;w++)if(s[w].is(p))return a>0&&a<n.length-1&&w>0&&w<s.length-1?n[a-1].matchesPattern(s[w-1])&&n[a+1].matchesPattern(s[w+1]):!1;return!1}let h=!1;for(const p of s)if(n[a].matchesPattern(p)){h=!0;break}if(!h&&!n[a].isOneOf([t.VariableName,t.BuiltInFunctionCall,t.UserDefinedFunctionCall,t.SubscriptedExpression]))return!1;n[a].isOneOf([t.VariableName,t.BuiltInFunctionCall,t.UserDefinedFunctionCall,t.SubscriptedExpression,t.CalculatedExpression])&&o.set(n[a].getTextValue(),h)}return o.size===0?!1:Array.from(o.values()).filter(a=>a===!0).length>0}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...this.getChildren().flatMap(n=>n.getAllNestedExpressions())]}toJSON(){const e=super.toJSON();return e.nodes=this.getChildren().map(n=>n.toJSON()),e}convertToIterator(){const e=this.getChildren();return e.length===3&&(e[0].removeObserver(this),e[2].removeObserver(this)),new ki(this.getTextValue(),e)}};He=new WeakSet,kl=function(){const e=this.getChildren();for(let n=0;n<e.length;n++)this.addConnection(e[n]),n<e.length-1&&e[n].addConnection(e[n+1])},ys=new WeakSet,bo=function(e,n,s){const o=e.getDataType(),a=s.getDataType();return n.isOneOf([t.EqualOperator,t.NotEqualOperator,t.IsKeyword,t.IsNotKeyword])?d.Bool:n.isOneOf([t.InKeyword,t.NotInKeyword])?a===d.String&&(o===d.String||o===d.Unknown||o===d.NotParsed)||a===d.List||a===d.Tuple||a===d.Set||a===d.Dict||a===d.Unknown?d.Bool:a===d.NotParsed?d.NotParsed:d.Invalid:o===d.NotParsed||a===d.NotParsed?d.NotParsed:o===d.None||a===d.None?d.Invalid:o===d.Unknown||a===d.Unknown||e.isNumeric()&&s.isNumeric()||o===a?d.Bool:d.Invalid},Pl=function(e){const n=[],s=e.getChildren();return!(s[0]!==void 0&&s[0].is(t.BuiltInFunctionCall)&&s[0].getFunctionExpression().is(t.AssertFunction))&&(e.getParent()===void 0||e.getParent().is(t.GroupStatement)&&e.getParent().getParent()===void 0)&&n.push(O.createStatementSymptom(I.UnusedValue,[e],0,0)),n},Vl=function(e){const n=[],s=e.getChildren();for(let o=0;o<s.length;o++)s[o].is(t.Colon)&&n.push(O.createStatementSymptom(I.UnexpectedColon,s,0,s.length-1,{before:o>0?s[o-1].getTextValue():we,after:o<s.length-1?s[o+1].getTextValue():we}));return n},Ll=function(e){const n=[],s=e.getChildren();return s.length===3&&s[0].getDataType()===d.Bool&&s[1].isOneOf([t.EqualOperator,t.IsKeyword])&&s[2].isOneOf([t.TrueType,t.FalseType])&&n.push(O.createStatementSymptom(I.CompareBoolLiteral,s,0,s.length-1,{boolValue:s[0].getTextValue(),operator:s[1].getTextValue(),boolLiteral:s[2].getTextValue(),usedIn:e.getContextOfUse()})),n},vl=function(e){const n=[],a=e.getChildren().flatMap(h=>h.is(t.GroupStatement)?h.getContents():h).filter(h=>!(h.is(t.BuiltInFunctionCall)&&h.getFunctionExpression().is(t.AssertFunction))&&(Bt(h)||h.getDataType()===d.None&&!h.isOneOf([t.NoneType,t.VariableName])));return a.length>0&&n.push(...a.map(h=>O.createStatementSymptom(I.AssignedNone,[h],0,0,{expression:h,usage:zc}))),n},b(Fs,ys);let Ai=Fs;const Cs=class Cs extends ne{constructor(e,n){var o;const s=m(o=Cs,Ns,Io).call(o,n);super(e,n,t.BooleanExpression,c.MultipartValue,s);b(this,_e);n.length===3&&n[1].is(c.LogicalOperators)&&(n[0].addObserver(this),n[2].addObserver(this)),m(this,_e,Rl).call(this),this.addRules([m(this,_e,Gl),m(this,_e,Ul),m(this,_e,El)])}setDataType(e){var s;const n=m(s=Cs,Ns,Io).call(s,this.getChildren());n!==this.getDataType()&&super.setDataType(n)}matchesPattern(e){const n=this.getChildren();if(this.getEntity()!==e.getEntity())return e.is(t.VariableName)&&n.length===2&&n[0].is(t.NotOperator)&&n[1].is(t.VariableName)?n[1].matchesPattern(e):!1;const s=e.getChildren(),o=new Map;for(const a of n){if(a.is(t.NotOperator))continue;let h=!1;for(const p of s)if(!p.is(t.NotOperator)&&a.matchesPattern(p)){h=!0;break}if(!h&&!a.is(t.VariableName))return!1;a.is(t.VariableName)&&o.set(a.getTextValue(),h)}return o.size===0?!0:Array.from(o.values()).filter(a=>a===!0).length>0}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...this.getChildren().flatMap(n=>n.getAllNestedExpressions())]}toJSON(){const e=super.toJSON();return e.nodes=this.getChildren().map(n=>n.toJSON()),e}};_e=new WeakSet,Rl=function(){const e=this.getChildren();for(let n=0;n<e.length;n++)this.addConnection(e[n]),n<e.length-1&&e[n].addConnection(e[n+1])},Ns=new WeakSet,Io=function(e){if(e.length===2&&e[0].is(t.NotOperator))return d.Bool;if(e.length===3&&e[1].is(c.LogicalOperators)){const n=e[0].getDataType(),s=e[2].getDataType();return n===s?n:n===d.NotParsed||s===d.NotParsed?d.NotParsed:d.Unknown}else return d.Invalid},El=function(e){const n=[];return(e.getParent()===void 0||e.getParent().is(t.GroupStatement)&&e.getParent().getParent()===void 0)&&n.push(O.createStatementSymptom(I.UnusedValue,[e],0,0)),n},Ul=function(e){const n=[],s=e.getChildren();for(let o=0;o<s.length;o++)s[o].is(t.Colon)&&n.push(O.createStatementSymptom(I.UnexpectedColon,s,0,s.length-1,{before:o>0?s[o-1].getTextValue():we,after:o<s.length-1?s[o+1].getTextValue():we}));return n},af=function(e,n){const s=e.getDataType(),o=n.getDataType();return s!==d.Bool&&s!==d.Unknown||o!==d.Bool&&o!==d.Unknown},Gl=function(e){const n=[],s=e.getChildren();if(s.length===3){const o=s[0].getDataType(),a=s[2].getDataType();(o!==d.Bool&&o!==d.Unknown||a!==d.Bool&&a!==d.Unknown)&&n.push(O.createStatementSymptom(I.NaturalLanguageBoolean,s,0,2,{form:Kc,leftSideType:s[0].getDataType(),leftSideText:s[0].getTextValue(),leftSideEntity:s[0].getEntity(),operator:s[1].getTextValue(),rightSideType:s[2].getDataType(),rightSideText:s[2].getTextValue(),rightSideEntity:s[2].getEntity(),tempExpression:e}))}return n},b(Cs,Ns);let Bi=Cs;class ki extends ne{constructor(e,n){super(e,n,t.IteratorExpression,c.MultipartValue,d.NA);b(this,Ae);b(this,Bn);b(this,he);b(this,ae,[]);m(this,Ae,$l).call(this),m(this,Ae,Jl).call(this),this.addRules([m(this,Ae,ql),m(this,Ae,Wl)])}checkForSymptoms(){this.checkRules(this),u(this,he).checkForSymptoms();for(const e of u(this,ae))e.checkForSymptoms()}checkForCounterRules(e){super.checkForCounterRules(e),u(this,he).checkForCounterRules(u(this,he));for(const n of u(this,ae))n.checkForCounterRules(n)}getVariableExpressions(){let e=u(this,he).getVariableExpressions();for(let n of u(this,ae))e=e.concat(n.getVariableExpressions());return e}setDataType(e){m(this,Ae,yo).call(this)}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...u(this,ae).flatMap(n=>n.getAllNestedExpressions()),...u(this,he).getAllNestedExpressions()]}toJSON(){const e=super.toJSON();return e.loopVariables=u(this,ae).map(n=>n.toJSON()),e.iterable=u(this,he).toJSON(),e}getLoopVariables(){return u(this,ae)}getIterable(){return u(this,he)}}Bn=new WeakMap,he=new WeakMap,ae=new WeakMap,Ae=new WeakSet,Jl=function(){const e=this.getChildren();for(let n=0;n<e.length;n++)this.addConnection(e[n]),n<e.length-1&&e[n].addConnection(e[n+1])},$l=function(){const e=this.getChildren();y(this,Bn,on(e,t.InKeyword)),y(this,he,e[e.length-1]),y(this,ae,u(this,Bn)===1&&e[0].is(t.TupleDefinition)?e[0].getElements().filter(n=>n[0].is(t.VariableName)).map(n=>n[0]):e.slice(0,u(this,Bn)).filter(n=>n.is(t.VariableName)));for(let n of u(this,ae))n.setAssignedOrChanged();m(this,Ae,Kl).call(this)},Kl=function(){if(u(this,he).isOneOf([t.BuiltInFunctionCall,t.BuiltInMethodCall])){const e=u(this,he).is(t.BuiltInMethodCall)?u(this,he).getMethodEntity():u(this,he).getFunctionEntity();if(e===t.EnumerateFunction)if(u(this,ae).length===1)u(this,ae)[0].setDataType(d.Tuple);else if(u(this,ae).length===2){u(this,ae)[0].setDataType(d.Int);const n=u(this,he).getArguments(),s=n.length===1&&n[0].length===1&&n[0][0].getDataType()===d.String?d.String:d.Unknown;u(this,ae)[1].setDataType(s)}else for(const n of u(this,ae))n.setDataType(d.Unknown);else if(e===t.RangeFunction&&u(this,ae).length===1)u(this,ae)[0].setDataType(d.Int);else if(kt.get(e)===d.String&&u(this,ae).length===1)u(this,ae)[0].setDataType(d.String);else for(const n of u(this,ae))n.setDataType(d.Unknown)}else u(this,he).addObserver(this),m(this,Ae,yo).call(this)},yo=function(){const e=u(this,he).getDataType()===d.String||u(this,he).getDataType()===d.File?d.String:d.Unknown;for(let n of u(this,ae))n.setDataType(e)},Wl=function(e){const n=[],s=u(e,he).getVariableExpressions();for(const o of u(e,ae))for(const a of s)if(o.getTextValue()===a.getTextValue()){const h=o.getLastUsages(),p=a.getLastUsages().length>0&&a.getLastUsages()[0].isParameter();n.push(O.createStatementSymptom(I.OverwrittenVariable,[o],0,0,{isParameter:p,functionBlock:p?h[0].getBlockId():"",prevUsageIsDefinition:!1,overwriteType:$c,overwriteValue:o.compareValues(o,[h[h.length-1]]),usageText:e.getParent().getTextValue(),overwrittenVar:[{lineNumber:h[h.length-1].getStartLineNumber(),blockId:h[h.length-1].getBlockId(),docIndex:h[h.length-1].getDocumentStartIndex(),forLoopDefinition:h[h.length-1].getParent().is(t.IteratorExpression)&&h[h.length-1].getParent().getLoopVariables().filter(w=>w.getTextValue()===h[h.length-1].getTextValue()).length>0}]}))}return n},ql=function(e){const n=[],s=e.getChildren();for(let o=0;o<s.length;o++)s[o].is(t.Colon)&&n.push(O.createStatementSymptom(I.UnexpectedColon,s,0,s.length-1,{before:o>0?s[o-1].getTextValue():we,after:o<s.length-1?s[o+1].getTextValue():we}));return n};class hd extends ne{constructor(e,n){if(n.length<4)throw new Error("A lambda expression must have a minimum of 4 children");const s=Q.split(n.slice(1),t.Colon);if(s.length!==2)throw new Error("Lambda expects at least one argument and a return value");const o=Q.split(s[0],t.Comma);for(const h of o)for(const p of h)p.is(t.VariableName)&&(p.setAssignedOrChanged(),p.setDataType(d.Unknown));const a=Q.createTree(s[1]);if(a.length!==1)throw new Error("Lambda can only have one return value");super(e,n,t.LambdaDefinitionStatement,c.BlockDefinitions,a[0].getDataType());b(this,Os);b(this,Ts);y(this,Os,o),y(this,Ts,a[0]),a[0].addObserver(this)}getVariableExpressions(){let e=[];for(let n of this.getChildren())n.is(t.VariableName)?e.push(n):e=e.concat(n.getVariableExpressions());return e}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...this.getChildren().flatMap(n=>n.getAllNestedExpressions())]}toJSON(){const e=super.toJSON();return e.arguments=u(this,Os).map(n=>n.map(s=>s.toJSON())),e.return=u(this,Ts).toJSON(),e}}Os=new WeakMap,Ts=new WeakMap;const xs=class xs extends ne{constructor(e,n){var o;if(n.length!==5)throw new Error("Ternary should contain 5 children");let s=m(o=xs,Ms,Fo).call(o,n);super(e,n,t.TernaryStatement,c.BlockDefinitionStatement,s);b(this,kn);n[0].addObserver(this),n[4].addObserver(this),this.addRule(m(this,kn,jl)),this.addCounterRule(m(this,kn,Hl))}setDataType(e){var s;const n=m(s=xs,Ms,Fo).call(s,this.getChildren());n!==this.getDataType()&&super.setDataType(n)}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...this.getChildren().flatMap(n=>n.getAllNestedExpressions())]}toJSON(){const e=super.toJSON();return e.nodes=this.getChildren().map(n=>n.toJSON()),e}};Ms=new WeakSet,Fo=function(e){return e.length===5?Dt([e[0].getDataType(),e[4].getDataType()]):d.Unknown},kn=new WeakSet,jl=function(e){const n=[];if(e.getDataType()===d.Bool){const s=e.getChildren();if(s[0].is(t.TrueType)&&s[4].is(t.FalseType)){let o=e.getParent();for(;o.is(t.GroupStatement);)o=o.getParent();const a=h=>{switch(h){case t.ReturnStatement.name:return"return";case t.AssignmentStatement.name:return"assignment";default:return"unknown"}};n.push(O.createStatementSymptom(I.TernaryReturnsBool,s,0,s.length-1,{boolValue:s[2].getTextValue(),boolLiteralIfTrue:s[0].getTextValue(),boolLiteralIfFalse:s[4].getTextValue(),parentText:o?o.getTextValue():"",parentEntity:o?a(o.getEntity().name):""}))}}return n},Hl=function(e){const n=[],s=e.getExpressionsOfKind(t.ComparisonExpression);for(const o of s)o.getExpressionsOfKind(t.EqualOperator).length>0&&n.push(O.createStatementSymptom(k.EqualityExpression,[o],0,0,{parentText:e.getTextValue(),tempExpression:o}));return n},b(xs,Ms);let Pi=xs;const Ui=class Ui extends ne{constructor(e,n){if(n.length<3||n.length>5)throw new Error("List comprehension should contain 3-5 children");super(e,n,t.ListComprehension,c.BlockDefinitionStatement,d.List);b(this,Pn);const s=`${n[0].getStartLineNumber()}-listComprehension-${n[0].getDocumentStartIndex()}`;this.setBlockId(s),this.setScopeId(s),m(this,Pn,Ql).call(this)}getVariableExpressions(){let e=[];const n=this.getChildren(),s=m(this,Pn,zl).call(this);if(s>-1){e=e.concat(n[s].getVariableExpressions());for(let o=0;o<n.length;o++)o!==s&&(e=e.concat(n[o].getVariableExpressions()))}return e}copyAndConvertToPlaceholder(){const e=new Ui(this.getTextValue(),this.getChildren());return this.setTextValue(""),this.setChildren([]),e}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...this.getChildren().flatMap(n=>n.getAllNestedExpressions())]}toJSON(){const e=super.toJSON();return e.nodes=this.getChildren().map(n=>n.toJSON()),e}};Pn=new WeakSet,zl=function(){const e=this.getChildren();for(let n=0;n<e.length;n++)if(e[n].is(t.IteratorExpression))return n;return-1},Ql=function(){const e=this.getChildren();if(e.length>0&&e[0].is(t.ListComprehension)&&e[2].is(t.IteratorExpression)){const n=e[0].getChildren();if(n.length>=3&&n[2].is(t.IteratorExpression)){const s=e[2].getIterable(),o=n[2].getLoopVariables();for(const a of o)a.getTextValue()===s.getTextValue()&&(a.addObserver(s),s.setDataType(a.getDataType()),s.setAssignedOrChanged())}}};let Vi=Ui;class fd extends ne{constructor(e,n){if(n.length===0||!n[0].is(t.ReturnKeyword))throw new Error("Not a valid return statement");let s=d.None;if(n.length===2)s=n[1].getDataType();else if(n.length>2)if(jn(n,t.Comma)){s=d.Tuple;const o=n.slice(1),a=Q.split(o,t.Comma),h=new Hs(fe(o),o,t.TupleDefinition,a);n=[n[0],h]}else s=d.Invalid;super(e,n,t.ReturnStatement,c.MultipartValue,s);b(this,Me);n.length===2&&(n[1].addObserver(this),this.addConnection(n[1])),this.addRules([m(this,Me,nc),m(this,Me,tc),m(this,Me,Zl),m(this,Me,ec)]),this.addCounterRules([m(this,Me,Xl),m(this,Me,Yl)])}getReturnedValue(){return this.getChildren().slice(1)}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...this.getChildren().flatMap(n=>n.getAllNestedExpressions()).slice(1)]}toJSON(){const e=super.toJSON();return e.returnedValue=this.getReturnedValue().map(n=>n.toJSON()),e}}Me=new WeakSet,Xl=function(e){const n=[];let s=e.getReturnedValue()[0];return s.is(t.GroupStatement)&&(s=s.getContents()[0]),s.getDataType()===d.Bool&&!s.isOneOf([t.TrueType,t.FalseType,t.TernaryStatement])&&n.push(O.createStatementSymptom(k.NonLiteralBooleanReturned,e.getChildren(),0,e.getChildren().length-1,{expression:s.getTextValue()})),n},Zl=function(e){var o;const n=[],s=e.getChildren();return s.length===2&&s[1].is(t.GroupStatement)&&n.push(O.createStatementSymptom(I.ReturnInParentheses,s,0,1,{contents:m(o=e,Me,_l).call(o,s[1]),textInParentheses:s[1].getTextValue().substring(1,s[1].getTextValue().length-1)})),n},Yl=function(e){const n=[],s=e.getChildren();return s.length===2&&!s[1].is(t.GroupStatement)&&n.push(O.createStatementSymptom(k.ReturnNoParentheses,s,0,1,{returnValue:s[1].getTextValue()})),n},_l=function(e){const n=e.getContents();if(n.length===1){if(n[0].isOneOf([c.Literals,c.Types]))return Gc;if(n[0].isOneOf([t.VariableName,t.SubscriptedExpression]))return Jc;if(n[0].isOneOf([c.FunctionCall,c.MethodCall]))return Do;if(n[0].is(c.CompoundTypes))return Ao}return Bo},ec=function(e){const n=[],s=e.getChildren();for(let o=0;o<s.length;o++)s[o].is(t.Colon)&&n.push(O.createStatementSymptom(I.UnexpectedColon,s,0,s.length-1,{before:o>0?s[o-1].getTextValue():we,after:o<s.length-1?s[o+1].getTextValue():we}));return n},tc=function(e){const n=[],a=e.getChildren().flatMap(h=>h.is(t.GroupStatement)?h.getContents():h).filter(h=>Bt(h)||h.getDataType()===d.None&&!h.isOneOf([t.NoneType,t.VariableName]));return a.length>0&&n.push(...a.map(h=>O.createStatementSymptom(I.AssignedNone,[h],0,0,{expression:h,usage:bi}))),n},nc=function(e){const n=e.getChildren(),s=[];for(let o=1;o<n.length;o++)if(n[o].is(t.AssignmentStatement)){const a=n[o].getTargetVariables().map(h=>h.getTextValue());s.push(O.createStatementSymptom(I.AssignmentInReturn,n,o,o,{assignedVariables:a}))}return s};class gd extends ne{constructor(e,n){super(e,n,t.ImportStatement,c.KeywordStatement,d.NA);b(this,ci);b(this,Vn,[]);if(n.length>1&&(y(this,ci,n[1]),n[0].is(t.FromKeyword)))for(let s=3;s<n.length;s++)n[s].is(t.Comma)||u(this,Vn).push(n[s])}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...u(this,Vn).flatMap(n=>n.getAllNestedExpressions())]}toJSON(){const e=super.toJSON();return e.importedEntities=u(this,Vn).map(n=>n.toJSON()),e}}ci=new WeakMap,Vn=new WeakMap;class pd extends ne{constructor(e,n){if(n.length===0)throw new Error("Not enough elements to make a statement");let s=t.Unknown;if(n[0].is(t.AssertKeyword))s=t.AssertStatement;else if(n[0].is(t.GlobalKeyword))s=t.GlobalStatement;else if(n[0].is(t.RaiseKeyword))s=t.ThrowStatement;else throw new Error("Unknown keyword");super(e,n,s,c.KeywordStatement,d.NA);b(this,Ln,[]);y(this,Ln,n.slice(1))}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...u(this,Ln).flatMap(n=>n.getAllNestedExpressions())]}toJSON(){const e=super.toJSON();return e.keyword=this.getChildren()[0].toJSON(),e.values=u(this,Ln).map(n=>n.toJSON()),e}}Ln=new WeakMap;const Qt=class Qt extends Ks{constructor(e,n,s,o=[],a=!0,h=!1){super();b(this,Be);b(this,zt);l(this,"lineNumbers",new Set);b(this,Ne);b(this,Ds);b(this,As);b(this,Je);y(this,zt,e),this.lineNumbers.add(n),y(this,As,s),y(this,Ds,s.getSpaceCount()+s.getTabCount()),o.length>0&&(o[o.length-1].is(t.ContinuationLine)&&o.pop(),o.length>0&&o[0].isOneOf([t.IfDefinition,t.ElifDefinition,t.WhileDefinition])&&(this.addRule(m(this,Be,rc)),this.addCounterRule(m(this,Be,ac)))),y(this,Ne,o),this.addRule(m(this,Be,ic)),a&&m(this,Be,No).call(this,h)}getRawText(){return u(this,zt)}updateRawText(e){y(this,zt,e)}getLineNumbers(){return this.lineNumbers}getFirstLineNumber(){return this.lineNumbers.size>0?Math.min(...Array.from(this.lineNumbers)):-1}getLastLineNumber(){return this.lineNumbers.size>0?Math.max(...Array.from(this.lineNumbers)):-1}addLineNumber(e){this.lineNumbers.add(e)}getIndentation(){return u(this,Ds)}getIndent(){return u(this,As)}getExpressions(){return u(this,Je)===void 0?u(this,Ne):u(this,Je)}getRawExpressions(){return u(this,Ne)}containsExpression(e){for(let n of this.getExpressions())if(n.contains(e))return!0;return!1}getVariableUsages(){const e=new Map;for(let n of u(this,Je)){const s=n.getVariableExpressions();for(let o of s)e.has(o.getTextValue())||e.set(o.getTextValue(),[]),e.get(o.getTextValue()).push(o)}return e}isBlank(){return u(this,Je).length===0}getFirstExpression(){if(this.isBlank())throw new Error("Statement is blank. Could not get first expression.");return u(this,Je)[0]}isBlockStatement(){return!1}isDefinitionOfBlock(){return u(this,Je).length===0?!1:u(this,Je)[0].is(c.BlockDefinitionStatement)}static createFromSource(e,n=!1){return new Qt(e.getText(),e.getLineNumber(),e.getIndent(),e.getExpressions(),!e.continuesOnNextLine(),n)}continueFromSource(e){this.addLineNumber(e.getLineNumber()),m(this,Be,sc).call(this,e.getExpressions()),this.updateRawText(u(this,zt)+`
`+e.getText()),e.continuesOnNextLine()||m(this,Be,No).call(this)}toJSON(){return{expressions:u(this,Je).map(e=>e.toJSON())}}};zt=new WeakMap,Ne=new WeakMap,Ds=new WeakMap,As=new WeakMap,Je=new WeakMap,Be=new WeakSet,No=function(e=!1){y(this,Je,Q.createTree(u(this,Ne))),e||this.addRules([m(this,Be,oc)]),this.checkRules(this),this.checkForCounterRules(this)},sc=function(e){if(e.length>0&&e[0].is(t.OpenParenthesis)&&u(this,Ne).length>0&&u(this,Ne)[u(this,Ne).length-1].is(t.VariableName)){const n=u(this,Ne).length-1,s=u(this,Ne)[n];let o=Xe(u(this,Ne)[u(this,Ne).length-1]);o.category!==c.BuiltInFunctions&&(o=new X(t.FunctionName,c.Identifiers)),u(this,Ne)[n]=rn(s.getTextValue(),o,s.getStartLineNumber(),s.getDocumentStartIndex(),s.getDocumentEndIndex(),s.getEndLineNumber())}y(this,Ne,u(this,Ne).concat(e))},ic=function(e){var o,a,h;const n=e.getRawExpressions(),s=[];for(let p=0;p<n.length;p++)m(o=Qt,Tt,lc).call(o,n,p)&&s.push(O.createStatementSymptom(I.NaturalLanguageBoolean,n,p,p+1,{form:Wc})),m(a=Qt,Tt,uc).call(a,n,p)&&s.push(O.createStatementSymptom(I.OutOfPlaceBooleanOperator,n,p,p)),m(h=Qt,Tt,cc).call(h,n,p)&&s.push(O.createStatementSymptom(I.DoubleComparisonOperators,n,p,p+1));return s},oc=function(e){const n=[],s=u(e,Je);for(let o=0;o<s.length;o++)s[o].is(t.Colon)&&n.push(O.createStatementSymptom(I.UnexpectedColon,s,0,s.length-1,{before:o>0?{type:s[o-1].getEntity().name,value:s[o-1].getTextValue()}:{type:we},after:o<s.length-1?{type:s[o+1].getEntity().name,value:s[o+1].getTextValue()}:{type:we}}));return n},rc=function(e){const n=e.getFirstExpression().getExpressionsOfKind(t.AssignmentStatement),s=[];for(const o of n)s.push(O.createStatementSymptom(I.AssignmentInBoolean,[o],0,0,{parentText:e.getRawText()}));return s},ac=function(e){const n=e.getFirstExpression().getExpressionsOfKind(t.ComparisonExpression),s=[];for(const o of n)o.getExpressionsOfKind(t.EqualOperator).length>0&&s.push(O.createStatementSymptom(k.EqualityExpression,[o],0,0,{parentText:e.getRawText(),tempExpression:o}));return s},Tt=new WeakSet,lc=function(e,n){return e[n].is(t.AndOperator)&&n<e.length-1&&e[n+1].is(t.OrOperator)},cc=function(e,n){return n<e.length-1&&e[n].isOneOf([t.AssignmentOperator,c.ComparisonOperators])&&e[n+1].isOneOf([t.AssignmentOperator,c.ComparisonOperators])},uc=function(e,n){return e[n].is(c.LogicalOperators)?!!(!e[n].is(t.NotOperator)&&(n===0||e[n-1].isOneOf([c.LogicalOperators,c.MathsOperators,c.ComparisonOperators,c.BlockDefinitions]))||!e[n].is(t.NotOperator)&&n<e.length-1&&e[n+1].isOneOf([c.LogicalOperators,c.MathsOperators,c.ComparisonOperators,c.BlockDefinitions])&&!e[n+1].is(t.NotOperator)):!1},b(Qt,Tt);let Pt=Qt;class md extends Pt{constructor(e,n){super(e.getRawText(),e.getFirstLineNumber(),e.getIndent());b(this,Ce);b(this,Y,[]);b(this,Bs,!1);b(this,ks,!1);for(const s of e.getExpressions())s.setBlockId(`${e.getFirstLineNumber()}-${e.getRawExpressions()[0].getTextValue()}`),s.setScopeId(n);u(this,Y).push(e);for(const s of e.getLineNumbers())this.addLineNumber(s);this.addRules([m(this,Ce,Co)]),this.addCounterRules([m(this,Ce,Oo)])}checkBlockRules(e){if(!u(this,Bs)){for(const n of this.getRules())O.symptoms.push(...n(e));y(this,Bs,!0)}}checkBlockCounterRules(e){if(!u(this,ks)){for(const n of this.getCounterRules())O.counterSymptoms.push(...n(e));y(this,ks,!0)}}getExpressions(){let e=[];for(let n of u(this,Y))e=e.concat(n.getExpressions());return e}getVariableUsages(){const e=new Map;for(let n of u(this,Y)){const s=n.getVariableUsages();for(const[o,a]of s)if(!e.has(o))e.set(o,a);else{const h=e.get(o).concat(a);e.set(o,h)}}return e}isBlank(){return!1}getFirstExpression(){if(this.isBlank())throw new Error("Statement is blank. Could not get first expression.");return u(this,Y)[0].getFirstExpression()}isBlockStatement(){return!0}getLineNumbers(){const e=new Set;for(let n of u(this,Y))for(let s=n.getFirstLineNumber();s<=n.getLastLineNumber();s++)e.add(s);return e}getFirstLineNumber(){return u(this,Y).length===0?-1:u(this,Y)[0].getFirstLineNumber()}getLastLineNumber(){return u(this,Y).length===0?-1:u(this,Y)[u(this,Y).length-1].getLastLineNumber()}getStatements(){return u(this,Y)}getDefinitionStatement(){let e=u(this,Y)[0];for(;e.isBlockStatement();)e=e.getDefinitionStatment();return e}addStatement(e,n){const s=u(this,Y).length>0&&u(this,Y)[u(this,Y).length-1].getExpressions().length>0?u(this,Y)[u(this,Y).length-1].getFirstExpression().getBlockId():"unknown";u(this,Y).push(e);for(const h of e.getExpressions())h.setBlockId(s),h.setScopeId(n.getScope().getId());const o=fe(this.getExpressions());this.updateRawText(o);for(let h of e.getLineNumbers())this.addLineNumber(h);Q.connectVariableUsages(e,n);const a=n.getBlockEntity()===t.DocumentDefinition?n:n.getParentBlock().getScope();Q.connectUserDefinedFunctions(e,a),Q.connectUserDefinedMethods(e,a),Q.makeGraphConnections(u(this,Y))}getBlockStatementForIndent(e){if(u(this,Y).length===0||e<=this.getIndentation())return;const n=u(this,Y)[u(this,Y).length-1];if(!n.isBlockStatement())return this;const s=n.getBlockStatementForIndent(e);return s===void 0?this:s}getLastBlockStatement(){if(u(this,Y).length===0)return;const e=u(this,Y)[u(this,Y).length-1];if(!e.isBlockStatement())return this;const n=e.getLastBlockStatement();return n===void 0?this:n}toJSON(){return{definition:this.getDefinitionStatement().toJSON(),statements:u(this,Y).slice(1).map(e=>e.toJSON())}}}Y=new WeakMap,Bs=new WeakMap,ks=new WeakMap,Ce=new WeakSet,Co=function(e){var a,h,p;const n=[],s=e.getDefinitionStatement();try{s.getFirstExpression().is(t.ForDefinitionStatement)?n.push(...m(a=e,Ce,hc).call(a,e,s)):s.getFirstExpression().is(t.ExceptDefinitionStatement)&&n.push(...m(h=e,Ce,dc).call(h,e,s))}catch{}const o=e.getStatements().filter(w=>w.isBlockStatement());for(const w of o)n.push(...m(p=w,Ce,Co).call(p,w));return n},dc=function(e,n){const s=[];if(n.getFirstExpression().getChildren().length===3&&n.getFirstExpression().getChildren()[1].is(t.ExceptionName)){const o=n.getFirstExpression().getChildren()[1],a=e.getStatements().slice(1);for(const h of a){const p=h.getFirstExpression();if(p.is(t.ThrowStatement)){const w=p.getExpressionsOfKind(t.ExceptionName);for(const S of w)S.getTextValue()===o.getTextValue()&&s.push(O.createStatementSymptom(I.RedundantException,[p],0,0))}}}return s},lf=function(e,n){const s=[],o=n.getFirstExpression(),a=o.getVariableExpressions();for(const h of e.getStatements()){const p=h.getExpressions();for(const w of p){if(At(w))return s;const S=w.getVariableExpressions().filter(N=>N.isAssignedOrChanged()),F=new Set(S.map(N=>N.getTextValue()));for(const N of a)if(F.has(N.getTextValue()))return s}}return s.push(O.createStatementSymptom(I.InfiniteLoop,[o],0,0)),s},hc=function(e,n){const s=[],o=n.getFirstExpression().getCondition()[0];if(o!==void 0&&o.is(t.IteratorExpression)){const a=o.getLoopVariables(),h=e.getVariableUsages();for(const p of a)if(h.has(p.getTextValue())){const w=h.get(p.getTextValue()).filter(S=>S.getStartLineNumber()!==n.getFirstLineNumber());for(let S=0;S<w.length;S++){const F=w[S].getParent();if(F.is(t.IteratorExpression)&&F.getLoopVariables().filter(N=>N===w[S]).length>0)break;if(w[S].isAssignedOrChanged()&&!(w.slice(S+1).filter(E=>!E.isAssignedOrChanged()).length>0)){const E=n.getFirstExpression().getTextValue(),G=p.getDataType().name;s.push(O.createStatementSymptom(I.ForLoopIteratorModified,[w[S]],0,0,{definitionText:E.trim(),loopVarTypeAtDefinition:G,modificationText:w[S].getParent().getTextValue()}));break}}}}return s},Oo=function(e){var a,h,p;const n=[],s=e.getDefinitionStatement();try{s.getFirstExpression().isOneOf([t.IfDefinitionStatement,t.ElifDefinitionStatement,t.WhileDefinitionStatement])&&n.push(...m(a=e,Ce,fc).call(a,e,s))}catch{}try{s.getFirstExpression().is(t.ForDefinitionStatement)&&n.push(...m(h=e,Ce,gc).call(h,e,s))}catch{}const o=e.getStatements().filter(w=>w.isBlockStatement());for(const w of o)n.push(...m(p=w,Ce,Oo).call(p,w));return n},fc=function(e,n){const s=[],o=n.getFirstExpression().getCondition()[0];if(o.is(t.VariableName)&&o.getDataType()===d.Bool)s.push(O.createStatementSymptom(k.StandaloneBooleanVariable,[o],0,0,{boolValue:o.getTextValue(),usedIn:o.getContextOfUse()}));else if(o.is(t.BooleanExpression)){const a=o.getChildren();a.length===2&&a[0].is(t.NotOperator)&&a[1].is(t.VariableName)&&a[1].getDataType()===d.Bool&&s.push(O.createStatementSymptom(k.StandaloneBooleanVariable,a,0,a.length-1,{boolValue:a[1].getTextValue(),usedIn:o.getContextOfUse()}))}return s},gc=function(e,n){const s=[],o=n.getFirstExpression().getCondition()[0];if(o!==void 0&&o.is(t.IteratorExpression)){const a=o.getLoopVariables(),h=e.getVariableUsages();let p=0;for(const w of a){let S=0;if(h.has(w.getTextValue())){const F=h.get(w.getTextValue()).filter(N=>N.getStartLineNumber()!==n.getFirstLineNumber());for(let N=0;N<F.length;N++){const E=F[N].getParent();if(E.is(t.IteratorExpression)&&E.getLoopVariables().filter(G=>G===F[N]).length>0)break;if(F[N].isAssignedOrChanged()){S=0;break}else S++}}p+=S>0?1:0}p===a.length&&s.push(O.createStatementSymptom(k.ForLoopTargetNotModified,[o],0,0,{loopVars:a.map(w=>w.getTextValue())}))}return s};const wd=(g,i,e)=>{let n=new Map;for(let[s,o]of dh){const a=o(g,i,e);a.length>0&&n.set(s,Xs.create(s,a))}return n},Sd=(g,i,e)=>{let n=new Map;for(let[s,o]of hh){const a=o(g,i,e);a.length>0&&n.set(s,Xs.create(s,a))}return n},bd=g=>g.filter(e=>e.getID()===I.AssignmentInBoolean.name).map(e=>new V(e.getLineNumber(),e.getDocIndex(),new P([e],"A single equals operator is used in a boolean expression where a double equals operator might be expected."))),Id=g=>{const i=g.filter(n=>n.getID()===I.UnexpectedColon.name&&n.getAdditionalInfo().after.type!==we&&n.getAdditionalInfo().before.type===t.VariableName.name);let e=[];for(let n of i){const s=new P([n],"The unexpected colon is preceded by a variable name and followed by a value. The intention may be to assign the value to the named variable.");e.push(new V(n.getLineNumber(),n.getDocIndex(),s))}return e},yd=g=>{const i=g.filter(o=>o.getID()===I.NaturalLanguageBoolean.name&&o.getAdditionalInfo().operator==="or"),e=new Map,n=[];for(const o of i){let a,h=o.getAdditionalInfo().tempExpression.is(t.BooleanExpression)?o.getAdditionalInfo().tempExpression:void 0;try{for(a=o.getAdditionalInfo().tempExpression.getParent();a.is(t.BooleanExpression);)h=a,a=a.getParent()}catch{a=void 0}if(a)try{a.getFirstExpressionOf(t.ComparisonExpression)&&o.getAdditionalInfo().operator==="or"?(e.has(a)||e.set(a,[]),e.get(a).push(o),o.getAdditionalInfo().parentText=a.getTextValue(),o.getAdditionalInfo().parentEntity=a.getEntity(),h&&(o.getAdditionalInfo().completeBooleanExpression=h.getTextValue())):n.push(o)}catch{n.push(o)}else n.push(o)}let s=[];for(const o of e.values()){o.sort((h,p)=>h.getDocIndex()-p.getDocIndex());const a=new P(o,"One or more non-boolean value is used where a boolean expression is expected.");s.push(new V(o[0].getLineNumber(),o[0].getDocIndex(),a))}return s},Fd=g=>{const i=g.filter(n=>n.getID()===I.CompareBoolLiteral.name);let e=[];for(let n of i){const s=n.toJSON();if(s.boolLiteral===Rc){const o=new P([n],`${s.boolValue} is a boolean value so ${s.operator} ${s.boolLiteral} is redundant.`);e.push(new V(n.getLineNumber(),n.getDocIndex(),o))}else{const o=new P([n],`${s.boolValue} is a boolean value so the expression can be rewritten as not ${s.boolValue}.`);e.push(new V(n.getLineNumber(),n.getDocIndex(),o))}}return e},Nd=g=>{const i=g.filter(n=>n.getID()===I.UnreachableExit.name&&n.getAdditionalInfo().exitKeyword===bi);g.filter(n=>n.getID()===I.LoopReturn.name&&n.getAdditionalInfo().loopType==="for"&&n.getAdditionalInfo().exitType==="return");let e=[];for(let n of i){const s=new P([n],"Code follows a return statement in the same branch.");e.push(new V(n.getLineNumber(),n.getDocIndex(),s))}return e},Cd=g=>{const i=g.filter(n=>n.getID()===I.OverwrittenVariable.name&&n.getAdditionalInfo().overwriteType===Ii&&n.getAdditionalInfo().overwriteValue!==Fi&&!(n.getAdditionalInfo().prevUsageIsDefinition&&n.getAdditionalInfo().overwrittenVar[n.getAdditionalInfo().overwrittenVar.length-1].forLoopDefinition));let e=[];for(let n of i){const s=new P([n],`The iterating variable ${n.getAffectedText()} is initialised before the loop. ${n.getAdditionalInfo().overwriteValue===Po?"The overwritten value is different from the value initialised by the loop":"It could not be determined if the overwritten value is the same as the value initialised by the loop"}.`);e.push(new V(n.getLineNumber(),n.getDocIndex(),s))}return e},Od=(g,i)=>{const e=g.filter(h=>h.getID()===I.UndefinedVariable.name),n=Array.from(i.values()).flatMap(h=>h).flatMap(h=>h.getUsages()).filter(h=>h.getVariable().getDataType()===d.Function).map(h=>h.getVariable()),s=g.filter(h=>h.getID()===I.SubscriptedNonSubscriptable.name),o=g.filter(h=>h.getID()===I.VariableWithSameNameAsFunction.name&&(h.getAdditionalInfo().funcType===sn||h.getAdditionalInfo().funcType===nn&&h.getAdditionalInfo().numArgsExpected>0));let a=[];if(o.length===0||e.length===0&&n.length===0)return a;for(let h of o){const p=h.getAffectedText(),w=h.getDocIndex();for(let S of e)if(S.getAffectedText()===p&&S.getDocIndex()===w&&s.filter(N=>N.getAdditionalInfo().varName===p&&N.getDocIndex()===w).length===0){const N=new P([S,h],`The variable ${p} has not been assigned a value and the file contains a user-defined function of the same name.`);a.push(new V(S.getLineNumber(),S.getDocIndex(),N))}for(let S of n)if(S.getTextValue()===p&&S.getDocumentStartIndex()===w&&s.filter(N=>N.getAdditionalInfo().varName===p&&N.getDocIndex()===w).length===0){const N=new P([h],`The variable ${p} has not been assigned a value and the file contains a user-defined function of the same name.`);a.push(new V(h.getLineNumber(),h.getDocIndex(),N))}}return a},Td=g=>{const i=g.filter(s=>s.getID()===I.SubscriptedNonSubscriptable.name),e=g.filter(s=>s.getID()===I.VariableWithSameNameAsFunction.name);let n=[];for(let s of i){let o=s.getAdditionalInfo().varName,a=s.getDocIndex();for(let h of e)if(h.getAffectedText()===o&&h.getDocIndex()===a){const p=s.getAdditionalInfo().isUndefined?"undefined variable":s.getAdditionalInfo().subscriptedType==="unknown data type"?"variable with unknown data type":`variable with ${s.getAdditionalInfo().subscriptedType} data type`,w=new P([s,h],`${o} (${p}) has the same name as a function. ${o} is subscripted, suggesting a mistake may have been made while calling a function of the same name. It is possible there is confusion about when to use square brackets versus parentheses.`);n.push(new V(s.getLineNumber(),s.getDocIndex(),w))}}return n},Md=g=>{const i=g.filter(s=>s.getID()===I.LoopVarModifiedInChildLoop.name&&s.getAdditionalInfo().modifiedIn.every(o=>o.loopType==="for"&&o.varDataType==="int")),e=g.filter(s=>s.getID()===I.LoopVarNotModified.name);let n=[];for(let s of i){const o=s.getAffectedText(),a=s.getBlock();for(const h of e)if(h.getBlock()===a&&h.getAdditionalInfo().unmodifiedVars.includes(o)){const p=new P([s,h],`The int variable ${o} is referenced in a while loop condition but only modified in a nested for loop. If ${o} is being used to count the iterated items, the two loops could be replaced with a single for loop using enumerate() or range() to count the items.`);n.push(new V(s.getLineNumber(),s.getDocIndex(),p));break}}return n},xd=g=>{const i=g.filter(n=>n.getID()===I.OverwrittenVariable.name&&n.getAdditionalInfo().overwriteType===Ii&&n.getAdditionalInfo().overwriteValue===Fi&&n.getAdditionalInfo().prevUsageIsDefinition&&!n.getAdditionalInfo().overwrittenVar[n.getAdditionalInfo().overwrittenVar.length-1].forLoopDefinition);let e=[];for(let n of i){const s=new P([n],`The iterating variable ${n.getAffectedText()} is initialised before the loop with the same value that it is initialised with in the for loop definition.`);e.push(new V(n.getLineNumber(),n.getDocIndex(),s))}return e},Dd=(g,i)=>{const e=g.filter(s=>s.getID()===I.UndefinedVariable.name&&s.getAdditionalInfo().variable.getScope().getBlockEntity()===t.DocumentDefinition);let n=[];for(let s of e){const o=s.getAdditionalInfo().variable.getName(),a=i.get(o).filter(h=>h.getScope().getBlockEntity()!==t.DocumentDefinition);if(a.length>0){s.getAdditionalInfo().localVariables=[];for(const p of a){const w={scope:p.getScope().getBlockEntity().name};p.getScope().getBlockEntity()===t.FunctionDefinition&&(w.functionName=p.getScope().getFunctionName()),s.getAdditionalInfo().localVariables.push(w)}const h=new P([s],`The undefined variable ${s.getAffectedText()} has global scope. The document contains ${a.length} other ${a.length===1?"variable":"variables"} with the same name in function scope.`);n.push(new V(s.getLineNumber(),s.getDocIndex(),h))}}return n},Ad=g=>{let i=g.filter(n=>n.getID()===I.ForLoopIteratorModified.name),e=[];for(let n of i){let s="";s=`The for loop iterator variable ${n.getAffectedText()} is modified in the loop.`;const o=new P([n],s);e.push(new V(n.getLineNumber(),n.getDocIndex(),o))}return e},Bd=g=>{const i=g.filter(n=>n.getID()===I.OneLineConditional.name);let e=[];for(let n of i){const s=n.toJSON();if(s.form===wi){const o=new P([n],"Conditional returns a boolean literal that matches the value of the boolean expression in the if statement. The whole conditional could be replaced with a single line.");e.push(new V(n.getLineNumber(),n.getDocIndex(),o))}else if(s.form===Si){const o=new P([n],`The variable ${s.variableAssigned} is assigned a boolean literal that matches the value of the boolean expression in the if statement. The whole conditional could be replaced with a single line.`);e.push(new V(n.getLineNumber(),n.getDocIndex(),o))}}return e},kd=g=>{const i=g.filter(n=>n.getID()===I.TernaryReturnsBool.name);let e=[];for(let n of i){const s=new P([n],"Ternary returns a boolean literal that matches the value of the boolean expression in the ternary. The ternary could be replaced with the boolean expression alone.");e.push(new V(n.getLineNumber(),n.getDocIndex(),s))}return e},Pd=g=>{const i=g.filter(s=>s.getID()===I.UnexpectedColon.name&&s.getAdditionalInfo().after.type===we&&(s.getAdditionalInfo().before.type===t.FunctionName.name||s.getAdditionalInfo().before.type===ko)),e=g.filter(s=>s.getID()===I.UnknownFunction.name);let n=[];for(let s of i)if(s.getAdditionalInfo().before.type===t.FunctionName.name){let o=e.filter(a=>a.getAffectedText()===s.getAdditionalInfo().before.value);if(o.length>0){const a=new P([s,o[0]],`The unexpected colon is preceded by a call to unknown function, ${o[0].getAffectedText()}. It is possible the intention was to declare a function but the def keyword has been omitted.`);n.push(new V(s.getLineNumber(),s.getDocIndex(),a))}}else if(s.getAdditionalInfo().before.type===ko){const o=new P([s],"The unexpected colon is preceded by a Boolean expression. It is possible the intention was to declare a while, if, or elif but the keyword was omitted.");n.push(new V(s.getLineNumber(),s.getDocIndex(),o))}return n},Vd=g=>{const i=g.filter(s=>s.getID()===I.DefinitionFollowedByReservedWord.name),e=g.filter(s=>s.getID()===I.ReservedWordAssigned.name);let n=[];for(let s of i){const o=new P([s],`The reserved word, ${s.getAdditionalInfo().reservedWord}, follows the ${s.getAdditionalInfo().definitionType}.`);n.push(new V(s.getLineNumber(),s.getDocIndex(),o))}for(let s of e){const o=new P([s],`The reserved word, ${s.getAffectedText()}, is followed by the assignment operator.`);n.push(new V(s.getLineNumber(),s.getDocIndex(),o))}return n},Ld=(g,i)=>{const e=g.filter(h=>h.getID()===I.UndefinedVariable.name),n=Array.from(i.values()).flatMap(h=>h).flatMap(h=>h.getUsages()).filter(h=>h.getVariable().getDataType()===d.Function).map(h=>h.getVariable()),s=g.filter(h=>h.getID()===I.SubscriptedNonSubscriptable.name),o=g.filter(h=>h.getID()===I.VariableWithSameNameAsFunction.name&&h.getAdditionalInfo().funcType===nn&&h.getAdditionalInfo().numArgsExpected===0);let a=[];if(o.length===0||e.length===0&&n.length===0)return a;for(let h of o){const p=h.getAffectedText(),w=h.getDocIndex();for(let S of e)if(S.getAffectedText()===p&&S.getDocIndex()===w&&s.filter(N=>N.getAdditionalInfo().varName===p&&N.getDocIndex()===w).length===0){const N=new P([S,h],`The variable ${p} has not been assigned a value and the file contains a user-defined function of the same name, which does not expect any arguments.`);a.push(new V(S.getLineNumber(),S.getDocIndex(),N))}for(let S of n)if(S.getTextValue()===p&&S.getDocumentStartIndex()===w&&s.filter(N=>N.getAdditionalInfo().varName===p&&N.getDocIndex()===w).length===0){const N=new P([h],`The variable ${p} has not been assigned a value and the file contains a user-defined function of the same name, which does not expect any arguments.`);a.push(new V(h.getLineNumber(),h.getDocIndex(),N))}}return a},vd=g=>{const i=g.filter(o=>o.getID()===I.AssignedNone.name),e=g.filter(o=>o.getID()===I.FunctionPrints.name),n=g.filter(o=>o.getID()===I.UnusedReturn.name&&o.getAdditionalInfo().expression.is(t.FunctionName));let s=[];for(let o of i){const a=o.toJSON();if(a.expressionNoValue.type===nn){const h=a.expressionNoValue.value.split("(")[0],p=e.filter(S=>S.getAffectedText()===h);if(p.length>0){const S=new P([o,...p],`User-defined function ${h} prints to the console but does not return a value.`);s.push(new V(o.getLineNumber(),o.getDocIndex(),S))}else{const S=new P([o],`User-defined function ${h} does not return a value but it is used as if it does.`);s.push(new V(o.getLineNumber(),o.getDocIndex(),S))}}else if(a.expressionNoValue.type===sn&&a.expressionNoValue.value.indexOf("print(")===0){const h=new P([o],"The print function does not return a value but it is used as if it does.");s.push(new V(o.getLineNumber(),o.getDocIndex(),h))}}for(let o of n){const h=o.toJSON().unusedFunc.value,p=e.filter(S=>S.getAffectedText()===h);if(p.length>0){const S=new P([o,...p],`User-defined function ${h} prints to the console and returns a value but the value is not used.`);s.push(new V(o.getLineNumber(),o.getDocIndex(),S))}}return s},Rd=g=>{const i=g.filter(s=>s.getID()===I.FunctionPrints.name),e=g.filter(s=>s.getID()===I.UnusedReturn.name&&!(s.getAdditionalInfo().expression.is(c.BuiltInMethods)&&Ci.has(s.getAdditionalInfo().expression.getEntity()))&&!s.getAdditionalInfo().expression.isOneOf([t.StrFunction,t.IntFunction,t.FloatFunction,t.BoolFunction,t.ListFunction,t.TupleFunction,t.SetFunction])),n=[];for(let s of e){const a=s.toJSON().unusedFunc.value;if(!(i.filter(w=>w.getAffectedText()===a).length>0)){const w=new P([s],`The function ${a} returns a value but the value is not used.`);n.push(new V(s.getLineNumber(),s.getDocIndex(),w))}}return n},Ed=g=>{const i=g.filter(n=>n.getID()===I.ReturnInParentheses.name),e=n=>n===Do?"function call":n===Ao?"compound type (e.g. list, set)":n===Bo?"compound expression":n;return i.map(n=>new V(n.getLineNumber(),n.getDocIndex(),new P([n],`The function returns a ${e(n.getAdditionalInfo().contents)} wrapped in parentheses. The parentheses are unnecessary.`)))},Ud=g=>{const i=g.filter(n=>n.getID()===I.SequentialIfs.name&&n.getAdditionalInfo().branchMatches.length>0);let e=[];for(let n of i)for(let s of n.getAdditionalInfo().branchMatches){let o=s.map(h=>h.lineNum+1).join(", "),a=o.lastIndexOf(",");o=o.substring(0,a)+" and"+o.substring(a+1),s.length>0&&e.push(new V(s[0].lineNum,s[0].docIndex,new P([n],`The if statement is part of a sequence of if statements (lines ${o}) that have very similar boolean expressions.`)))}return e},Gd=(g,i,e)=>{const n=new Set(g.filter(a=>a.getID()===I.AssignmentInReturn.name).map(a=>a.getLineNumber())),s=g.filter(a=>a.getID()===I.OverwrittenVariable.name&&a.getAdditionalInfo().isParameter&&a.getAdditionalInfo().prevUsageIsDefinition&&!n.has(a.getLineNumber()));let o=[];for(let a of s){const h=a.getAdditionalInfo().functionBlock;let p="";for(const[S,F]of e.entries())if(F.getBlockId()===h){p=S;break}a.getAdditionalInfo().functionBlock=p;const w=new P([a],`The parameter ${a.getAffectedText()} is overwritten before use.`);o.push(new V(a.getLineNumber(),a.getDocIndex(),w))}return o},Jd=g=>{const i=g.filter(n=>n.getID()===I.UnusedReturn.name&&n.getAdditionalInfo().expression.is(c.BuiltInMethods)&&Ci.has(n.getAdditionalInfo().expression.getEntity())&&n.getAdditionalInfo().expression.getParent().getObject().getDataType()===d.String);let e=[];for(let n of i){const s=new P([n],`A String method, ${n.getAdditionalInfo().expression.getTextValue()}, that returns a new string is called but the return value is not assigned or passed.`);e.push(new V(n.getLineNumber(),n.getDocIndex(),s))}return e},$d=g=>{const i=g.filter(n=>n.getID()===I.UnusedReturn.name&&n.getAdditionalInfo().expression.isOneOf([t.StrFunction,t.IntFunction,t.FloatFunction,t.BoolFunction,t.ListFunction,t.TupleFunction,t.SetFunction]));let e=[];for(let n of i){const s=new P([n],`${n.getAdditionalInfo().expression.getTextValue()}() is called but the converted value returned by the function is not saved or passed.`);e.push(new V(n.getLineNumber(),n.getDocIndex(),s))}return e},Kd=g=>{const i=g.filter(s=>s.getID()===I.LoopVarNotModified.name),e=g.filter(s=>s.getID()===I.LoopReturn.name);let n=[];for(const s of e){if(s.getAdditionalInfo().exitTypes.filter(a=>a!=="return").length>0||s.getAdditionalInfo().loopType==="while"&&i.filter(a=>a.getBlock()===s.getBlock()).length>0)continue;const o=new P([s],`A ${s.getAdditionalInfo().loopType} always exits on the first iteration due to return statements. Related to DeferredReturn.`);n.push(new V(s.getLineNumber(),s.getDocIndex(),o))}return n},Wd=g=>{const i=g.filter(s=>s.getID()===I.LoopVarNotModified.name),e=g.filter(s=>s.getID()===I.LoopReturn.name);let n=[];for(let s of i){const o=e.filter(a=>a.getBlock()===s.getBlock());if(o.length>0){const a=new P([s,...o],"No while loop variables are modified (excluding modifications in any nested loops) and the loop always exits on the first iteration.");n.push(new V(s.getLineNumber(),s.getDocIndex(),a))}}return n},qd=g=>{const i=g.filter(n=>n.getID()===I.TypeUnnecessary.name);let e=[];for(let n of i){const s=n.toJSON();let o;s.argType===Ec&&s.convertedType===Uc?o=new P([n],`A string value, ${s.convertedValue}, is converted to a list which may not be necessary. The programmer may not realise that much of the functionality provided by a list is also available to strings.`):o=new P([n],`${s.convertedValue} is guaranteed to be a ${s.argType} so there is no need to convert it to ${s.convertedType}.`),o!==void 0&&e.push(new V(n.getLineNumber(),n.getDocIndex(),o))}return e},jd=g=>g.filter(e=>e.getID()===k.EqualityExpression.name).map(e=>new V(e.getLineNumber(),e.getDocIndex(),new P([e],"The equality operator is used in a Boolean expression."))),Hd=g=>{const i=g.filter(n=>n.getID()===k.ValidAssignment.name);let e=[];for(let n of i){const s=new P([n],"A variable is assigned a value.");e.push(new V(n.getLineNumber(),n.getDocIndex(),s))}return e},zd=g=>{const i=g.filter(s=>s.getID()===k.EqualityExpression.name),e=new Map;for(const s of i){let o,a=s.getAdditionalInfo().tempExpression.is(t.BooleanExpression)?s.getAdditionalInfo().tempExpression:void 0;try{for(o=s.getAdditionalInfo().tempExpression.getParent();o.is(t.BooleanExpression);)a=o,o=o.getParent()}catch{o=void 0}o&&a&&a.getTextValue().includes(" or ")&&(e.has(o)||e.set(o,[]),e.get(o).push(s),s.getAdditionalInfo().completeBooleanExpression=a.getTextValue())}for(const[s,o]of Array.from(e.entries())){const a=[],h=new Set;for(let p=0;p<o.length;p++)if(!h.has(p)){for(let w=0;w<o.length;w++)if(w!==p&&!h.has(w)){const S=o[p].getAdditionalInfo().tempExpression,F=o[w].getAdditionalInfo().tempExpression;S.matchesPattern(F)&&(h.has(p)||(a.push(o[p]),h.add(p)),a.push(o[w]),h.add(w))}}e.set(s,a)}let n=[];for(const s of Array.from(e.values()).filter(o=>o.length>1)){s.sort((a,h)=>a.getDocIndex()-h.getDocIndex());const o=new P(s,"A Boolean expression contains multiple equality checks separated by an or.");n.push(new V(s[0].getLineNumber(),s[0].getDocIndex(),o))}return n},Qd=g=>g.filter(e=>e.getID()===k.StandaloneBooleanVariable.name).map(e=>new V(e.getLineNumber(),e.getDocIndex(),new P([e],"A condition statement uses a single standalone Boolean variable as the condition instead of comparing it to True or False."))),Xd=(g,i,e)=>{const n=new Set(i.filter(h=>h.getID()===I.UnreachableExit.name&&h.getAdditionalInfo().exitKeyword===bi).map(h=>h.getAdditionalInfo().functionBlock)),s=g.filter(h=>h.getID()===k.ReturnLast.name&&!n.has(h.getAdditionalInfo().functionBlock)),o=new Map;for(const[h,p]of e)if(!n.has(p.getBlockId())){const w=s.filter(S=>S.getAdditionalInfo().functionBlock===p.getBlockId());w.length>0&&o.set(h,w)}let a=[];for(const h of Array.from(o.values())){h.sort((w,S)=>w.getDocIndex()-S.getDocIndex());const p=new P(h,"All returns in a function are the last statements in their respective branches.");a.push(new V(h[0].getLineNumber(),h[0].getDocIndex(),p))}return a},Zd=g=>g.filter(e=>e.getID()===k.NewForLoopVar.name).map(e=>new V(e.getLineNumber(),e.getDocIndex(),new P([e],"A for loop definition creates a new loop variable instead of overwriting an existing variable."))),Yd=g=>g.filter(e=>e.getID()===k.ValidFunctionCall.name).map(e=>new V(e.getLineNumber(),e.getDocIndex(),new P([e],"A properly formed function call with parentheses and 0 or more arguments."))),_d=g=>g.filter(e=>e.getID()===k.CounterLoop.name&&!e.getAdditionalInfo().isNestedInWhile).map(e=>new V(e.getLineNumber(),e.getDocIndex(),new P([e],"A counter loop (uses range or enumerate) is not nested inside a while loop."))),eh=(g,i)=>{const e=new Set(i.filter(o=>o.getID()===I.UndefinedVariable.name&&o.getAdditionalInfo().variable.getScope().getBlockEntity()===t.DocumentDefinition).map(o=>o.getAffectedText())),n=g.filter(o=>o.getID()===k.ValidGlobalVariable.name),s=[];if(n.length>0){const o=g.filter(a=>a.getID()===k.FunctionScopeVariable.name&&!e.has(a.getAffectedText()));o.length>0&&(s.push(...n.map(a=>new V(a.getLineNumber(),a.getDocIndex(),new P([a],"A variable is defined in document scope.")))),s.push(...o.map(a=>new V(a.getLineNumber(),a.getDocIndex(),new P([a],"A variable defined in function scope does not have an undefined counterpart in document scope.")))))}return s},th=g=>g.filter(e=>e.getID()===k.ForLoopTargetNotModified.name).map(e=>new V(e.getLineNumber(),e.getDocIndex(),new P([e],"The target variable(s) in a for loop iterator are used in the loop without modification."))),nh=g=>{const i=g.filter(s=>s.getID()===k.NonLiteralBooleanAssigned.name),e=g.filter(s=>s.getID()===k.NonLiteralBooleanReturned.name),n=i.map(s=>new V(s.getLineNumber(),s.getDocIndex(),new P([s],"A non-literal Boolean expression is assigned directly to a variable.")));return n.push(...e.map(s=>new V(s.getLineNumber(),s.getDocIndex(),new P([s],"A non-literal Boolean expression is returned directly.")))),n},sh=g=>g.filter(e=>e.getID()===k.UsedReturn.name).map(e=>new V(e.getLineNumber(),e.getDocIndex(),new P([e],"The value returned by a function call is used in some way."))),ih=g=>g.filter(e=>e.getID()===k.ReturnNoParentheses.name).map(e=>new V(e.getLineNumber(),e.getDocIndex(),new P([e],"An expression is returned without parentheses."))),oh=g=>g.filter(e=>e.getID()===k.IfElif.name).map(e=>new V(e.getLineNumber(),e.getDocIndex(),new P([e],"A conditional made up of multiple branches."))),rh=g=>g.filter(e=>e.getID()===k.ParameterCalled.name).map(e=>new V(e.getLineNumber(),e.getDocIndex(),new P([e],"A parameter is called in the function without modification."))),ah=g=>{const i=g.filter(n=>n.getID()===k.UsedReturn.name),e=[];for(const n of i){const s=n.getAdditionalInfo().expression;Ci.has(s.getEntity())&&e.push(new V(n.getLineNumber(),n.getDocIndex(),new P([n],"The result of a string method is used in some way.")))}return e},lh=g=>g.filter(e=>e.getID()===k.UsedReturn.name&&e.getAdditionalInfo().expression.isOneOf([t.StrFunction,t.IntFunction,t.FloatFunction,t.BoolFunction,t.ListFunction,t.TupleFunction,t.SetFunction])).map(e=>new V(e.getLineNumber(),e.getDocIndex(),new P([e],"The result of a type conversion function is used in some way."))),ch=(g,i)=>{const e=new Set(i.filter(s=>s.getID()===I.LoopReturn.name&&s.getAdditionalInfo().loopType==="while").map(s=>s.getBlock()));return g.filter(s=>s.getID()===k.WhileLoopVarModified.name&&!e.has(s.getBlock())).map(s=>new V(s.getLineNumber(),s.getDocIndex(),new P([s],"A while loop progresses because a loop variable is modified and there is no early exit.")))},uh=g=>g.filter(e=>e.getID()===k.LoopExitsSometimes.name).map(e=>new V(e.getLineNumber(),e.getDocIndex(),new P([e],"A loop contains a return that is inside a conditional."))),Gi=class Gi{constructor(i,e){b(this,vn);b(this,Ps);b(this,Xt);y(this,vn,i.name),y(this,Ps,i.description),y(this,Xt,e)}addOccurrence(i){u(this,Xt).push(i)}getName(){return u(this,vn)}isPresentInToken(i,e){for(const n of u(this,Xt))for(const s of n.getReason().getContributingSymptoms())if(i<=s.getDocIndex()&&e>=s.getDocIndex())return!0;return!1}toJSON(){return{type:u(this,vn),description:u(this,Ps),occurrences:u(this,Xt).map(i=>i.toJSON())}}static create(i,e){return new Gi(i,e)}};vn=new WeakMap,Ps=new WeakMap,Xt=new WeakMap;let Xs=Gi;class V{constructor(i,e,n){b(this,Rn);b(this,En);b(this,Un);y(this,Rn,i),y(this,En,e),y(this,Un,n)}getLineNumber(){return u(this,Rn)}getDocIndex(){return u(this,En)}getReason(){return u(this,Un)}toJSON(){return{line:u(this,Rn),docIndex:u(this,En),reason:u(this,Un).toJSON()}}}Rn=new WeakMap,En=new WeakMap,Un=new WeakMap;class P{constructor(i,e){b(this,Gn);b(this,Vs);y(this,Gn,i),y(this,Vs,e)}getContributingSymptoms(){return u(this,Gn)}toJSON(){return{contributingSymptoms:u(this,Gn).map(i=>i.toJSON()),explanation:u(this,Vs)}}}Gn=new WeakMap,Vs=new WeakMap;const dh=new Map([[v.PrintSameAsReturn,vd],[v.UnusedReturn,Rd],[v.MapToBooleanWithIf,Bd],[v.ComparisonWithBoolLiteral,Fd],[v.DeferredReturn,Nd],[v.TypeMustBeSpecified,qd],[v.CompareMultipleValuesWithOr,yd],[v.ParenthesesOnlyIfArgument,Ld],[v.FunctionCallsUseSquareBrackets,Td],[v.FunctionCallsNoParentheses,Od],[v.AssignCompares,bd],[v.ReturnCall,Ed],[v.SequentialIfsAreExclusive,Ud],[v.WhileSameAsIf,Wd],[v.IterationRequiresTwoLoops,Md],[v.StringMethodsModifyTheString,Jd],[v.TypeConversionModifiesArgument,$d],[v.MapToBooleanWithTernaryOperator,kd],[v.NoReservedWords,Vd],[v.ParameterMustBeAssignedInFunction,Gd],[v.LocalVariablesAreGlobal,Dd],[v.IteratorInitialisedOutsideLoop,xd],[v.ForLoopVarIsLocal,Cd],[v.LoopCounter,Ad],[v.NoKeyword,Pd],[v.ColonAssigns,Id],[v.ReturnWaitsForLoop,Kd]]),hh=new Map([[oe.Equality,jd],[oe.Assignment,Hd],[oe.MultipleEquality,zd],[oe.BooleanVariableCondition,Qd],[oe.ReturnLast,Xd],[oe.NewForLoopVar,Zd],[oe.FunctionCall,Yd],[oe.SingleCounterLoop,_d],[oe.VariablesInMultipleScopes,eh],[oe.ForLoopTargetNotModified,th],[oe.BooleanExpressionUsedAsValue,nh],[oe.UsedReturn,sh],[oe.ReturnNoParentheses,ih],[oe.MultiBranchConditional,oh],[oe.ParameterCalled,rh],[oe.StringMethodAssigned,ah],[oe.ConversionAssigned,lh],[oe.WhileLoopProgresses,ch],[oe.LoopExitsSometimes,uh]]);class _o{constructor(i){b(this,ui);b(this,Zt);b(this,ze);b(this,Mt);b(this,Ls);b(this,Yt);b(this,_t);b(this,Jn);y(this,Zt,i.getTextValue()),y(this,ze,i.getCategory()),y(this,Mt,i.getEntity()),y(this,Yt,i.getDocumentStartIndex()),y(this,_t,i.getDocumentEndIndex()),y(this,Ls,i.getConnectedTo()),y(this,Jn,new Set)}getText(){return u(this,Zt)}getEntity(){return u(this,Mt)}getCategory(){return u(this,ze)}getConnectedTo(){return u(this,Ls)}addMisconception(i){u(this,Jn).add(i)}getID(){let i=`${u(this,Mt).name}_${u(this,ze).name} ${u(this,Zt)}`;return m(this,ui,pc).call(this)?i:`${u(this,Yt)}_${u(this,_t)}_${i}`}getStartIndex(){return u(this,Yt)}getEndIndex(){return u(this,_t)}toJSON(){return{id:this.getID(),text:u(this,Zt),entity:u(this,Mt).name,category:u(this,ze).name,startDocIndex:u(this,Yt),endDocIndex:u(this,_t),misconceptions:Array.from(u(this,Jn))}}}Zt=new WeakMap,ze=new WeakMap,Mt=new WeakMap,Ls=new WeakMap,Yt=new WeakMap,_t=new WeakMap,Jn=new WeakMap,ui=new WeakSet,pc=function(){return u(this,Mt)===t.FunctionName&&u(this,ze)===c.Identifiers||u(this,ze)===c.BuiltInFunctions||u(this,ze)===c.BuiltInMethods||u(this,ze)===c.BuiltInModules||u(this,ze)===c.BuiltInExceptions};class fh{constructor(i,e){b(this,et);b(this,xt,new Map);b(this,$n,new Map);const n=Array.from(e.values());for(const s of i)m(this,et,mc).call(this,n,s),m(this,et,To).call(this,s);m(this,et,wc).call(this)}toJSON(){const i={nodes:{},edges:{}};for(const[e,n]of u(this,xt))i.nodes[e]=n.toJSON();for(const[e,n]of u(this,$n))i.edges[e]=Array.from(n);return i}}xt=new WeakMap,$n=new WeakMap,et=new WeakSet,mc=function(i,e){const n=i.filter(s=>s.isPresentInToken(e.getStartIndex(),e.getEndIndex()));for(const s of n)e.addMisconception(s.getName())},To=function(i){const e=i.getID();u(this,xt).has(e)||(u(this,xt).set(e,i),u(this,$n).set(e,new Set))},wc=function(){for(const[i,e]of u(this,xt)){const n=e.getConnectedTo();for(const s of n){const o=new _o(s);u(this,xt).has(o.getID())||m(this,et,To).call(this,o),i!==o.getID()&&m(this,et,Sc).call(this,i,o.getID())}}},Sc=function(i,e){u(this,$n).get(i).add(e)};class gh{constructor(i){b(this,U);b(this,vs);b(this,ve,[]);b(this,Oe);l(this,"variables");l(this,"userDefinedFunctions");l(this,"userDefinedClasses");l(this,"modules");y(this,vs,i),y(this,Oe,new zn),this.variables=new Map,this.modules=new Map,O.symptoms=[],O.counterSymptoms=[];try{m(this,U,bc).call(this,i)}catch(e){const n=`Unable to process ${i} due to error: ${e.stack}`;throw new Error(n)}}getUserDefinedFunctions(){return this.userDefinedFunctions}getUserDefinedClasses(){return this.userDefinedClasses}getVariables(){return this.variables}getSymptoms(){return O.symptoms}getCounterSymptoms(){return O.counterSymptoms}getMisconceptions(){return wd(O.symptoms,this.variables,this.getUserDefinedFunctions())}getConcepts(){return Sd(O.counterSymptoms,O.symptoms,this.getUserDefinedFunctions())}getText(){return u(this,vs)}getBlocks(){return u(this,Oe)}getGraph(){let i=[];for(const n of u(this,ve))for(const s of n.getExpressions()){let o=s.getAllNestedExpressions();try{i.push(...o.map(a=>new _o(a)))}catch(a){console.log("Unable to get graph nodes:",a)}}return new fh(i,this.getMisconceptions())}}vs=new WeakMap,ve=new WeakMap,Oe=new WeakMap,U=new WeakSet,bc=function(i){y(this,ve,[]);let e=u(this,Oe);const n=i.split(/\r?\n/),s=[...i.matchAll(/\r?\n/g)].map(o=>o[0]);if(n.length>0){let o=new Qn(n[0],0,0);u(this,ve).push(Pt.createFromSource(o)),o.continuesOnNextLine()||(e=m(this,U,xo).call(this,u(this,ve)[u(this,ve).length-1],e));for(let a=1;a<n.length;a++){const h=e.isScopeBlock()?m(this,U,Mo).call(this,e):m(this,U,Mo).call(this,e.getScope()),p=Array.from(e.getScope().findAllModules().keys()),w={varsWithTypeNames:h,moduleNames:p,classDefinitionInProgress:e.hasParentOfEntity(t.ClassDefinition)},S=o.getDocumentStartIndex()+o.getText().length+s[a-1].length;if(o.continuesOnNextLine())w.groupCharCounts=o.getOpenGroupChars(),w.lastLineExpressions=o.getExpressions(),o.hasOpenComment()&&(w.multilineCommentDelimiter=o.getCommentDelimiter()),o.hasOpenString()&&(w.stringLiteralDelimiter=o.getStringLiteralDelimiter()),o=new Qn(n[a],a,S,w),u(this,ve)[u(this,ve).length-1].continueFromSource(o);else if(o.followedBySeparateStatement()){a--;const F=o.getLineEndIndex()+1;w.startFrom=F,o=new Qn(n[a],a,o.getDocumentStartIndex(),w),u(this,ve).push(Pt.createFromSource(o,e.getBlockEntity()===t.ClassDefinition))}else o=new Qn(n[a],a,S,w),u(this,ve).push(Pt.createFromSource(o,e.getBlockEntity()===t.ClassDefinition));o.continuesOnNextLine()||(e=m(this,U,xo).call(this,u(this,ve)[u(this,ve).length-1],e))}}m(this,U,yc).call(this),m(this,U,Fc).call(this),m(this,U,Ic).call(this)},tn=function(){return[u(this,Oe)].concat(u(this,Oe).getChildBlocksOfKind(t.FunctionDefinition)).concat(u(this,Oe).getChildBlocksOfKind(t.ClassDefinition)).concat(u(this,Oe).getChildBlocksOfKind(t.ListComprehension))},Ic=function(){const i=m(this,U,tn).call(this);for(const e of i)for(const n of e.getStatements()){for(const s of n.getExpressions())s.checkForSymptoms(),s.checkForCounterRules(s);n.isBlockStatement()&&(n.checkBlockRules(n),n.checkBlockCounterRules(n))}for(const e of this.variables.values())for(const n of e)n.checkRules(n),n.checkForCounterRules(n);for(const e of this.userDefinedFunctions.values()){const n=e.getParent();if(n!==void 0&&n.is(t.FunctionDefinitionStatement)){const s=n.getParameters().length-n.getOptionalParameterCount(),o=n.getParameters().length,a=Array.from(e.getObservers()).filter(h=>h.is(t.UserDefinedFunctionCall));for(const h of a){const p=h.getArguments();(p.length<s||p.length>o)&&O.symptoms.push(O.createStatementSymptom(I.WrongArgNumber,[h],0,0,{expectedMinArgs:s,expectedMaxArgs:o,receivedArgs:p.length}))}}}u(this,Oe).checkRules(u(this,Oe)),u(this,Oe).checkForCounterRules(u(this,Oe))},yc=function(){const i=new Map,e=m(this,U,tn).call(this);for(const n of e){const s=n.getVariableMap(),o=n.getUserDefinedFunctions();for(const[a,h]of s){let p=!1;const w=h.getUsages()[0].getVariable();w.getDataType()===d.NotParsed&&!w.isAssignedOrChanged()&&!w.isParameter()&&(Q.checkIfVariableExistsInParent(h,n)?p=!0:o.has(a)?w.setDataType(d.Function):(h.getUsages()[0].getVariable().setDataType(d.Undefined),h.checkAndAdjustUndefined())),i.has(a)||i.set(a,[]),p||i.get(a).push(h)}}this.variables=i},Fc=function(){this.userDefinedFunctions=m(this,U,Tc).call(this),this.userDefinedClasses=u(this,Oe).getUserDefinedClasses();const i=u(this,Oe).getChildBlocksOfKind(t.FunctionDefinition);for(const n of i){let s=n.getLastExecutedStatements();const o=n.alwaysReturnsAValue();if(o&&(s=s.filter(a=>a.getFirstExpression().is(t.ReturnStatement))),n.getParentBlock().getBlockEntity()!==t.ClassDefinition)this.userDefinedFunctions.has(n.getFunctionName())&&this.userDefinedFunctions.get(n.getFunctionName()).is(t.FunctionName)&&this.userDefinedFunctions.get(n.getFunctionName()).addReturns(s,!o);else{const a=n.getParentBlock().getClassType().name;if(this.userDefinedClasses.has(a)){const h=this.userDefinedClasses.get(a).methods;h.has(n.getFunctionName())&&h.get(n.getFunctionName()).addReturns(s,!o)}}}m(this,U,Mc).call(this);const e=m(this,U,Cc).call(this);m(this,U,Oc).call(this,e),m(this,U,Nc).call(this),m(this,U,xc).call(this)},Nc=function(){const i=this.userDefinedFunctions.keys(),e=Array.from(i).filter(n=>this.variables.has(n));for(const n of e){const s=this.userDefinedFunctions.get(n).getParent();if(s!==void 0){for(const o of this.variables.get(n))if(o.getUsages().length>0){const a=o.getUsages()[0].getVariable();O.symptoms.push(O.createStatementSymptom(I.VariableWithSameNameAsFunction,[a],0,0,{funcType:nn,numArgsExpected:s.getParameters().length-s.getOptionalParameterCount(),varIsParameter:a.isParameter()}))}}}},Cc=function(){const i=this.userDefinedFunctions.keys(),e=[];for(const n of i)Xe(n).category===c.BuiltInFunctions&&e.push(n);return e},Oc=function(i){if(i.length>0){const e=m(this,U,tn).call(this);for(const n of e){const s=n.getStatements();for(const o of s){const h=o.getExpressions().flatMap(p=>p.getExpressionsOfKind(t.BuiltInFunctionCall)).filter(p=>i.includes(p.getFunctionName()));for(const p of h)i.includes(p.getFunctionName())&&p.convertToUserDefinedFunction(this.userDefinedFunctions.get(p.getFunctionName()))}}}},Tc=function(){const i=new Map;let e=m(this,U,tn).call(this);for(const n of e){const s=n.getUserDefinedFunctions();for(const[o,a]of s)i.set(o,a)}return i},Mc=function(){const i=m(this,U,tn).call(this);for(const e of i){const n=e.getUnconnectedFunctionCalls();for(let s of n)for(let o of s[1])if(this.userDefinedFunctions.has(s[0])){const a=this.userDefinedFunctions.get(s[0]);a.addObserver(o),o.setDataType(a.getReturnType())}else m(this,U,Dc).call(this,s[0],e)?o.convertToImportedFunction():(o.setDataType(d.Unknown),O.symptoms.push(O.createStatementSymptom(I.UnknownFunction,[o],0,0)))}},xc=function(){const i=m(this,U,tn).call(this);for(const e of i){const n=e.getUnconnectedMethodCalls();for(let s of n)for(let o of s[1]){const a=o.getObject();let h;if(a.getDataType().isCustom)a.getDataType().methods.has(s[0])&&(h=a.getDataType().methods.get(s[0]));else for(const p of this.userDefinedClasses.values())if(p.methods.has(s[0])){h=p.methods.get(s[0]);break}h&&(h.addObserver(o),o.setDataType(h.getReturnType()))}}},Dc=function(i,e){let n=e;for(;n!==void 0;){if(n.getModuleMap().has(i)||Array.from(n.getModuleMap().values()).filter(s=>s.hasDirectImport(i)).length>0)return!0;n=n.getParentBlock()!==void 0?n.getParentBlock().getScope():void 0}return!1},Mo=function(i){const e=new Set(["int","float","bool","str","list","set","dict"]);let n=Array.from(i.getVariableMap().keys()).filter(o=>e.has(o)),s=i;for(;s.getBlockEntity()!==t.DocumentDefinition;)s=s.getParentBlock().getScope(),n=n.concat(Array.from(s.getVariableMap().keys()).filter(o=>e.has(o)));return n},xo=function(i,e){if(!i.isBlank()){const n=i.getFirstExpression(),s=i.getIndentation(),o=n.getStartLineNumber();let a;const h=m(this,U,kc).call(this,i);e.isScopeBlock()||(a=e.getScope().getStatementToUpdate(s,o)),n.isOneOf([t.FunctionDefinitionStatement,t.MethodDefinitionStatement])?(e=m(this,U,Vc).call(this,e,i,s),n.is(t.MethodDefinitionStatement)&&m(this,U,Bc).call(this,e,n)):n.is(t.ClassDefinitionStatement)?e=m(this,U,Lc).call(this,e,i,s):n.is(c.BlockDefinitionStatement)&&!n.is(t.TernaryStatement)?e=m(this,U,Pc).call(this,e,i,s,a):a!==void 0?(e=m(this,U,Wn).call(this,s,e,o),a.addStatement(i,e)):(e=m(this,U,Wn).call(this,s,e,o),e.addStatement(i)),h.length>0&&m(this,U,Ac).call(this,h,e)}return e},Ac=function(i,e){for(let n of i){const s=new ju(e,n);e.addChildBlock(s)}},Bc=function(i,e){const n=i.getParentBlock();if(n&&n.getBlockEntity()===t.ClassDefinition){const s=n.getClassType(),o=e.getMethodNameExpression();o.setContainingClass(s),s.methods.set(o.getTextValue(),o)}},kc=function(i){const e=i.getExpressions();let n=[];for(const s of e){const o=s.getExpressionsOfKind(t.ListComprehension);for(const a of o)n.push(a.copyAndConvertToPlaceholder())}return n},Pc=function(i,e,n,s){const o=new md(e,i.getScope().getId()),a=new $o(i,o),h=m(this,U,Wn).call(this,n,i,e.getFirstLineNumber()),p=o.getFirstExpression().isOneOf([t.ElifDefinitionStatement,t.ElseDefinitionStatement]),w=o.getFirstExpression().is(t.ExceptDefinitionStatement);if(o.isBlockStatement()&&(p||w)){const S=s?s.getStatements():h.getStatements(),F=S[S.length-1],N=p?[t.IfDefinitionStatement,t.ElifDefinitionStatement,t.ElseDefinitionStatement]:[t.TryDefinitionStatement];if(F!==void 0&&F.isBlockStatement()&&F.getFirstExpression().isOneOf(N)){const E=h.getChildBlocks(),G=E[E.length-1],M=G.getBlockEntity();if(p&&(M===t.IfDefinition||M===t.ElifDefinition)||w&&M===t.TryDefinition){const ht=G.getSiblingConditionalBranches();for(const di of ht)a.addSibling(di),di.addSibling(a);G.addSibling(a),a.addSibling(G)}}}return h.addChildBlock(a),s?s.addStatement(o,a):h.addStatement(o),a},Vc=function(i,e,n){i=m(this,U,Wn).call(this,n,i,e.getFirstLineNumber());const s=new Ti(i,e);return i.addChildBlock(s),s},Lc=function(i,e,n){i=m(this,U,Wn).call(this,n,i,e.getFirstLineNumber());const s=new qu(i,e);return i.addChildBlock(s),s},Wn=function(i,e,n){let s=e.getIndentation();const o=e.getStatements();if(o.length>0&&o[o.length-1].getLastLineNumber()===n)return e;for(;e.getBlockEntity()!==t.DocumentDefinition&&i<=s;){let a=e.getParentBlock();e=a!==void 0?a:u(this,Oe),s=e.getIndentation()}return e};class _{constructor(i,e,n,s,o){l(this,"type");l(this,"docIndex");l(this,"affectedText");l(this,"firstMessage");l(this,"extendedFeedbackParams");for(this.type=i,this.docIndex=e,this.affectedText=n,this.firstMessage=s,this.extendedFeedbackParams=o;this.extendedFeedbackParams.includes("+");)this.extendedFeedbackParams=this.extendedFeedbackParams.replace("+","%2B");this.extendedFeedbackParams=encodeURI(this.extendedFeedbackParams)}static notImplemented(){return new _("Invalid",-1,"N/A","No feedback","")}toJSON(){return{type:this.type,docIndex:this.docIndex,affectedText:this.affectedText,firstMessage:this.firstMessage,extendedFeedbackParams:this.extendedFeedbackParams}}}const ph=g=>g.hasOwnProperty("reason")&&g.reason.hasOwnProperty("contributingSymptoms")&&g.reason.contributingSymptoms.length>0,ft=(g,i)=>g.type===i,mh=g=>{const i=[];try{for(const e of g.occurrences)if(ph(e))switch(g.type){case v.AssignCompares.name:i.push(wh(g.type,e));break;case v.ColonAssigns.name:i.push(Sh(g.type,e));break;case v.CompareMultipleValuesWithOr.name:i.push(bh(g.type,e));break;case v.ComparisonWithBoolLiteral.name:i.push(Ih(g.type,e));break;case v.DeferredReturn.name:i.push(Fh(g.type,e));break;case v.ForLoopVarIsLocal.name:case v.IteratorInitialisedOutsideLoop.name:i.push(Nh(g.type,e));break;case v.FunctionCallsNoParentheses.name:case v.ParenthesesOnlyIfArgument.name:i.push(Oh(g.type,e));break;case v.IterationRequiresTwoLoops.name:i.push(Th(g.type,e));break;case v.LocalVariablesAreGlobal.name:i.push(Mh(g.type,e));break;case v.LoopCounter.name:i.push(Ch(g.type,e));break;case v.MapToBooleanWithIf.name:i.push(xh(g.type,e));break;case v.MapToBooleanWithTernaryOperator.name:i.push(Dh(g.type,e));break;case v.ParameterMustBeAssignedInFunction.name:i.push(Ah(g.type,e));break;case v.PrintSameAsReturn.name:i.push(Bh(g.type,e));break;case v.ReturnCall.name:i.push(kh(g.type,e));break;case v.ReturnWaitsForLoop.name:i.push(Rh(g.type,e));break;case v.SequentialIfsAreExclusive.name:i.push(yh(g.type,e));break;case v.StringMethodsModifyTheString.name:i.push(Ph(g.type,e));break;case v.TypeConversionModifiesArgument.name:i.push(Vh(g.type,e));break;case v.TypeMustBeSpecified.name:i.push(Lh(g.type,e));break;case v.UnusedReturn.name:i.push(vh(g.type,e));break;case v.WhileSameAsIf.name:i.push(Eh(g.type,e));break;default:console.log("Not implemented!",g.type)}}catch(e){console.log(e)}return i},le=(g,i)=>`?miscon=${g}&lineNumber=${i.line+1}`,wh=(g,i)=>{const e=i.reason.contributingSymptoms[0],n=i.docIndex,s=e.text,o="Should this = be == ?",a=`${le(g,i)}&text=${s}&parentText=${e.parentText}`;return new _(g,n,s,o,a)},Sh=(g,i)=>{const e=i.reason.contributingSymptoms[0],n=i.docIndex,s=e.text,o="Should this : be = ?",a=`${le(g,i)}&text=${s}&variableName=${e.before.value}&assignedValue=${e.after.value}`;return new _(g,n,s,o,a)},bh=(g,i)=>{const e="NA",n=i.docIndex,s=i.reason.contributingSymptoms[0].text?i.reason.contributingSymptoms[0].text:e,o=i.reason.contributingSymptoms[0].completeBooleanExpression?`${i.reason.contributingSymptoms[0].completeBooleanExpression} will always be True`:"This boolean expression will always be True";let a=e,h=e,p=e;const w=[],S=[],F=[],N=[],E=[];for(const M of i.reason.contributingSymptoms)ft(M,I.NaturalLanguageBoolean.name)&&(M.completeBooleanExpression&&(a=M.completeBooleanExpression),M.parentText&&(h=M.parentText),M.parentEntity&&(p=M.parentEntity),M.rightSideEntity&&(M.rightSideEntity===t.ComparisonExpression.name&&(w.length===0||w[0]!==M.rightSideText)?w.unshift(M.rightSideText):M.rightSideEntity!==t.BooleanExpression.name&&(S.length===0||S[0]!==M.rightSideText)&&(S.unshift(M.rightSideText),N.unshift(M.rightSideEntity),F.unshift(M.rightSideType))),M.leftSideEntity&&(M.leftSideEntity===t.ComparisonExpression.name?w.unshift(M.leftSideText):M.leftSideEntity!==t.BooleanExpression.name&&(S.unshift(M.leftSideText),N.unshift(M.leftSideEntity),F.unshift(M.leftSideType))),E.unshift(M.operator));const G=`${le(g,i)}&booleanExpressionText=${a}&parentText=${h}&parentEntity=${p}&${w.map(M=>"comparisonText="+M).join("&")}&${S.map(M=>"otherText="+M).join("&")}&${N.map(M=>"otherEntity="+M).join("&")}&${F.map(M=>"otherType="+M).join("&")}&${E.map(M=>"operator="+M).join("&")}}`;return new _(g,n,s,o,G)},Ih=(g,i)=>{const e=i.reason.contributingSymptoms[0],n=i.docIndex,s=e.text,o=e.boolValue,a=e.boolLiteral,h=a==="True"?`${o} is boolean so == True is not needed`:`${s} is the same as not ${o}`,p=`${le(g,i)}&text=${s}&boolValue=${o}&boolLiteral=${a}`;return new _(g,n,s,h,p)},yh=(g,i)=>{const e=i.docIndex;let n=i.reason.contributingSymptoms[0].text;const s=new Set;for(const p of i.reason.contributingSymptoms){if(!ft(p,I.SequentialIfs.name))continue;const w=p.branchMatches.flat();w.forEach(M=>{s.add(M.lineNum+1)});const S=w[0].docIndex-p.docIndex,F=S,N=w[w.length-1].docIndex-w[0].docIndex+S,E=n.substring(N).indexOf(`
`),G=E>-1?N+E:n.length;n=n.substring(F,G)}const a=`Should this sequence of if statements be if${Array(s.size-1).fill("-elif").join("")} instead?`,h=`${le(g,i)}&fullText=${n}&${[...s].map(p=>"statementLine="+p).join("&")}`;return new _(g,e,n,a,h)},Fh=(g,i)=>{for(const e of i.reason.contributingSymptoms)if(ft(e,I.UnreachableExit.name)&&e.exitKeyword==="return"){const n=e.docIndex,s=e.text,o="This code will never execute",a=`${le(g,i)}&exitKeyword=${e.exitKeyword}`;return new _(g,n,s,o,a)}return _.notImplemented()},Nh=(g,i)=>{const e=i.reason.contributingSymptoms[0],n=e.text,s=e.usageText,o=e.overwrittenVar[e.overwrittenVar.length-1].lineNum+1,a=e.prevUsageIsDefinition,h=a?`${n} does not need to be defined if it is only used in the for loop on line ${e.line+1}`:`This for loop changes the value of an existing variable, ${n}`,p=a?e.overwrittenVar[0].docIndex:i.docIndex,w=`${le(g,i)}&loopVariable=${n}&forDefinition=${s}&overwrittenVarLine=${o}&overwrittenIsDefinition=${a}`;return new _(g,p,n,h,w)},Ch=(g,i)=>{const e=i.docIndex,n=i.reason.contributingSymptoms[0],s=n.text,o=`This value of ${s} will be ignored by the next loop iteration`,a=`${le(g,i)}&loopVarName=${s}&definitionText=${n.definitionText}&loopVarTypeAtDefinition=${n.loopVarTypeAtDefinition}&modificationText=${n.modificationText}`;return new _(g,e,s,o,a)},Oh=(g,i)=>{let e=i.docIndex,n=`${le(g,i)}`,s="";const o=i.reason.contributingSymptoms;if(o.length===2){const h=ft(o[0],I.UndefinedVariable.name)?o[0]:o[1],p=ft(o[1],I.VariableWithSameNameAsFunction.name)?o[1]:o[0];ft(h,I.UndefinedVariable.name)&&ft(p,I.VariableWithSameNameAsFunction.name)&&(s=p.text,e=h.docIndex,n=`${n}&funcName=${s}&funcType=${p.funcType}&funcExpectedArgs=${p.numArgsExpected}&matchesUndefinedVarOnLine=${h.line+1}`)}else o.length===1&&ft(o[0],I.VariableWithSameNameAsFunction.name)&&(s=o[0].text,e=o[0].docIndex,n=`${n}&funcName=${s}&funcType=${o[0].funcType}&funcExpectedArgs=${o[0].numArgsExpected}`);const a=`Did you forget () after ${s}?`;return new _(g,e,s,a,n)},Th=(g,i)=>{const e="This while loop might not be needed",n=i.reason.contributingSymptoms,s=n[0].type===I.LoopVarNotModified.name?n[0]:n[1],o=n[0].type===I.LoopVarModifiedInChildLoop.name?n[0]:n[1],a=s.text,h=s.docIndex,p=`${le(g,i)}&outerLoopText=${a}&outerLoopVariable=${o.text}${o.modifiedIn.map(w=>`&modifiedInType=${w.loopType}&modifiedInStartLine=${w.startLine+1}`)}`;return new _(g,h,a,e,p)},Mh=(g,i)=>{const e=i.reason.contributingSymptoms[0],n=i.docIndex,s=e.text,o=`${s} is undefined`;let a=`${le(g,i)}&text=${s}`;return e.hasOwnProperty("localVariables")&&(a=`${a}${e.localVariables.map(h=>`&localScope=${h.scope}${h.hasOwnProperty("functionName")?"&localFunction="+h.functionName:"&localFunction=NA"}`).join()}`),new _(g,n,s,o,a)},xh=(g,i)=>{const e=i.reason.contributingSymptoms[0],n=i.docIndex,s=e.text,o="This conditional could be shortened to one line";let a=`${le(g,i)}&text=${e.text}&form=${e.form}`;return e.form==="valueAssigned"&&(a=`${a}&variableAssigned=${e.variableAssigned}`),e.condition&&e.condition.length>0&&(a=`${a}&condition=${e.condition}`),new _(g,n,s,o,a)},Dh=(g,i)=>{const e=i.reason.contributingSymptoms[0],n=i.docIndex,s=e.text,o="This ternary is not needed",a=`${le(g,i)}&text=${e.text}&boolExp=${e.boolValue}&valueIfTrue=${e.boolLiteralIfTrue}&valueIfFalse=${e.boolLiteralIfFalse}&parentText=${e.parentText}&parentEntity=${e.parentEntity}`;return new _(g,n,s,o,a)},Ah=(g,i)=>{const e=i.reason.contributingSymptoms[0],n=i.docIndex,s=e.text,o="This statement replaces the value of an argument passed to the function";let a=`${le(g,i)}&paramName=${s}`;return e.functionBlock!==""&&(a=`${a}&functionName=${e.functionBlock}`),new _(g,n,s,o,a)},Bh=(g,i)=>{const e=i.reason.contributingSymptoms.filter(o=>o.type===I.AssignedNone.name),n=i.reason.contributingSymptoms.filter(o=>I.UnusedReturn);let s=`${le(g,i)}`;if(e.length>0){const o=e[0],a=o.docIndex,h=o.expressionNoValue.value,p=`${o.expressionNoValue.value} has no value`;if(s=`${s}&variant=AssignedNoReturn&expressionNoValueType=${o.expressionNoValue.type}&expressionNoValueUsage=${o.usage}&expressionNoValueText=${o.expressionNoValue.value}&expressionNoValueTarget=${o.target}`,o.expressionNoValue.type==="userDefinedFunction"){const w=i.reason.contributingSymptoms.filter(F=>F.type===I.FunctionPrints.name),S=w.length===1?w[0]:void 0;S&&S.printLines.filter(N=>N.isEndOfExitBranch).length>0&&!S.functionReturns&&(s=`${s}&isFuncPrintNoReturn=true`)}return new _(g,a,h,p,s)}else if(n.length>0){const o=n[0],a=o.docIndex,h=o.unusedFunc.value,p=`The value returned by ${h}() is not used`;if(s=`${s}&variant=UnusedReturn&expressionUnusedType=${o.unusedFunc.type}&expressionUnusedText=${o.unusedFunc.value}`,o.unusedFunc.type==="userDefinedFunction"){const w=i.reason.contributingSymptoms.filter(F=>F.type===I.FunctionPrints.name),S=w.length===1?w[0]:void 0;S&&S.text===o.unusedFunc.value&&(s=`${s}&isFuncPrintsAndReturns=true`)}return new _(g,a,h,p,s)}return _.notImplemented()},kh=(g,i)=>{const e=i.reason.contributingSymptoms[0],n=i.docIndex,s=e.text,o=`The () around ${e.textInParentheses} are not needed`,a=`${le(g,i)}&text=${s}&returnValueType=${e.contents}&returnValueText=${e.textInParentheses}`;return new _(g,n,s,o,a)},Ph=(g,i)=>{const e=i.reason.contributingSymptoms[0],n=i.docIndex,s=e.text,o=e.unusedFunc.value,a=e.unusedFunc.returnType,h=new RegExp("[ ]*.[ ]*"+o),p=s.split(h)[0],w=`${o}() will not change ${p}`,S=`${le(g,i)}&text=${s}&unusedMethod=${o}&unusedReturnType=${a}&stringValue=${p}`;return new _(g,n,s,w,S)},Vh=(g,i)=>{const e=i.reason.contributingSymptoms[0],n=i.docIndex,s=e.text,o=e.unusedFunc.value,a=e.unusedFunc.returnType,h=s.substring(s.indexOf("(")+1,s.lastIndexOf(")")),p=`${o}() will not change ${h}`,w=`${le(g,i)}&text=${s}&typeFunction=${o}&returnType=${a}&argument=${h}`;return new _(g,n,s,p,w)},Lh=(g,i)=>{const e=i.reason.contributingSymptoms[0],n=i.docIndex,s=e.text,o="This type conversion is not needed",a=`${le(g,i)}&text=${s}&argType=${e.argType}&convertedType=${e.convertedType}&convertedValue=${e.convertedValue}`;return new _(g,n,s,o,a)},vh=(g,i)=>{const e=i.reason.contributingSymptoms[0],n=i.docIndex,s=e.text,o=e.unusedFunc.returnType,a=o!==d.Unknown.name&&o!==d.Invalid.name&&o!==d.NA.name&&o!==d.NotParsed.name,h=a?`The ${o} returned by ${s} is not used`:`The value returned by ${s} is not used`,p=`${le(g,i)}&expressionUnusedType=${e.unusedFunc.type}&expressionUnusedText=${e.unusedFunc.value}${a?"&returnType="+o:""}`;return new _(g,n,s,h,p)},Rh=(g,i)=>{const e=i.docIndex,n=i.reason.contributingSymptoms[0],s=n.text,o=n.loopType,a=n.exitTypes.length,h=n.exitLevel,p=`This ${o} loop always ends the first time it runs because of where return is used`,w=`${le(g,i)}&text=${s}&loopType=${o}&returnCount=${a}&exitLevel=${h}`;return new _(g,e,s,p,w)},Eh=(g,i)=>{const e=i.docIndex,n=i.reason.contributingSymptoms,s=n.filter(h=>h.type===I.LoopReturn.name),o=n.filter(h=>h.type===I.LoopVarNotModified.name),a=le(g,i);if(o.length===1){const h=o[0].text,p="Could this while loop be an if statement?",w=`${a}&variant=${o[0].type}&definitionText=${h}&loopText=${o[0].loopText}${o[0].unmodifiedVars.map(S=>`&loopVar=${S}`)}${s.map(S=>`&earlyExitLine=${S.line+1}&earlyExitText=${S.text}`)}`;return new _(g,e,h,p,w)}return _.notImplemented()},er=(g,i)=>g.getLineNumber()===i.getLineNumber()&&g.getID()===i.getID()?0:g.getLineNumber()<i.getLineNumber()||g.getLineNumber()===i.getLineNumber()&&g.getID()<i.getID()?-1:1,tr=(g,{showSymptoms:i=!0,showMisconceptions:e=!0,showCounterSymptoms:n=!1,showConcepts:s=!1,showBlocks:o=!1,showVariables:a=!1,showFunctions:h=!1,showClasses:p=!1,showTree:w=!1,showGraph:S=!1,showErrorDetail:F=!1}={})=>{const N=[];try{N.push("Sending to DocInfo");let E=new gh(g);N.push("Getting symptom information");const G=i?Uh(E):[];N.push("Getting counter symptom information");const M=n?Jh(E):[];N.push("Getting variable information");const ht=a?Wh(E):[];N.push("Getting function information");const di=h?qh(E):[];N.push("Getting class information");const Yh=p?jh(E):[];N.push("Getting misconception information");const _h=e?Gh(E):[];N.push("Getting concept information");const ef=s?$h(E):[];N.push("Getting block information");const nr=o?Kh(E):[],Ji={misconceptions:_h,concepts:ef,symptoms:G,counterSymptoms:M,blocks:nr,variables:ht,functions:di,classes:Yh};if(w){const $i=nr.toTree();Ji.tree=$i}if(S){const $i=E.getGraph();Ji.graph=$i.toJSON()}return Ji}catch(E){console.log("Unable to parse",E);const G={misconceptions:[],concepts:[],symptoms:[],counterSymptoms:[],blocks:[],variables:[],functions:[],classes:[],error:`Unable to parse! ${E.toString()}`};return N.push(E.toString()),F&&(G.errorDetail=N.join(`
`)),G}},Uh=g=>g.getSymptoms().sort(er).map(i=>{try{return i.toJSON()}catch(e){return{error:"Could not process symptom",msg:e.toString()}}}),Gh=g=>Array.from(g.getMisconceptions().values()).map(i=>{try{return i.toJSON()}catch(e){return{error:"Could not process misconception",msg:e.toString()}}}),Jh=g=>g.getCounterSymptoms().sort(er).map(i=>{try{return i.toJSON()}catch(e){return{error:"Could not process counter symptom",msg:e.toString()}}}),$h=g=>Array.from(g.getConcepts().values()).map(i=>{try{return i.toJSON()}catch(e){return{error:"Could not process concept",msg:e.toString()}}}),Kh=g=>{try{return g.getBlocks().toJSON()}catch{return[]}},Wh=g=>Array.from(g.getVariables().values()).flat().map(i=>{try{return i.toJSON()}catch(e){return{error:"Could not process variable",msg:e.toString()}}}),qh=g=>Array.from(g.getUserDefinedFunctions().values()).filter(i=>i.is(t.FunctionName)).map(i=>{try{return i.toJSON()}catch(e){return{error:"Could not process function",msg:e.toString()}}}),jh=g=>Array.from(g.getUserDefinedClasses().values()).map(i=>{try{return i.toJSON()}catch(e){return{error:"Could not process class",msg:e.toString()}}}),Hh=()=>{let g={};for(let i in I)g[I[i].name]=I[i].description;return g},zh=()=>{let g={};for(let i in k)g[k[i].name]=k[i].description;return g},Qh=()=>{let g={};for(let i in v)g[v[i].name]=v[i].description;return g},Xh=()=>{let g={};for(let i in oe)g[oe[i].name]=oe[i].description;return g},Zh=(g,i=!1,e={})=>{const n=tr(g,e),s={};if(i&&(s.parse=n),s.feedback=[],n.hasOwnProperty("misconceptions"))for(const o of n.misconceptions)o.hasOwnProperty("type")&&s.feedback.push(...mh(o).map(a=>a.toJSON()));return s};W.conceptInfo=Xh,W.counterSymptomInfo=zh,W.feedback=Zh,W.misconceptionInfo=Qh,W.parse=tr,W.symptomInfo=Hh,Object.defineProperty(W,Symbol.toStringTag,{value:"Module"})});
