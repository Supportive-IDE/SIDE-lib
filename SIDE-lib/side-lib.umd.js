(function(E,G){typeof exports=="object"&&typeof module<"u"?G(exports):typeof define=="function"&&define.amd?define(["exports"],G):(E=typeof globalThis<"u"?globalThis:E||self,G(E["side-lib"]={}))})(this,function(E){"use strict";var Nd=Object.defineProperty;var Cd=Object.getPrototypeOf;var Md=Reflect.get;var Gr=E=>{throw TypeError(E)};var Od=(E,G,B)=>G in E?Nd(E,G,{enumerable:!0,configurable:!0,writable:!0,value:B}):E[G]=B;var l=(E,G,B)=>Od(E,typeof G!="symbol"?G+"":G,B),Oi=(E,G,B)=>G.has(E)||Gr("Cannot "+B);var u=(E,G,B)=>(Oi(E,G,"read from private field"),B?B.call(E):G.get(E)),I=(E,G,B)=>G.has(E)?Gr("Cannot add the same private member more than once"):G instanceof WeakSet?G.add(E):G.set(E,B),y=(E,G,B,a)=>(Oi(E,G,"write to private field"),a?a.call(E,B):G.set(E,B),B),m=(E,G,B)=>(Oi(E,G,"access private method"),B);var ei=(E,G,B,a)=>({set _(t){y(E,G,t,B)},get _(){return u(E,G,a)}}),Di=(E,G,B)=>Md(Cd(E),B,G);var Dt,xt,Bt,At,kt,en,tn,nn,sn,Pt,ve,ct,st,rn,Kn,Wn,Be,$r,xi,Jr,Kr,Wr,ut,Fe,on,jn,dt,jr,ti,qn,Hn,an,it,Lt,ln,ht,ft,Re,gt,ae,zn,X,W,qr,Hr,zr,Qr,Bi,Ai,ki,Xr,Pi,Li,Vi,Ms,yi,Fi,cn,Ti,Qn,Gs,Zr,Xn,vi,j,tt,Os,Yr,_r,eo,to,no,Ri,_,Vt,Zn,un,je,Te,U,vt,Yn,Ne,Ae,ge,pt,Ni,T,so,io,Ui,ro,qt,ze,xe,oo,ao,Ei,Gi,lo,$i,co,uo,ho,fo,go,po,mo,wo,So,Io,bo,Rn,yo,Dd,Fo,To,No,Co,Mo,Oo,Do,xo,Bo,Ao,D,Ji,ko,Po,Lo,Vo,vo,Ro,Uo,Eo,Ki,Go,$o,Jo,Ko,fe,Wo,jo,qo,Wi,Ho,ji,zo,qi,Qo,Xo,Zo,Yo,Hi,_o,mt,wt,St,rt,dn,hn,fn,es,gn,Se,Rt,pn,ts,ke,Js,ea,pe,ns,mn,ta,wn,na,sa,ia,is,ue,Ce,ra,oa,ni,aa,la,Ws,ca,de,Ie,ua,da,Ds,ha,fa,Sn,ga,pa,js,ma,Xe,Me,In,wa,Sa,qs,Ia,Hs,ba,Ze,bn,ya,Fa,zs,Ta,It,bt,rs,os,as,re,si,Na,Ca,Ma,Oa,Da,xa,zi,ls,Ye,cs,Qi,yn,Qs,Ba,te,Xs,Aa,le,Fn,ka,Pa,Z,we,ee,La,Va,va,Xi,Ra,Zi,Yi,Ua,Ea,Ga,Ue,Pe,Tn,ot,Ee,$a,Ja,Ka,Wa,ja,ne,Nn,qa,Ha,Oe,at,Cn,za,Qa,us,_i,Ge,Xa,_e,er,tr,Za,Ya,_a,el,tl,$e,nl,hs,nr,sl,il,rl,ol,qe,al,gs,sr,ll,cl,xd,ul,Mn,he,se,be,dl,hl,fl,ir,gl,pl,ms,ws,Ss,rr,Zs,ml,On,wl,Sl,Je,Il,bl,yl,Fl,Tl,Ys,Dn,xn,Et,me,bs,ys,Le,Ve,or,Nl,Cl,Ml,Ol,yt,Dl,xl,Bl,H,et,ar,Al,Bd,kl,Bn,Fs,$t,An,kn,Pn,Ln,Ts,Jt,Ke,Ft,Ns,Kt,Wt,Vn,_s,Pl,Tt,vn,He,Ll,lr,Vl,vl,Cs,De,ye,v,Rl,Ht,Ul,El,Gl,$l,Jl,Kl,Wl,jl,ql,Hl,cr,ur,zl,Ql,Xl,Zl,Yl,_l,Un;class G{constructor(i){this.name=i}}const C=class C extends G{static getCategory(i){return i>=65&&i<=90||i>=97&&i<=122?C.Letter:i>=48&&i<=57?C.Digit:i===46?C.Decimal:i===95?C.Underscore:i===32?C.Space:i===9?C.Tab:i===10||i===13?C.NewLine:i===40?C.OpenParentheses:i===41?C.CloseParentheses:i===123?C.OpenCurlyBrace:i===125?C.CloseCurlyBrace:i===91?C.OpenSquareBracket:i===93?C.CloseSquareBracket:i===44?C.Comma:i===58?C.Colon:i===59?C.Semicolon:i===43?C.Plus:i===45?C.Minus:i===42?C.Asterisk:i===37?C.Modulo:i===61?C.Equals:i===60?C.LessThan:i===62?C.GreaterThan:i===33?C.Exclamation:i===47?C.ForwardSlash:i===92?C.BackSlash:i===35?C.Hash:i===39?C.SingleQuote:i===34?C.DoubleQuote:i===64?C.At:C.Unknown}isQuote(){return this===C.SingleQuote||this===C.DoubleQuote}};l(C,"Letter",new C("letter")),l(C,"Digit",new C("digit")),l(C,"Decimal",new C("decimal")),l(C,"Underscore",new C("underscore")),l(C,"Space",new C("space")),l(C,"Tab",new C("tab")),l(C,"NewLine",new C("newline")),l(C,"OpenParentheses",new C("openParentheses")),l(C,"CloseParentheses",new C("closeParentheses")),l(C,"OpenCurlyBrace",new C("openCurlyBrace")),l(C,"CloseCurlyBrace",new C("closeCurlyBrace")),l(C,"OpenSquareBracket",new C("openSquareBracket")),l(C,"CloseSquareBracket",new C("closeSquareBracket")),l(C,"Comma",new C("comma")),l(C,"Colon",new C("colon")),l(C,"Semicolon",new C("semicolon")),l(C,"Plus",new C("plus")),l(C,"Minus",new C("minus")),l(C,"Asterisk",new C("asterisk")),l(C,"Modulo",new C("modulo")),l(C,"Equals",new C("equals")),l(C,"LessThan",new C("lessThan")),l(C,"GreaterThan",new C("greaterThan")),l(C,"Exclamation",new C("exclamation")),l(C,"ForwardSlash",new C("forwardSlash")),l(C,"BackSlash",new C("backSlash")),l(C,"Hash",new C("hash")),l(C,"SingleQuote",new C("singleQuote")),l(C,"DoubleQuote",new C("doubleQuote")),l(C,"At",new C("at")),l(C,"Unknown",new C("unknown"));let B=C;const A=class A extends G{};l(A,"BlockDefinitions",new A("BlockDefinitions")),l(A,"LogicalOperators",new A("LogicalOperators")),l(A,"Types",new A("Types")),l(A,"MathsOperators",new A("MathsOperators")),l(A,"ComparisonOperators",new A("ComparisonOperators")),l(A,"OtherKeywords",new A("OtherKeywords")),l(A,"BuiltInFunctions",new A("BuiltInFunctions")),l(A,"BuiltInMethods",new A("BuiltInMethods")),l(A,"OtherMethods",new A("OtherMethods")),l(A,"Identifiers",new A("Identifiers")),l(A,"MagicMethods",new A("MagicMethods")),l(A,"SpecialVariables",new A("SpecialVariables")),l(A,"Properties",new A("Properties")),l(A,"BuiltInExceptions",new A("BuiltInExceptions")),l(A,"Literals",new A("Literals")),l(A,"CompoundTypes",new A("CompoundTypes")),l(A,"Other",new A("Other")),l(A,"Comment",new A("Comment")),l(A,"Unknown",new A("Unknown")),l(A,"BuiltInModules",new A("BuiltInModules")),l(A,"ModuleFunctions",new A("ModuleFunctions")),l(A,"ModuleProperties",new A("ModuleProperties")),l(A,"ClassAttributes",new A("ClassAttributes")),l(A,"ImportedEntities",new A("ImportedEntities")),l(A,"TypeHint",new A("TypeHint")),l(A,"SyntacticSugar",new A("SyntacticSugar")),l(A,"FunctionCall",new A("FunctionCall")),l(A,"MethodCall",new A("MethodCall")),l(A,"ExceptionCall",new A("ExceptionCall")),l(A,"BlockDefinitionStatement",new A("BlockDefinitionStatement")),l(A,"Group",new A("Group")),l(A,"MultipartValue",new A("MultipartValue")),l(A,"Assignment",new A("Assigment")),l(A,"KeywordStatement",new A("KeywordStatement"));let a=A;const r=class r extends G{};l(r,"ClassDefinition",new r("class")),l(r,"FunctionDefinition",new r("def")),l(r,"ElifDefinition",new r("elif")),l(r,"ElseDefinition",new r("else")),l(r,"ExceptDefinition",new r("except")),l(r,"FinallyDefinition",new r("finally")),l(r,"ForDefinition",new r("for")),l(r,"IfDefinition",new r("if")),l(r,"LambdaDefinition",new r("lambda")),l(r,"TryDefinition",new r("try")),l(r,"WhileDefinition",new r("while")),l(r,"DocumentDefinition",new r("document")),l(r,"ListComprehension",new r("listComprehension")),l(r,"AndOperator",new r("and")),l(r,"NotOperator",new r("not")),l(r,"OrOperator",new r("or")),l(r,"FalseType",new r("False")),l(r,"NoneType",new r("None")),l(r,"TrueType",new r("True")),l(r,"AsKeyword",new r("AsKeyword")),l(r,"AssertKeyword",new r("AssertKeyword")),l(r,"BreakKeyword",new r("BreakKeyword")),l(r,"ContinueKeyword",new r("continue")),l(r,"DelKeyword",new r("del")),l(r,"FromKeyword",new r("from")),l(r,"ImportKeyword",new r("import")),l(r,"InKeyword",new r("in")),l(r,"IsKeyword",new r("is")),l(r,"NotInKeyword",new r("not in")),l(r,"IsNotKeyword",new r("is not")),l(r,"PassKeyword",new r("pass")),l(r,"RaiseKeyword",new r("raise")),l(r,"ReturnKeyword",new r("return")),l(r,"WithKeyword",new r("with")),l(r,"YieldKeyword",new r("yield")),l(r,"GlobalKeyword",new r("global")),l(r,"AddOperator",new r("+")),l(r,"SubtractOperator",new r("-")),l(r,"MultiplyOperator",new r("*")),l(r,"DivideOperator",new r("/")),l(r,"ModulusOperator",new r("%")),l(r,"ExponentOperator",new r("**")),l(r,"IntDivideOperator",new r("//")),l(r,"AssignmentOperator",new r("=")),l(r,"IncrementOperator",new r("+=")),l(r,"DecrementOperator",new r("-=")),l(r,"MultiplyAssignOperator",new r("*=")),l(r,"DivideAssignOperator",new r("/=")),l(r,"RemainderAssignOperator",new r("%=")),l(r,"IntDivideAssignOperator",new r("//=")),l(r,"ExponentAssignOperator",new r("**=")),l(r,"EqualOperator",new r("==")),l(r,"NotEqualOperator",new r("!=")),l(r,"GreaterThanOperator",new r(">")),l(r,"LessThanOperator",new r("<")),l(r,"GreaterThanOrEqualOperator",new r(">=")),l(r,"LessThanOrEqualOperator",new r("<=")),l(r,"TypeHintReturn",new r("->")),l(r,"Decorator",new r("decorator")),l(r,"AbsFunction",new r("abs")),l(r,"AllFunction",new r("all")),l(r,"AnyFunction",new r("any")),l(r,"AsciiFunction",new r("ascii")),l(r,"AssertFunction",new r("assert")),l(r,"BinFunction",new r("bin")),l(r,"BoolFunction",new r("bool")),l(r,"CallableFunction",new r("callable")),l(r,"ChrFunction",new r("chr")),l(r,"DictFunction",new r("dict")),l(r,"DivModFunction",new r("divmod")),l(r,"EnumerateFunction",new r("enumerate")),l(r,"EvalFunction",new r("eval")),l(r,"ExecFunction",new r("exec")),l(r,"ExitFunction",new r("exit")),l(r,"FilterFunction",new r("filter")),l(r,"FloatFunction",new r("float")),l(r,"FormatFunction",new r("format")),l(r,"GetAttrFunction",new r("getattr")),l(r,"GlobalsFunction",new r("globals")),l(r,"HasAttrFunction",new r("hasattr")),l(r,"InputFunction",new r("input")),l(r,"IntFunction",new r("int")),l(r,"IsInstanceFunction",new r("isinstance")),l(r,"LenFunction",new r("len")),l(r,"ListFunction",new r("list")),l(r,"MapFunction",new r("map")),l(r,"MaxFunction",new r("max")),l(r,"MinFunction",new r("min")),l(r,"OpenFunction",new r("open")),l(r,"OrdFunction",new r("ord")),l(r,"PowFunction",new r("pow")),l(r,"PrintFunction",new r("print")),l(r,"QuitFunction",new r("quit")),l(r,"RangeFunction",new r("range")),l(r,"ReversedFunction",new r("reversed")),l(r,"RoundFunction",new r("round")),l(r,"SetFunction",new r("set")),l(r,"SortedFunction",new r("sorted")),l(r,"StrFunction",new r("str")),l(r,"SumFunction",new r("sum")),l(r,"TupleFunction",new r("tuple")),l(r,"TypeFunction",new r("type")),l(r,"ZipFunction",new r("zip")),l(r,"Capitalize",new r("capitalize")),l(r,"Casefold",new r("casefold")),l(r,"Center",new r("center")),l(r,"Count",new r("count")),l(r,"Encode",new r("encode")),l(r,"EndsWith",new r("endswith")),l(r,"ExpandTabs",new r("expandtabs")),l(r,"Find",new r("find")),l(r,"Format",new r("format")),l(r,"FormatMap",new r("format_map")),l(r,"Index",new r("index")),l(r,"IsAlnum",new r("isalnum")),l(r,"IsAlpha",new r("isalpha")),l(r,"IsAscii",new r("isascii")),l(r,"IsDecimal",new r("isdecimal")),l(r,"IsDigit",new r("isdigit")),l(r,"IsIdentifier",new r("isidentifier")),l(r,"IsLower",new r("islower")),l(r,"IsNumeric",new r("isnumeric")),l(r,"IsPrintable",new r("isprintable")),l(r,"IsSpace",new r("isspace")),l(r,"IsTitle",new r("istitle")),l(r,"IsUpper",new r("isupper")),l(r,"Join",new r("join")),l(r,"LJust",new r("ljust")),l(r,"Lower",new r("lower")),l(r,"LStrip",new r("lstrip")),l(r,"MakeTrans",new r("maketrans")),l(r,"Partition",new r("partition")),l(r,"Replace",new r("replace")),l(r,"RFind",new r("rfind")),l(r,"RIndex",new r("rindex")),l(r,"RJust",new r("rjust")),l(r,"RPartition",new r("rpartition")),l(r,"RSplit",new r("rsplit")),l(r,"RStrip",new r("rstrip")),l(r,"Split",new r("split")),l(r,"SplitLines",new r("splitlines")),l(r,"StartsWith",new r("startswith")),l(r,"Strip",new r("strip")),l(r,"SwapCase",new r("swapcase")),l(r,"Title",new r("title")),l(r,"Translate",new r("translate")),l(r,"Upper",new r("upper")),l(r,"ZFill",new r("zfill")),l(r,"Append",new r("append")),l(r,"Clear",new r("clear")),l(r,"Copy",new r("copy")),l(r,"Extend",new r("extend")),l(r,"Insert",new r("insert")),l(r,"Pop",new r("pop")),l(r,"Remove",new r("remove")),l(r,"Reverse",new r("reverse")),l(r,"Sort",new r("sort")),l(r,"FromKeys",new r("fromkeys")),l(r,"Get",new r("get")),l(r,"Items",new r("items")),l(r,"Keys",new r("keys")),l(r,"PopItem",new r("popitem")),l(r,"SetDefault",new r("setdefault")),l(r,"Update",new r("update")),l(r,"Values",new r("values")),l(r,"Add",new r("add")),l(r,"Difference",new r("difference")),l(r,"DifferenceUpdate",new r("difference_update")),l(r,"Discard",new r("discard")),l(r,"Intersection",new r("intersection")),l(r,"IntersectionUpdate",new r("intersection_update")),l(r,"IsDisjoint",new r("isdisjoint")),l(r,"IsSubset",new r("issubset")),l(r,"IsSuperset",new r("issuperset")),l(r,"SymmetricDifference",new r("symmetric_difference")),l(r,"SymmetricDifferenceUpdate",new r("symmetric_difference_update")),l(r,"Union",new r("union")),l(r,"Close",new r("close")),l(r,"Detach",new r("detach")),l(r,"FileNo",new r("fileno")),l(r,"Flush",new r("flush")),l(r,"IsAtty",new r("isatty")),l(r,"Read",new r("read")),l(r,"Readable",new r("readable")),l(r,"ReadLine",new r("readline")),l(r,"ReadLines",new r("readlines")),l(r,"Seek",new r("seek")),l(r,"Seekable",new r("seekable")),l(r,"Tell",new r("tell")),l(r,"Truncate",new r("truncate")),l(r,"Writable",new r("writable")),l(r,"Write",new r("write")),l(r,"WriteLines",new r("writelines")),l(r,"Main",new r("__main__")),l(r,"Cmp",new r("__cmp__")),l(r,"Eq",new r("__eq__")),l(r,"Ne",new r("__ne__")),l(r,"Lt",new r("__lt__")),l(r,"Gt",new r("__gt__")),l(r,"Le",new r("__le__")),l(r,"Ge",new r("__ge__")),l(r,"Str",new r("__str__")),l(r,"SpecialContains",new r("__contains__")),l(r,"SpecialLen",new r("__len__")),l(r,"Name",new r("__name__")),l(r,"Self",new r("__self__")),l(r,"Doc",new r("__doc__")),l(r,"GetAttrVariable",new r("__getattr__")),l(r,"SetAttrVariable",new r("__setattr__")),l(r,"ClassVariable",new r("__class__")),l(r,"R",new r("r")),l(r,"F",new r("f")),l(r,"Sep",new r("sep")),l(r,"End",new r("end")),l(r,"Dot",new r(".")),l(r,"OpenParenthesis",new r("(")),l(r,"CloseParenthesis",new r(")")),l(r,"OpenSquareBracket",new r("[")),l(r,"CloseSquareBracket",new r("]")),l(r,"OpenBrace",new r("{")),l(r,"CloseBrace",new r("}")),l(r,"Comma",new r(",")),l(r,"Colon",new r(":")),l(r,"SingleQuote",new r("'")),l(r,"DoubleQuote",new r('"')),l(r,"MultiLineCommentDelimiter",new r("'''")),l(r,"ImportAll",new r("import all (*)")),l(r,"NamedImport",new r("named import")),l(r,"ExceptionName",new r("exceptionName")),l(r,"VariableName",new r("variableName")),l(r,"FunctionName",new r("functionName")),l(r,"MethodName",new r("methodName")),l(r,"ClassName",new r("className")),l(r,"PropertyName",new r("propertyName")),l(r,"ModuleName",new r("moduleName")),l(r,"IntLiteral",new r("intLiteral")),l(r,"StringLiteral",new r("stringLiteral")),l(r,"ContinuationLine",new r("continuationLine")),l(r,"Separator",new r("separator")),l(r,"FloatLiteral",new r("floatLiteral")),l(r,"SingleLineComment",new r("singleLineComment")),l(r,"MultiLineComment",new r("multilineComment")),l(r,"TypeHint",new r("typeHint")),l(r,"StrType",new r("strType")),l(r,"IntType",new r("intType")),l(r,"FloatType",new r("floatType")),l(r,"BoolType",new r("boolType")),l(r,"ListType",new r("listType")),l(r,"SetType",new r("setType")),l(r,"DictType",new r("dictType")),l(r,"TupleType",new r("tupleType")),l(r,"ListDefinition",new r("listDefinition")),l(r,"TupleDefinition",new r("tupleDefinition")),l(r,"SetDefinition",new r("setDefinition")),l(r,"DictDefinition",new r("dictDefinition")),l(r,"IndexKey",new r("indexKey")),l(r,"Slice",new r("slice")),l(r,"Unknown",new r("unknown")),l(r,"RandomModule",new r("randomModule")),l(r,"MathModule",new r("mathModule")),l(r,"StringModule",new r("stringModule")),l(r,"ReModule",new r("reModule")),l(r,"Pattern",new r("Pattern")),l(r,"Match",new r("Match")),l(r,"Sys",new r("sys")),l(r,"Seed",new r("seed")),l(r,"GetState",new r("getstate")),l(r,"SetState",new r("setstate")),l(r,"GetRandBits",new r("getrandbits")),l(r,"RandRange",new r("randrange")),l(r,"RandInt",new r("randint")),l(r,"Choice",new r("choice")),l(r,"Choices",new r("choices")),l(r,"Shuffle",new r("shuffle")),l(r,"Sample",new r("sample")),l(r,"RandomMethod",new r("random")),l(r,"Uniform",new r("uniform")),l(r,"Triangular",new r("triangular")),l(r,"BetaVariate",new r("betavariate")),l(r,"ExpoVariate",new r("expovariate")),l(r,"GammaVariate",new r("gammavariate")),l(r,"Gauss",new r("gauss")),l(r,"LogNormVariate",new r("lognormvariate")),l(r,"NormalVariate",new r("normalvariate")),l(r,"VonMisesVariate",new r("vonmisesvariate")),l(r,"ParetoVariate",new r("paretovariate")),l(r,"WeibullVariate",new r("weibullvariate")),l(r,"Acos",new r("acos")),l(r,"Acosh",new r("acosh")),l(r,"Asin",new r("asin")),l(r,"Asinh",new r("asinh")),l(r,"Atan",new r("atan")),l(r,"Atan2",new r("atan2")),l(r,"Atanh",new r("atanh")),l(r,"Ceil",new r("ceil")),l(r,"Comb",new r("comb")),l(r,"CopySign",new r("copysign")),l(r,"Cos",new r("cos")),l(r,"Cosh",new r("cosh")),l(r,"Degrees",new r("degrees")),l(r,"Dist",new r("dist")),l(r,"Erf",new r("erf")),l(r,"Erfc",new r("erfc")),l(r,"Exp",new r("exp")),l(r,"Expm1",new r("expm1")),l(r,"Fabs",new r("fabs")),l(r,"Factorial",new r("factorial")),l(r,"Floor",new r("floor")),l(r,"Fmod",new r("fmod")),l(r,"Frexp",new r("frexp")),l(r,"Fsum",new r("fsum")),l(r,"Gamma",new r("gamma")),l(r,"Gcd",new r("gcd")),l(r,"Hypot",new r("hypot")),l(r,"IsClose",new r("isclose")),l(r,"IsFinite",new r("isfinite")),l(r,"IsInf",new r("isinf")),l(r,"IsNaN",new r("isnan")),l(r,"ISqrt",new r("isqrt")),l(r,"Ldexp",new r("ldexp")),l(r,"LGamma",new r("lgamma")),l(r,"Log",new r("log")),l(r,"Log10",new r("log10")),l(r,"Log1P",new r("log1p")),l(r,"Log2",new r("log2")),l(r,"Perm",new r("perm")),l(r,"Pow",new r("pow")),l(r,"Prod",new r("prod")),l(r,"Radians",new r("radians")),l(r,"Remainder",new r("remainder")),l(r,"Sin",new r("sin")),l(r,"Sinh",new r("sinh")),l(r,"Sqrt",new r("sqrt")),l(r,"Tan",new r("tan")),l(r,"Tanh",new r("tanh")),l(r,"Trunc",new r("trunc")),l(r,"E",new r("e")),l(r,"Inf",new r("inf")),l(r,"Nan",new r("nan")),l(r,"Pi",new r("pi")),l(r,"Tau",new r("tau")),l(r,"AsciiLetters",new r("ascii_letters")),l(r,"AsciiLowercase",new r("ascii_lowercase")),l(r,"AsciiUppercase",new r("ascii_uppercase")),l(r,"Digits",new r("digits")),l(r,"Hexdigits",new r("hexdigits")),l(r,"Octdigits",new r("octdigits")),l(r,"Punctuation",new r("punctuation")),l(r,"Printable",new r("printable")),l(r,"Whitespace",new r("whitespace")),l(r,"Formatter",new r("Formatter")),l(r,"Template",new r("Template")),l(r,"Capwords",new r("capwords")),l(r,"ReA",new r("A")),l(r,"ReASCII",new r("ASCII")),l(r,"ReDebug",new r("DEBUG")),l(r,"ReI",new r("I")),l(r,"ReIGNORECASE",new r("IGNORECASE")),l(r,"ReL",new r("L")),l(r,"ReLOCALE",new r("LOCALE")),l(r,"ReM",new r("M")),l(r,"ReMULTILINE",new r("MULTILINE")),l(r,"ReS",new r("S")),l(r,"ReDOTALL",new r("DOTALL")),l(r,"ReX",new r("X")),l(r,"ReVERBOSE",new r("VERBOSE")),l(r,"Compile",new r("compile")),l(r,"Search",new r("search")),l(r,"Match",new r("match")),l(r,"FullMatch",new r("fullmatch")),l(r,"FindAll",new r("findall")),l(r,"FindIter",new r("finditer")),l(r,"Sub",new r("sub")),l(r,"SubN",new r("subn")),l(r,"Escape",new r("escape")),l(r,"Purge",new r("purge")),l(r,"AddAuditHook",new r("addaudithook")),l(r,"Audit",new r("audit")),l(r,"CallTracing",new r("call_tracing")),l(r,"ClearTypeCache",new r("_clear_type_cache")),l(r,"CurrentFrames",new r("_current_frames")),l(r,"CurrentExceptions",new r("_current_exceptions")),l(r,"BreakpointHook",new r("breakpointhook")),l(r,"DebugMallocStats",new r("_debugmallocstats")),l(r,"DisplayHook",new r("displayhook")),l(r,"ExceptHook",new r("excepthook")),l(r,"ExcInfo",new r("exc_info")),l(r,"SysExit",new r("exit")),l(r,"GetAllocatedBlocks",new r("getallocatedblocks")),l(r,"GetAndroidApiLevel",new r("getandroidapilevel")),l(r,"GetDefaultEncoding",new r("getdefaultencoding")),l(r,"GetDLOpenFlags",new r("getdlopenflags")),l(r,"GetFileSystemEncoding",new r("getfilesystemencoding")),l(r,"GetFileSystemEncodeErrors",new r("getfilesystemencodeerrors")),l(r,"GetRefCount",new r("getrefcount")),l(r,"GetRecursionLimit",new r("getrecursionlimit")),l(r,"GetSizeOf",new r("getsizeof")),l(r,"GetSwitchInterval",new r("getswitchinterval")),l(r,"GetFrame",new r("_getframe")),l(r,"GetProfile",new r("getprofile")),l(r,"GetTrace",new r("gettrace")),l(r,"GetWindowsVersion",new r("getwindowsversion")),l(r,"GetAsyncGenHooks",new r("get_asyncgen_hooks")),l(r,"GetCoroutineOriginTrackingDepth",new r("get_coroutine_origin_tracking_depth")),l(r,"Intern",new r("intern")),l(r,"IsFinalizing",new r("is_finalizing")),l(r,"SetDLOpenFlags",new r("setdlopenflags")),l(r,"SetProfile",new r("setprofile")),l(r,"SetRecursionLimit",new r("setrecursionlimit")),l(r,"SetSwitchInterval",new r("setswitchinterval")),l(r,"SetTrace",new r("settrace")),l(r,"SetAsyncgenHooks",new r("set_asyncgen_hooks")),l(r,"EnableLegacyWindowsFSEncoding",new r("_enablelegacywindowsfsencoding")),l(r,"ABIFlags",new r("abiflags")),l(r,"Argv",new r("argv")),l(r,"BaseExecPrefix",new r("base_exec_prefix")),l(r,"BasePrefix",new r("base_prefix")),l(r,"ByteOrder",new r("byte_order")),l(r,"BuiltInModuleNames",new r("built_in_module_names")),l(r,"Copyright",new r("copyright")),l(r,"DllHandle",new r("dllhandle")),l(r,"DontWriteBytecode",new r("dont_write_bytecode")),l(r,"PycachePrefix",new r("pycache_prefix")),l(r,"ExecPrefix",new r("exec_prefix")),l(r,"Executable",new r("executable")),l(r,"Flags",new r("flags")),l(r,"FloatInfo",new r("float_info")),l(r,"FloatReprStyle",new r("float_repr_style")),l(r,"HashInfo",new r("hash_info")),l(r,"HexVersion",new r("hexversion")),l(r,"Implementation",new r("implementation")),l(r,"IntInfo",new r("int_info")),l(r,"LastType",new r("last_type")),l(r,"LastValue",new r("last_value")),l(r,"LastTraceback",new r("last_traceback")),l(r,"MaxSize",new r("maxsize")),l(r,"MaxUnicode",new r("maxunicode")),l(r,"MetaPath",new r("meta_path")),l(r,"Modules",new r("modules")),l(r,"OrigArgv",new r("orig_argv")),l(r,"Path",new r("path")),l(r,"PathHooks",new r("path_hooks")),l(r,"PathImporterCache",new r("path_importer_cache")),l(r,"Platform",new r("platform")),l(r,"Prefix",new r("prefix")),l(r,"PS1",new r("ps1")),l(r,"PS2",new r("ps2")),l(r,"StdIn",new r("stdin")),l(r,"StdOut",new r("stdout")),l(r,"StdErr",new r("stderr")),l(r,"StdLibModuleNames",new r("stdlib_module_names")),l(r,"ThreadInfo",new r("thread_info")),l(r,"TracebackLimit",new r("tracebacklimit")),l(r,"Version",new r("version")),l(r,"ApiVersion",new r("api_version")),l(r,"VersionInfo",new r("version_info")),l(r,"WarnOptions",new r("warnoptions")),l(r,"WinVer",new r("winver")),l(r,"XOptions",new r("_xoptions")),l(r,"UserDefinedFunctionCall",new r("UserDefinedFunctionCall")),l(r,"BuiltInFunctionCall",new r("BuiltInFunctionCall")),l(r,"UserDefinedMethodCall",new r("UserDefinedMethodCall")),l(r,"BuiltInMethodCall",new r("BuiltInMethodCall")),l(r,"ExceptionCall",new r("ExceptionCall")),l(r,"FunctionDefinitionStatement",new r("FunctionDefinitionStatement")),l(r,"MethodDefinitionStatement",new r("MethodDefinitionStatement")),l(r,"ForDefinitionStatement",new r("ForDefinitionStatement")),l(r,"ExceptDefinitionStatement",new r("ExceptDefinitionStatement")),l(r,"ClassDefinitionStatement",new r("ClassDefinitionStatement")),l(r,"LambdaDefinitionStatement",new r("LambdaDefinitionStatement")),l(r,"IfDefinitionStatement",new r("IfDefinitionStatement")),l(r,"ElifDefinitionStatement",new r("ElifDefinitionStatement")),l(r,"ElseDefinitionStatement",new r("ElseDefinitionStatement")),l(r,"WhileDefinitionStatement",new r("WhileDefinitionStatement")),l(r,"TryDefinitionStatement",new r("TryDefinitionStatement")),l(r,"FinallyDefinitionStatement",new r("FinallyDefinitionStatement")),l(r,"TernaryStatement",new r("TernaryStatement")),l(r,"WithDefinitionStatement",new r("WithStatment")),l(r,"GroupStatement",new r("GroupStatement")),l(r,"FString",new r("FString")),l(r,"SubscriptedExpression",new r("SubscriptedExpression")),l(r,"CalculatedExpression",new r("CalculatedExpression")),l(r,"ComparisonExpression",new r("ComparisonExpression")),l(r,"BooleanExpression",new r("BooleanExpression")),l(r,"IteratorExpression",new r("IteratorExpression")),l(r,"CombinedStringLiteral",new r("CombinedStringLiteral")),l(r,"ReturnStatement",new r("ReturnStatement")),l(r,"PropertyCallExpression",new r("PropertyCallExpression")),l(r,"AssignmentStatement",new r("AssignmentStatement")),l(r,"ChangeStatement",new r("ChangeStatement")),l(r,"ImportStatement",new r("ImportStatement")),l(r,"AssertStatement",new r("AssertStatement")),l(r,"GlobalStatement",new r("GlobalStatement")),l(r,"ThrowStatement",new r("ThrowStatement"));let t=r;const P=class P extends G{constructor(i,e=!1,n=new Map,s=new Map){super(i),this.isCustom=e,this.attributes=n,this.methods=s}static createCustomType(i){return P[i]=new P(i,!0),P[i]}toJSON(){return{name:this.name,attributes:Array.from(this.attributes.values()).map(i=>i.toJSON()),methods:Array.from(this.methods.values()).map(i=>i.toJSON())}}};l(P,"Int",new P("int")),l(P,"Float",new P("float")),l(P,"Number",new P("number (int or float)")),l(P,"String",new P("string")),l(P,"Bool",new P("bool")),l(P,"List",new P("list")),l(P,"Set",new P("set")),l(P,"Tuple",new P("tuple")),l(P,"Dict",new P("dictionary")),l(P,"File",new P("file")),l(P,"Function",new P("function")),l(P,"Class",new P("class")),l(P,"None",new P("none")),l(P,"Exception",new P("exception")),l(P,"Unknown",new P("unknown data type")),l(P,"NA",new P("N/A")),l(P,"NotParsed",new P("not parsed")),l(P,"Invalid",new P("invalid")),l(P,"Undefined",new P("undefined")),l(P,"Random",new P("random")),l(P,"Math",new P("math")),l(P,"StringModule",new P("string module")),l(P,"Re",new P("re")),l(P,"Pattern",new P("Pattern")),l(P,"Match",new P("Match")),l(P,"Sys",new P("sys"));let d=P;const V=class V extends G{constructor(e,n){super(e);l(this,"description");this.description=n}};l(V,"AssignCompares",new V("AssignCompares","A single equals is used where a boolean expression is expected, e.g. in a conditional statement. This may be a typo or confusion between single and double equals operators.")),l(V,"ColonAssigns",new V("ColonAssigns","A colon is used between a variable name and a value. This may be a typo.")),l(V,"CompareMultipleValuesWithOr",new V("CompareMultipleValuesWithOr","A boolean expression has the form a == some_value or other_value, where other_value is non-boolean. There is likely a misunderstanding of the syntax of comparing multiple values.")),l(V,"ComparisonWithBoolLiteral",new V("ComparisonWithBoolLiteral",'A boolean expression contains "== True" or "== False". The programmer may believe that explicitly checking equality is always necessary in a boolean expression.')),l(V,"DeferredReturn",new V("DeferredReturn","Code follows a return statement in a function. The programmer may not realise that a return statement causes the function to exit immediately.")),l(V,"ForLoopVarIsLocal",new V("ForLoopVarIsLocal","An iterating variable in a for loop overwrites a variable declared before the loop and the value is different from the overwritten value, or the values cannot be determined. This potential misconception is similar to IteratorInitialisedOutsideLoop.")),l(V,"FunctionCallsNoParentheses",new V("FunctionCallsNoParentheses","An undefined variable has the same name as a function. There may be a misunderstanding about how to call a function. Caution: functions in Python are first class objects, so it is possible that use of the function name without parentheses is intended and there is no misconception.")),l(V,"FunctionCallsUseSquareBrackets",new V("FunctionCallsUseSquareBrackets","The name of a function is called followed by square brackets rather than parentheses. The programmer may not be aware of when to use which type of bracket.")),l(V,"IterationRequiresTwoLoops",new V("IterationRequiresTwoLoops","A while loop with an integer loop variable contains a nested for loop. The while loop variable is only modified in the nested for loop and is used to count items in the variable iterated in the for loop. The two nested loops could be replaced with a single for loop using enumerate() or range().")),l(V,"IteratorInitialisedOutsideLoop",new V("TargetInitialisedOutsideLoop","The target variable in a for loop is initialised before the loop with the same value. The programmer may not know that the iterating variable is initialised in the for loop definition.")),l(V,"LocalVariablesAreGlobal",new V("LocalVariablesAreGlobal","An undefined variable in document scope has the same name as a variable with function scope. This may indicate a misunderstanding of variable scope.")),l(V,"LoopCounter",new V("LoopCounter","A for loop target variable is modified in the loop and the modified variable is not used. This may indicate confusion over how loops use loop variables.")),l(V,"MapToBooleanWithIf",new V("MapToBooleanWithIf","A conditional statement checks a boolean expression only to return or assign a value that matches the value of the boolean expression. The programmer may not realise that a boolean expression can be assigned or returned directly.")),l(V,"MapToBooleanWithTernaryOperator",new V("MapToBooleanWithTernaryOperator","A ternary checks a boolean expression only to return or assign a value that matches the value of the boolean expression. The programmer may not realise that a boolean expression can be assigned or returned directly.")),l(V,"NoKeyword",new V("NoKeyword","A block definition keyword (e.g. def, if, while) is missing where one is expected. The programmer may not realise that the keyword is required.")),l(V,"NoReservedWords",new V("NoReservedWords","Any string that meets naming character constraints can be used as an identifier (name of a variable, function, method, or class).")),l(V,"ParameterMustBeAssignedInFunction",new V("ParameterMustBeAssignedInFunction","A user defined function has named parameter but the parameter value is overwritten in the function before it is used e.g. by prompting for command line input. This indicates potential misconceptions about the purpose or use of function parameters.")),l(V,"ParenthesesOnlyIfArgument",new V("ParenthesesOnlyIfArgument","An undefined variable has the same name as a user-defined function with no arguments. There may be a misunderstanding of the syntax of function calls.")),l(V,"PrintSameAsReturn",new V("PrintSameAsReturn","A call to a function that prints but does not return (including the print() function) is assigned or passed, or a call to a function that prints before returning a value is not assigned or passed. There may be confusion about printing a value versus returning a value.")),l(V,"ReturnCall",new V("ReturnCall","Function return values are surrounded by parentheses. There may be a belief that return needs to be called like a function.")),l(V,"ReturnWaitsForLoop",new V("ReturnWaitsForLoop","A return statement in a loop causes the loop to consistently exit on the first iteration. Typically due to a missing if statement, there may be an expectation that the loop implicitly knows when to return and when to continue.")),l(V,"SequentialIfsAreExclusive",new V("ConditionalIsSequence","If statements with very similar conditional statements appear in a sequence. There may be a belief that subsequent if statements will only execute if the previous condition does not. The programmer may not be aware of the efficiency drawbacks of using sequential if statements where a multiway conditional would be more appropriate.")),l(V,"StringMethodsModifyTheString",new V("StringMethodsModifyTheString","A string method is called but the result is not saved or passed. There may be an assumption that string methods mutate the string.")),l(V,"TypeConversionModifiesArgument",new V("TypeConversionModifiesArgument","A type conversion function (e.g. int(), float()) is called but the return value is not saved or used.")),l(V,"TypeMustBeSpecified",new V("TypeMustBeSpecified","A value that is guaranteed to have a particular data type is passed to a type conversion function that returns the same data type. In the case of literals, there may be a belief that type must be specified as in strongly typed languages. In other cases, there may be a misunderstanding or lack of confidence in how Python dynamically determines type.")),l(V,"UnusedReturn",new V("UnusedReturn","The result of a call to a function / method that returns a value is not used in some way.")),l(V,"WhileSameAsIf",new V("WhileSameAsIf","A while loop does not modify any of its loop variables and may also always exit during the first iteration. Where this behaviour is intentional, the while definition would be better replaced with an if statement. Where the loop does not exit, there is a risk of an infinite loop."));let L=V;const x=class x extends G{constructor(e,n){super(e);l(this,"description");this.description=n}};l(x,"AssignmentInBoolean",new x("AssignmentInBoolean","An assignment operator is used in a Boolean expression. This could be a typo or an indication of confusion about = and ==.")),l(x,"AssignmentInReturn",new x("AssignmentInReturn","A variable is assigned in a return statement.")),l(x,"AssignedNone",new x("AssignedNoReturn","A function or method that does not return a value is assigned to a variable, passed as an argument, or used in some way. Commonly seen with the print() function.")),l(x,"CompareBoolLiteral",new x("CompareBoolLiteral","A Boolean expression is compared to a Boolean literal. Although this is not an error, it may indicate a misconception about Boolean values.")),l(x,"DefinitionFollowedByReservedWord",new x("DefinitionFollowedByReservedWord","A definition keyword (def or class) is followed by a reserved word, suggesting the intention to define a function or class with the same name as a reserved word.")),l(x,"DoubleComparisonOperators",new x("DoubleComparisonOperators","Two comparison operators are used side by side. This may be due to an extra space e.g. <= is written as < =.")),l(x,"ForLoopIteratorModified",new x("ForLoopTargetModified","A for loop target variable is modified in the loop and the modified value is not used.")),l(x,"FunctionPrints",new x("FunctionPrints","A user-defined function contains print statements. This is not an issue unless AssignedNoReturn is also present and print is used in place of return statements.")),l(x,"InfiniteLoop",new x("InfiniteLoop","A while loop does not exit.")),l(x,"LoopReturn",new x("LoopEarlyExit","A return or break statement causes a loop to always exit on the first iteration.")),l(x,"LoopVarModifiedInChildLoop",new x("WhileLoopVarModifiedInChildLoop","A while loop variable is modified in a nested for or while loop.")),l(x,"LoopVarNotModified",new x("WhileLoopVarNotModified","None of the variables used in a while loop definition are modified in the body of the while loop. If the while loop contains a nested loop, only usages of the variable in the outer loop are checked.")),l(x,"NaturalLanguageBoolean",new x("NaturalLanguageBoolean",`A Boolean expression uses syntax that makes sense in spoken English but may produce unexpected results or even and error in Python. The most common form is checking if a particular expression is equal to one of a range of values using "or <non_boolean>" e.g., "day == 'sat' or 'sun'".`)),l(x,"OneLineConditional",new x("OneLineConditional","A conditional that could be re-written as one line. Although this is not an error, it may indicate a misconception about Boolean values.")),l(x,"OutOfPlaceBooleanOperator",new x("OutOfPlaceOperatorsInBoolean","A comparison or logical operator is used in an unexpected place in a conditional expression.")),l(x,"OverwrittenVariable",new x("VariableOverwrite","A variable's value is initialised or changed then overwritten without being used.")),l(x,"RedundantException",new x("RedundantException","A specific exception is caught then immediately raised. Suggests confusion about how to work with exceptions.")),l(x,"ReservedWordAssigned",new x("ReservedWordAssigned","A reserved word is followed by the assignment operator, suggesting an intention to create a variable with the same name as a reserved word.")),l(x,"ReturnInParentheses",new x("ReturnInParentheses","The return keyword is followed by a value or compound expression in parentheses. May suggest a belief that returned values must be encapsulated in parentheses.")),l(x,"SequentialIfs",new x("SequentialIfs","Multiple if statements appear in sequence with no other code between the if blocks. If statements that contain a return or break at the top level are not included. Depending on the contents of the boolean expressions and each block, it may indicate a misconception about how conditionals are evaluated.")),l(x,"SubscriptedNonSubscriptable",new x("SubscriptedNonSubscriptable","Square brackets follow a variable name that does not have a subscriptable type (i.e. is not a string, list, tuple, or dictionary)")),l(x,"TernaryReturnsBool",new x("TernaryReturnsBool","A ternary returns a boolean. Although this is not an error, it may indicate a misconception about Boolean values.")),l(x,"TypeErrorInvalid",new x("InvalidCalculation","A calculation that produces a TypeError e.g. string + int.")),l(x,"TypeUnnecessary",new x("UnnecessaryTypeConversion","A value that has a guaranteed data type is passed to a type conversion function that produces the same data type. Also captures strings converted to lists.")),l(x,"UndefinedVariable",new x("UndefinedVariable","A variable that was not declared is called. Depending on context, may be due to sloppiness (e.g. a typo) or may suggest misconception about variable scope, function parameters, or how to call functions.")),l(x,"UnexpectedColon",new x("UnexpectedColon","A colon is found where it is not expected, indicating either a typo or a misunderstanding of syntax.")),l(x,"UnknownFunction",new x("UnknownFunction","A function that is not defined in the file or built in to Python is called. Could be a typo or a misunderstanding about variables.")),l(x,"UnknownMethod",new x("UnknownMethod","An unknown method, or a method that is not valid is called on a value with known data type.")),l(x,"UnreachableExhaustiveConditional",new x("UnreachableCode.exhaustiveConditional","Code that is unreachable because it follows a conditional with an else branch in which all branches return.")),l(x,"UnreachableExit",new x("UnreachableCode.exitKeyword","Code that is unreachable because it follows a <code>return</code> or <code>break</code> statement. This might indicate a misconception about how those keywords affect the flow of control.")),l(x,"UnreachableInfiniteLoop",new x("UnreachableCode.infiniteLoop",'Code that is unreachable because it follows a loop created using "while True" that never exits.')),l(x,"UnusedReturn",new x("UnusedReturn","The result of a call to a function / method that returns a value is not used in some way.")),l(x,"UnusedValue",new x("UnusedValue","A value (either a single variable or a compound expression) is created but not assigned to a variable, passed as a function argument, or used in some other way.")),l(x,"UnusedVariable",new x("UnusedVariable","A variable is not used after initialisation. May be an oversight but could potentially indicate misconceptions about variables.")),l(x,"VariableWithSameNameAsFunction",new x("VariableWithSameNameAsFunction","A variable has the same name as a function.")),l(x,"WhileLoopVarAssignedIntLiteral",new x("WhileLoopVarAssignedIntLiteral","A while loop counter variable is assigned an int value rather than incremented or decremented. The variable is not modified elsewhere in the loop.")),l(x,"WrongArgNumber",new x("WrongArgNumber","A user-defined function is called with the wrong number of arguments.")),l(x,"WhileTrue",new x("WhileTrue","A while loop is defined to iterate forever. This is a valid approach but may be a contributor to misconceptions when combined with other symptoms."));let b=x;const zt="userDefinedFunction",ec="userDefinedVariable",Qt="builtInFunction",ii="valueReturned",ri="valueAssigned",tc="True",dr="return",nc="string",sc="list",ic="literal",hr="functionCall",rc="variable",fr="compoundTypeDefinition",gr="compoundExpression",pr="booleanExpression",oi="forLoopVariable",oc="forLoopTargetReplacesIterable",ai="assignment",li="same",mr="different",xs="unknown",ce="empty",ac="orNonBoolean",lc="andOr",cc="topLevel",uc="allBranchesOfExhaustiveConditional",wr="functionArgument",dc="calculation",hc="comparison";function q(g,i){this.entity=g,this.category=i}function Bs(g){switch(g){case t.TrueType:case t.FalseType:return d.Bool;case t.NoneType:return d.None;case t.StrType:case t.IntType:case t.FloatType:case t.BoolType:case t.ListType:case t.SetType:case t.DictType:case t.TupleType:return d.Class;case t.Name:case t.Doc:case t.Sep:case t.End:return d.String;case t.IntLiteral:return d.Int;case t.FloatLiteral:return d.Float;case t.StringLiteral:return d.String;case t.ListDefinition:return d.List;case t.TupleDefinition:return d.Tuple;case t.SetDefinition:return d.Set;case t.DictDefinition:return d.Dict;case t.RandomModule:return d.Random;case t.MathModule:return d.Math;case t.StringModule:return d.StringModule;case t.ReModule:return d.Re;case t.Pattern:return d.Pattern;case t.Match:return d.Match;case t.Sys:return d.Sys;default:return d.Unknown}}function Nt(g){if(g.length===0)return d.Undefined;if(g.length===1)return g[0];{const i=new Set(g);if(i.size===1)return g[0];for(let e of i)if(e!==d.Int&&e!==d.Float&&e!==d.Number)return d.Unknown;return d.Number}}function As(g){return new Set([d.String,d.List,d.Dict,d.Tuple,d.Unknown,d.NotParsed]).has(g)}function oe(g,i=!1){if(g.length===0)return"";let e=g[0].getTextValue();const n=i?g[0].getIndexOnLine():0;for(let s=0;s<n;s++)e=" "+e;for(let s=1;s<g.length;s++){let o=g[s].getDocumentStartIndex()-g[s-1].getDocumentEndIndex()-1;for(let c=g[s-1].getEndLineNumber();c<g[s].getStartLineNumber();c++)e+=`
`,o--;for(let c=0;c<o;c++)e+=" ";e+=g[s].getTextValue()}return e}function ks(g){const i=[];for(const e of g){const n=e.getExpressions();i.push(...n)}return i}function En(g,i){for(let e of g)if(e.is(i))return!0;return!1}function Xt(g){return g.getExpressionsOfKind(t.ReturnKeyword).length>0||g.getExpressionsOfKind(t.BreakKeyword).length>0||g.getExpressionsOfKind(t.ExitFunction).length>0||g.getExpressionsOfKind(t.SysExit).length>0||g.getExpressionsOfKind(t.QuitFunction).length>0}function Zt(g,i){for(let e=0;e<g.length;e++)if(g[e].is(i))return e;return-1}function fc(g){return new Set(["str","int","float","bool","str","list","set","dict"]).has(g)}function Ct(g){return g.isOneOf([t.UserDefinedFunctionCall,t.BuiltInFunctionCall,t.UserDefinedMethodCall,t.BuiltInMethodCall])&&g.getDataType()===d.None}function ci(g,i,e){if(!gc(i,e))return!1;let n=0,s=0;for(let o of g)o.is(i)?n++:o.is(e)&&s++;return n>0&&n===s}function gc(g,i){return g===t.OpenParenthesis?i===t.CloseParenthesis:g===t.OpenBrace?i===t.CloseBrace:g===t.OpenSquareBracket?i===t.CloseSquareBracket:!1}function Sr(g){return g===t.OpenBrace||g===t.OpenParenthesis||g===t.OpenSquareBracket}function pc(g){return g===t.CloseBrace||g===t.CloseParenthesis||g===t.CloseSquareBracket}function mc(g){if(!Sr(g))throw new Error(`${g} is not a valid open bracket.`);return g===t.OpenBrace?t.CloseBrace:g===t.OpenParenthesis?t.CloseParenthesis:t.CloseSquareBracket}const h=(g,i)=>({entity:g,category:i}),We=g=>{switch(g){case"class":return h(t.ClassDefinition,a.BlockDefinitions);case"def":return h(t.FunctionDefinition,a.BlockDefinitions);case"elif":return h(t.ElifDefinition,a.BlockDefinitions);case"else":return h(t.ElseDefinition,a.BlockDefinitions);case"except":return h(t.ExceptDefinition,a.BlockDefinitions);case"finally":return h(t.FinallyDefinition,a.BlockDefinitions);case"for":return h(t.ForDefinition,a.BlockDefinitions);case"if":return h(t.IfDefinition,a.BlockDefinitions);case"lambda":return h(t.LambdaDefinition,a.BlockDefinitions);case"try":return h(t.TryDefinition,a.BlockDefinitions);case"while":return h(t.WhileDefinition,a.BlockDefinitions);case"with":return h(t.WithKeyword,a.BlockDefinitions);case"and":return h(t.AndOperator,a.LogicalOperators);case"not":return h(t.NotOperator,a.LogicalOperators);case"or":return h(t.OrOperator,a.LogicalOperators);case"False":return h(t.FalseType,a.Types);case"None":return h(t.NoneType,a.Types);case"True":return h(t.TrueType,a.Types);case"as":return h(t.AsKeyword,a.OtherKeywords);case"global":return h(t.GlobalKeyword,a.OtherKeywords);case"assert":return h(t.AssertKeyword,a.OtherKeywords);case"break":return h(t.BreakKeyword,a.OtherKeywords);case"continue":return h(t.ContinueKeyword,a.OtherKeywords);case"del":return h(t.DelKeyword,a.OtherKeywords);case"from":return h(t.FromKeyword,a.OtherKeywords);case"import":return h(t.ImportKeyword,a.OtherKeywords);case"in":return h(t.InKeyword,a.ComparisonOperators);case"is":return h(t.IsKeyword,a.ComparisonOperators);case"pass":return h(t.PassKeyword,a.OtherKeywords);case"raise":return h(t.RaiseKeyword,a.OtherKeywords);case"return":return h(t.ReturnKeyword,a.OtherKeywords);case"yield":return h(t.YieldKeyword,a.OtherKeywords);case"r":return h(t.R,a.OtherKeywords);case"f":return h(t.F,a.OtherKeywords);case"+":return h(t.AddOperator,a.MathsOperators);case"-":return h(t.SubtractOperator,a.MathsOperators);case"*":return h(t.MultiplyOperator,a.MathsOperators);case"/":return h(t.DivideOperator,a.MathsOperators);case"%":return h(t.ModulusOperator,a.MathsOperators);case"**":return h(t.ExponentOperator,a.MathsOperators);case"//":return h(t.IntDivideOperator,a.MathsOperators);case"=":return h(t.AssignmentOperator,a.MathsOperators);case"+=":return h(t.IncrementOperator,a.MathsOperators);case"-=":return h(t.DecrementOperator,a.MathsOperators);case"*=":return h(t.MultiplyAssignOperator,a.MathsOperators);case"/=":return h(t.DivideAssignOperator,a.MathsOperators);case"%=":return h(t.RemainderAssignOperator,a.MathsOperators);case"//=":return h(t.IntDivideAssignOperator,a.MathsOperators);case"**=":return h(t.ExponentAssignOperator,a.MathsOperators);case"==":return h(t.EqualOperator,a.ComparisonOperators);case"!=":return h(t.NotEqualOperator,a.ComparisonOperators);case">":return h(t.GreaterThanOperator,a.ComparisonOperators);case"<":return h(t.LessThanOperator,a.ComparisonOperators);case">=":return h(t.GreaterThanOrEqualOperator,a.ComparisonOperators);case"<=":return h(t.LessThanOrEqualOperator,a.ComparisonOperators);case"->":return h(t.TypeHintReturn,a.TypeHint);case"@":return h(t.Decorator,a.SyntacticSugar);case"abs":return h(t.AbsFunction,a.BuiltInFunctions);case"all":return h(t.AllFunction,a.BuiltInFunctions);case"any":return h(t.AnyFunction,a.BuiltInFunctions);case"ascii":return h(t.AsciiFunction,a.BuiltInFunctions);case"bin":return h(t.BinFunction,a.BuiltInFunctions);case"bool":return h(t.BoolFunction,a.BuiltInFunctions);case"callable":return h(t.CallableFunction,a.BuiltInFunctions);case"chr":return h(t.ChrFunction,a.BuiltInFunctions);case"dict":return h(t.DictDefinition,a.BuiltInFunctions);case"divmod":return h(t.DivModFunction,a.BuiltInFunctions);case"enumerate":return h(t.EnumerateFunction,a.BuiltInFunctions);case"eval":return h(t.EvalFunction,a.BuiltInFunctions);case"exec":return h(t.ExecFunction,a.BuiltInFunctions);case"exit":return h(t.ExitFunction,a.BuiltInFunctions);case"filter":return h(t.FilterFunction,a.BuiltInFunctions);case"float":return h(t.FloatFunction,a.BuiltInFunctions);case"getattr":return h(t.GetAttrFunction,a.BuiltInFunctions);case"globals":return h(t.GlobalsFunction,a.BuiltInFunctions);case"hasattr":return h(t.HasAttrFunction,a.BuiltInFunctions);case"input":return h(t.InputFunction,a.BuiltInFunctions);case"int":return h(t.IntFunction,a.BuiltInFunctions);case"isinstance":return h(t.IsInstanceFunction,a.BuiltInFunctions);case"len":return h(t.LenFunction,a.BuiltInFunctions);case"list":return h(t.ListFunction,a.BuiltInFunctions);case"map":return h(t.MapFunction,a.BuiltInFunctions);case"max":return h(t.MaxFunction,a.BuiltInFunctions);case"min":return h(t.MinFunction,a.BuiltInFunctions);case"open":return h(t.OpenFunction,a.BuiltInFunctions);case"ord":return h(t.OrdFunction,a.BuiltInFunctions);case"pow":return h(t.PowFunction,a.BuiltInFunctions);case"print":return h(t.PrintFunction,a.BuiltInFunctions);case"quit":return h(t.QuitFunction,a.BuiltInFunctions);case"range":return h(t.RangeFunction,a.BuiltInFunctions);case"reversed":return h(t.ReversedFunction,a.BuiltInFunctions);case"round":return h(t.RoundFunction,a.BuiltInFunctions);case"set":return h(t.SetFunction,a.BuiltInFunctions);case"sorted":return h(t.SortedFunction,a.BuiltInFunctions);case"str":return h(t.StrFunction,a.BuiltInFunctions);case"sum":return h(t.SumFunction,a.BuiltInFunctions);case"tuple":return h(t.TupleFunction,a.BuiltInFunctions);case"type":return h(t.TypeFunction,a.BuiltInFunctions);case"zip":return h(t.ZipFunction,a.BuiltInFunctions);case"__main__":return h(t.Main,a.MagicMethods);case"__cmp__":return h(t.Cmp,a.MagicMethods);case"__eq__":return h(t.Eq,a.MagicMethods);case"__ne__":return h(t.Ne,a.MagicMethods);case"__lt__":return h(t.Lt,a.MagicMethods);case"__gt__":return h(t.Gt,a.MagicMethods);case"__le__":return h(t.Le,a.MagicMethods);case"__ge__":return h(t.Ge,a.MagicMethods);case"__str__":return h(t.Str,a.MagicMethods);case"__getattr__":return h(t.GetAttrVariable,a.MagicMethods);case"__setattr__":return h(t.SetAttrVariable,a.MagicMethods);case"__contains__":return h(t.SpecialContains,a.MagicMethods);case"__len__":return h(t.SpecialLen,a.MagicMethods);case"__name__":return h(t.Name,a.SpecialVariables);case"__self__":return h(t.Self,a.SpecialVariables);case"__doc__":return h(t.Doc,a.SpecialVariables);case"__class__":return h(t.ClassVariable,a.SpecialVariables);case"sep":return h(t.Sep,a.SpecialVariables);case"end":return h(t.End,a.SpecialVariables);case"ArtithmeticError":return h(t.ExceptionName,a.BuiltInExceptions);case"AssertionError":return h(t.ExceptionName,a.BuiltInExceptions);case"AttributeError":return h(t.ExceptionName,a.BuiltInExceptions);case"BlockingIOError":return h(t.ExceptionName,a.BuiltInExceptions);case"BrokenPipeError":return h(t.ExceptionName,a.BuiltInExceptions);case"BufferError":return h(t.ExceptionName,a.BuiltInExceptions);case"ChildProcessError":return h(t.ExceptionName,a.BuiltInExceptions);case"ConnectionAbortedError":return h(t.ExceptionName,a.BuiltInExceptions);case"ConnectionError":return h(t.ExceptionName,a.BuiltInExceptions);case"ConnectionRefusedError":return h(t.ExceptionName,a.BuiltInExceptions);case"ConnectionResetError":return h(t.ExceptionName,a.BuiltInExceptions);case"Exception":return h(t.ExceptionName,a.BuiltInExceptions);case"EOFError":return h(t.ExceptionName,a.BuiltInExceptions);case"EnvironmentError":return h(t.ExceptionName,a.BuiltInExceptions);case"FileExistsError":return h(t.ExceptionName,a.BuiltInExceptions);case"FileNotFoundError":return h(t.ExceptionName,a.BuiltInExceptions);case"FloatingPointError":return h(t.ExceptionName,a.BuiltInExceptions);case"GeneratorExit":return h(t.ExceptionName,a.BuiltInExceptions);case"ImportError":return h(t.ExceptionName,a.BuiltInExceptions);case"IndentationError":return h(t.ExceptionName,a.BuiltInExceptions);case"IndexError":return h(t.ExceptionName,a.BuiltInExceptions);case"InterruptedError":return h(t.ExceptionName,a.BuiltInExceptions);case"IOError":return h(t.ExceptionName,a.BuiltInExceptions);case"IsADirectoryError":return h(t.ExceptionName,a.BuiltInExceptions);case"KeyError":return h(t.ExceptionName,a.BuiltInExceptions);case"KeyboardInterrupt":return h(t.ExceptionName,a.BuiltInExceptions);case"LookupError":return h(t.ExceptionName,a.BuiltInExceptions);case"MemoryError":return h(t.ExceptionName,a.BuiltInExceptions);case"ModuleNotFoundError":return h(t.ExceptionName,a.BuiltInExceptions);case"NameError":return h(t.ExceptionName,a.BuiltInExceptions);case"NotADirectoryError":return h(t.ExceptionName,a.BuiltInExceptions);case"NotImplementedError":return h(t.ExceptionName,a.BuiltInExceptions);case"OSError":return h(t.ExceptionName,a.BuiltInExceptions);case"OverflowError":return h(t.ExceptionName,a.BuiltInExceptions);case"PermissionError":return h(t.ExceptionName,a.BuiltInExceptions);case"ProcessLookupError":return h(t.ExceptionName,a.BuiltInExceptions);case"RecursionError":return h(t.ExceptionName,a.BuiltInExceptions);case"ReferenceError":return h(t.ExceptionName,a.BuiltInExceptions);case"RuntimeError":return h(t.ExceptionName,a.BuiltInExceptions);case"StopIteration":return h(t.ExceptionName,a.BuiltInExceptions);case"SyntaxError":return h(t.ExceptionName,a.BuiltInExceptions);case"TabError":return h(t.ExceptionName,a.BuiltInExceptions);case"TimeoutError":return h(t.ExceptionName,a.BuiltInExceptions);case"SystemError":return h(t.ExceptionName,a.BuiltInExceptions);case"SystemExit":return h(t.ExceptionName,a.BuiltInExceptions);case"TypeError":return h(t.ExceptionName,a.BuiltInExceptions);case"UnboundLocalError":return h(t.ExceptionName,a.BuiltInExceptions);case"UnicodeError":return h(t.ExceptionName,a.BuiltInExceptions);case"UnicodeEncodeError":return h(t.ExceptionName,a.BuiltInExceptions);case"UnicodeDecodeError":return h(t.ExceptionName,a.BuiltInExceptions);case"UnicodeTranslateError":return h(t.ExceptionName,a.BuiltInExceptions);case"ValueError":return h(t.ExceptionName,a.BuiltInExceptions);case"Warning":return h(t.ExceptionName,a.BuiltInExceptions);case"ZeroDivisionError":return h(t.ExceptionName,a.BuiltInExceptions);case"capitalize":return h(t.Capitalize,a.BuiltInMethods);case"casefold":return h(t.Casefold,a.BuiltInMethods);case"center":return h(t.Center,a.BuiltInMethods);case"count":return h(t.Count,a.BuiltInMethods);case"encode":return h(t.Encode,a.BuiltInMethods);case"endswith":return h(t.EndsWith,a.BuiltInMethods);case"expandtabs":return h(t.ExpandTabs,a.BuiltInMethods);case"find":return h(t.Find,a.BuiltInMethods);case"format":return h(t.Format,a.BuiltInMethods);case"format_map":return h(t.FormatMap,a.BuiltInMethods);case"index":return h(t.Index,a.BuiltInMethods);case"isalnum":return h(t.IsAlnum,a.BuiltInMethods);case"isalpha":return h(t.IsAlpha,a.BuiltInMethods);case"isascii":return h(t.IsAscii,a.BuiltInMethods);case"isdecimal":return h(t.IsDecimal,a.BuiltInMethods);case"isdigit":return h(t.IsDigit,a.BuiltInMethods);case"isidentifier":return h(t.IsIdentifier,a.BuiltInMethods);case"islower":return h(t.IsLower,a.BuiltInMethods);case"isnumeric":return h(t.IsNumeric,a.BuiltInMethods);case"isprintable":return h(t.IsPrintable,a.BuiltInMethods);case"isspace":return h(t.IsSpace,a.BuiltInMethods);case"istitle":return h(t.IsTitle,a.BuiltInMethods);case"isupper":return h(t.IsUpper,a.BuiltInMethods);case"join":return h(t.Join,a.BuiltInMethods);case"ljust":return h(t.LJust,a.BuiltInMethods);case"lower":return h(t.Lower,a.BuiltInMethods);case"lstrip":return h(t.LStrip,a.BuiltInMethods);case"maketrans":return h(t.MakeTrans,a.BuiltInMethods);case"partition":return h(t.Partition,a.BuiltInMethods);case"replace":return h(t.Replace,a.BuiltInMethods);case"rfind":return h(t.RFind,a.BuiltInMethods);case"rindex":return h(t.RIndex,a.BuiltInMethods);case"rjust":return h(t.RJust,a.BuiltInMethods);case"rpartition":return h(t.RPartition,a.BuiltInMethods);case"rsplit":return h(t.RSplit,a.BuiltInMethods);case"rstrip":return h(t.RStrip,a.BuiltInMethods);case"split":return h(t.Split,a.BuiltInMethods);case"splitlines":return h(t.SplitLines,a.BuiltInMethods);case"startswith":return h(t.StartsWith,a.BuiltInMethods);case"strip":return h(t.Strip,a.BuiltInMethods);case"swapcase":return h(t.SwapCase,a.BuiltInMethods);case"title":return h(t.Title,a.BuiltInMethods);case"translate":return h(t.Translate,a.BuiltInMethods);case"upper":return h(t.Upper,a.BuiltInMethods);case"zfill":return h(t.ZFill,a.BuiltInMethods);case"append":return h(t.Append,a.BuiltInMethods);case"clear":return h(t.Clear,a.BuiltInMethods);case"copy":return h(t.Copy,a.BuiltInMethods);case"extend":return h(t.Extend,a.BuiltInMethods);case"insert":return h(t.Insert,a.BuiltInMethods);case"pop":return h(t.Pop,a.BuiltInMethods);case"remove":return h(t.Remove,a.BuiltInMethods);case"reverse":return h(t.Reverse,a.BuiltInMethods);case"sort":return h(t.Sort,a.BuiltInMethods);case"fromkeys":return h(t.FromKeys,a.BuiltInMethods);case"get":return h(t.Get,a.BuiltInMethods);case"items":return h(t.Items,a.BuiltInMethods);case"keys":return h(t.Keys,a.BuiltInMethods);case"popitem":return h(t.PopItem,a.BuiltInMethods);case"setdefault":return h(t.SetDefault,a.BuiltInMethods);case"update":return h(t.Update,a.BuiltInMethods);case"values":return h(t.Values,a.BuiltInMethods);case"add":return h(t.Add,a.BuiltInMethods);case"difference":return h(t.Difference,a.BuiltInMethods);case"difference_update":return h(t.DifferenceUpdate,a.BuiltInMethods);case"discard":return h(t.Discard,a.BuiltInMethods);case"intersection":return h(t.Intersection,a.BuiltInMethods);case"intersection_update":return h(t.IntersectionUpdate,a.BuiltInMethods);case"isdisjoint":return h(t.IsDisjoint,a.BuiltInMethods);case"issubset":return h(t.IsSubset,a.BuiltInMethods);case"issuperset":return h(t.IsSuperset,a.BuiltInMethods);case"symmetric_difference":return h(t.SymmetricDifference,a.BuiltInMethods);case"symmetric_difference_update":return h(t.SymmetricDifferenceUpdate,a.BuiltInMethods);case"union":return h(t.Union,a.BuiltInMethods);case"close":return h(t.Close,a.BuiltInMethods);case"detach":return h(t.Detach,a.BuiltInMethods);case"fileno":return h(t.FileNo,a.BuiltInMethods);case"flush":return h(t.Flush,a.BuiltInMethods);case"isatty":return h(t.IsAtty,a.BuiltInMethods);case"read":return h(t.Read,a.BuiltInMethods);case"readable":return h(t.Readable,a.BuiltInMethods);case"readline":return h(t.ReadLine,a.BuiltInMethods);case"readlines":return h(t.ReadLines,a.BuiltInMethods);case"seek":return h(t.Seek,a.BuiltInMethods);case"seekable":return h(t.Seekable,a.BuiltInMethods);case"tell":return h(t.Tell,a.BuiltInMethods);case"truncate":return h(t.Truncate,a.BuiltInMethods);case"writable":return h(t.Writable,a.BuiltInMethods);case"write":return h(t.Write,a.BuiltInMethods);case"writelines":return h(t.WriteLines,a.BuiltInMethods);case"(":return h(t.OpenParenthesis,a.Other);case")":return h(t.CloseParenthesis,a.Other);case"[":return h(t.OpenSquareBracket,a.Other);case"]":return h(t.CloseSquareBracket,a.Other);case"{":return h(t.OpenBrace,a.Other);case"}":return h(t.CloseBrace,a.Other);case",":return h(t.Comma,a.Other);case":":return h(t.Colon,a.Other);case".":return h(t.Dot,a.Other);case"\\":return h(t.ContinuationLine,a.Other);case";":return h(t.Separator,a.Other);case"'":return h(t.SingleQuote,a.Other);case'"':return h(t.DoubleQuote,a.Other);case"random":return h(t.RandomModule,a.BuiltInModules);case"math":return h(t.MathModule,a.BuiltInModules);case"string":return h(t.StringModule,a.BuiltInModules);case"re":return h(t.ReModule,a.BuiltInModules);case"sys":return h(t.Sys,a.BuiltInModules);case"seed":return h(t.Seed,a.ModuleFunctions);case"getstate":return h(t.GetState,a.ModuleFunctions);case"setstate":return h(t.SetState,a.ModuleFunctions);case"getrandbits":return h(t.GetRandBits,a.ModuleFunctions);case"randrange":return h(t.RandRange,a.ModuleFunctions);case"randint":return h(t.RandInt,a.ModuleFunctions);case"choice":return h(t.Choice,a.ModuleFunctions);case"choices":return h(t.Choices,a.ModuleFunctions);case"shuffle":return h(t.Shuffle,a.ModuleFunctions);case"sample":return h(t.Sample,a.ModuleFunctions);case"uniform":return h(t.Uniform,a.ModuleFunctions);case"triangular":return h(t.Triangular,a.ModuleFunctions);case"betavariate":return h(t.BetaVariate,a.ModuleFunctions);case"expovariate":return h(t.ExpoVariate,a.ModuleFunctions);case"gammavariate":return h(t.GammaVariate,a.ModuleFunctions);case"gauss":return h(t.Gauss,a.ModuleFunctions);case"lognormvariate":return h(t.LogNormVariate,a.ModuleFunctions);case"normalvariate":return h(t.NormalVariate,a.ModuleFunctions);case"vonmisesvariate":return h(t.VonMisesVariate,a.ModuleFunctions);case"paretovariate":return h(t.ParetoVariate,a.ModuleFunctions);case"weibullvariate":return h(t.WeibullVariate,a.ModuleFunctions);case"acos":return h(t.Acos,a.ModuleFunctions);case"acosh":return h(t.Acosh,a.ModuleFunctions);case"asin":return h(t.Asin,a.ModuleFunctions);case"asinh":return h(t.Asinh,a.ModuleFunctions);case"atan":return h(t.Atan,a.ModuleFunctions);case"atan2":return h(t.Atan2,a.ModuleFunctions);case"atanh":return h(t.Atanh,a.ModuleFunctions);case"ceil":return h(t.Ceil,a.ModuleFunctions);case"comb":return h(t.Comb,a.ModuleFunctions);case"copysign":return h(t.Copysign,a.ModuleFunctions);case"cos":return h(t.Cos,a.ModuleFunctions);case"cosh":return h(t.Cosh,a.ModuleFunctions);case"degrees":return h(t.Degrees,a.ModuleFunctions);case"dist":return h(t.Dist,a.ModuleFunctions);case"erf":return h(t.Erf,a.ModuleFunctions);case"erfc":return h(t.Erfc,a.ModuleFunctions);case"exp":return h(t.Exp,a.ModuleFunctions);case"expm1":return h(t.Expm1,a.ModuleFunctions);case"fabs":return h(t.Fabs,a.ModuleFunctions);case"factorial":return h(t.Factorial,a.ModuleFunctions);case"floor":return h(t.Floor,a.ModuleFunctions);case"fmod":return h(t.Fmod,a.ModuleFunctions);case"frexp":return h(t.Frexp,a.ModuleFunctions);case"fsum":return h(t.Fsum,a.ModuleFunctions);case"gamma":return h(t.Gamma,a.ModuleFunctions);case"gcd":return h(t.Gcd,a.ModuleFunctions);case"hypot":return h(t.Hypot,a.ModuleFunctions);case"isclose":return h(t.IsClose,a.ModuleFunctions);case"isfinite":return h(t.IsFinite,a.ModuleFunctions);case"isinf":return h(t.IsInf,a.ModuleFunctions);case"isnan":return h(t.IsNaN,a.ModuleFunctions);case"isqrt":return h(t.ISqrt,a.ModuleFunctions);case"ldexp":return h(t.Ldexp,a.ModuleFunctions);case"lgamma":return h(t.LGamma,a.ModuleFunctions);case"log":return h(t.Log,a.ModuleFunctions);case"log10":return h(t.Log10,a.ModuleFunctions);case"log1p":return h(t.Log1P,a.ModuleFunctions);case"log2":return h(t.Log2,a.ModuleFunctions);case"perm":return h(t.Perm,a.ModuleFunctions);case"pow":return h(t.Pow,a.ModuleFunctions);case"prod":return h(t.Prod,a.ModuleFunctions);case"radians":return h(t.Radians,a.ModuleFunctions);case"remainder":return h(t.Remainder,a.ModuleFunctions);case"sin":return h(t.Sin,a.ModuleFunctions);case"sinh":return h(t.Sinh,a.ModuleFunctions);case"sqrt":return h(t.Sqrt,a.ModuleFunctions);case"tan":return h(t.Tan,a.ModuleFunctions);case"tanh":return h(t.Tanh,a.ModuleFunctions);case"trun":return h(t.Trunc,a.ModuleFunctions);case"e":return h(t.E,a.ModuleProperties);case"inf":return h(t.Inf,a.ModuleProperties);case"nan":return h(t.Nan,a.ModuleProperties);case"pi":return h(t.Pi,a.ModuleProperties);case"tau":return h(t.Tau,a.ModuleProperties);case"ascii_letters":return h(t.AsciiLetters,a.ModuleProperties);case"ascii_lowercase":return h(t.AsciiLowercase,a.ModuleProperties);case"ascii_uppercase":return h(t.AsciiUppercase,a.ModuleProperties);case"digits":return h(t.Digits,a.ModuleProperties);case"hexdigits":return h(t.Hexdigits,a.ModuleProperties);case"octdigits":return h(t.Octdigits,a.ModuleProperties);case"punctuation":return h(t.Punctuation,a.ModuleProperties);case"printable":return h(t.Printable,a.ModuleProperties);case"whitespace":return h(t.Whitespace,a.ModuleProperties);case"Formatter":return h(t.Formatter,a.ModuleFunctions);case"Template":return h(t.Template,a.ModuleFunctions);case"capwords":return h(t.Capwords,a.ModuleFunctions);case"Pattern":return h(t.Pattern,a.Types);case"Match":return h(t.Match,a.Types);case"A":return h(t.ReA,a.ModuleProperties);case"ASCII":return h(t.ReASCII,a.ModuleProperties);case"DEBUG":return h(t.ReDebug,a.ModuleProperties);case"I":return h(t.ReI,a.ModuleProperties);case"IGNORECASE":return h(t.ReIGNORECASE,a.ModuleProperties);case"L":return h(t.ReL,a.ModuleProperties);case"LOCALE":return h(t.ReLOCALE,a.ModuleProperties);case"M":return h(t.ReM,a.ModuleProperties);case"MULTILINE":return h(t.ReMULTILINE,a.ModuleProperties);case"S":return h(t.ReS,a.ModuleProperties);case"DOTALL":return h(t.ReDOTALL,a.ModuleProperties);case"X":return h(t.ReX,a.ModuleProperties);case"VERBOSE":return h(t.ReVERBOSE,a.ModuleProperties);case"compile":return h(t.Compile,a.ModuleFunctions);case"search":return h(t.Search,a.ModuleFunctions);case"match":return h(t.Match,a.ModuleFunctions);case"fullmatch":return h(t.FullMatch,a.ModuleFunctions);case"findall":return h(t.FindAll,a.ModuleFunctions);case"finditer":return h(t.FindIter,a.ModuleFunctions);case"sub":return h(t.Sub,a.ModuleFunctions);case"subn":return h(t.SubN,a.ModuleFunctions);case"escape":return h(t.Escape,a.ModuleFunctions);case"purge":return h(t.Purge,a.ModuleFunctions);case"addaudithook":return h(t.AddAuditHook,a.ModuleFunctions);case"audit":return h(t.Audit,a.ModuleFunctions);case"call_tracing":return h(t.CallTracing,a.ModuleFunctions);case"_clear_type_cache":return h(t.ClearTypeCache,a.ModuleFunctions);case"_current_frames":return h(t.CurrentFrames,a.ModuleFunctions);case"_current_exceptions":return h(t.CurrentExceptions,a.ModuleFunctions);case"breakpointhook":return h(t.BreakpointHook,a.ModuleFunctions);case"_debugmallocstats":return h(t.DebugMallocStats,a.ModuleFunctions);case"displayhook":return h(t.DisplayHook,a.ModuleFunctions);case"excepthook":return h(t.ExceptHook,a.ModuleFunctions);case"exc_info":return h(t.ExcInfo,a.ModuleFunctions);case"getallocatedblocks":return h(t.GetAllocatedBlocks,a.ModuleFunctions);case"getandroidapilevel":return h(t.GetAndroidApiLevel,a.ModuleFunctions);case"getdefaultencoding":return h(t.GetDefaultEncoding,a.ModuleFunctions);case"getdlopenflags":return h(t.GetDLOpenFlags,a.ModuleFunctions);case"getfilesystemencoding":return h(t.GetFileSystemEncoding,a.ModuleFunctions);case"getfilesystemencodeerrors":return h(t.GetFileSystemEncodeErrors,a.ModuleFunctions);case"getrefcount":return h(t.GetRefCount,a.ModuleFunctions);case"getrecursionlimit":return h(t.GetRecursionLimit,a.ModuleFunctions);case"getsizeof":return h(t.GetSizeOf,a.ModuleFunctions);case"getswitchinterval":return h(t.GetSwitchInterval,a.ModuleFunctions);case"_getframe":return h(t.GetFrame,a.ModuleFunctions);case"getprofile":return h(t.GetProfile,a.ModuleFunctions);case"gettrace":return h(t.GetTrace,a.ModuleFunctions);case"getwindowsversion":return h(t.GetWindowsVersion,a.ModuleFunctions);case"get_asyncgen_hooks":return h(t.GetAsyncGenHooks,a.ModuleFunctions);case"get_coroutine_origin_tracking_depth":return h(t.GetCoroutineOriginTrackingDepth,a.ModuleFunctions);case"intern":return h(t.Intern,a.ModuleFunctions);case"is_finalizing":return h(t.IsFinalizing,a.ModuleFunctions);case"setdlopenflags":return h(t.SetDLOpenFlags,a.ModuleFunctions);case"setprofile":return h(t.SetProfile,a.ModuleFunctions);case"setrecursionlimit":return h(t.SetRecursionLimit,a.ModuleFunctions);case"setswitchinterval":return h(t.SetSwitchInterval,a.ModuleFunctions);case"settrace":return h(t.SetTrace,a.ModuleFunctions);case"set_asyncgen_hooks":return h(t.SetAsyncgenHooks,a.ModuleFunctions);case"_enablelegacywindowsfsencoding":return h(t.EnableLegacyWindowsFSEncoding,a.ModuleFunctions);case"abiflags":return h(t.ABIFlags,a.ModuleProperties);case"argv":return h(t.Argv,a.ModuleProperties);case"base_exec_prefix":return h(t.BaseExecPrefix,a.ModuleProperties);case"base_prefix":return h(t.BasePrefix,a.ModuleProperties);case"byte_order":return h(t.ByteOrder,a.ModuleProperties);case"built_in_module_names":return h(t.BuiltInModuleNames,a.ModuleProperties);case"copyright":return h(t.Copyright,a.ModuleProperties);case"dllhandle":return h(t.DllHandle,a.ModuleProperties);case"dont_write_bytecode":return h(t.DontWriteBytecode,a.ModuleProperties);case"pycache_prefix":return h(t.PycachePrefix,a.ModuleProperties);case"exec_prefix":return h(t.ExecPrefix,a.ModuleProperties);case"executable":return h(t.Executable,a.ModuleProperties);case"flags":return h(t.Flags,a.ModuleProperties);case"float_info":return h(t.FloatInfo,a.ModuleProperties);case"float_repr_style":return h(t.FloatReprStyle,a.ModuleProperties);case"hash_info":return h(t.HashInfo,a.ModuleProperties);case"hexversion":return h(t.HexVersion,a.ModuleProperties);case"implementation":return h(t.Implementation,a.ModuleProperties);case"int_info":return h(t.IntInfo,a.ModuleProperties);case"last_type":return h(t.LastType,a.ModuleProperties);case"last_value":return h(t.LastValue,a.ModuleProperties);case"last_traceback":return h(t.LastTraceback,a.ModuleProperties);case"maxsize":return h(t.MaxSize,a.ModuleProperties);case"maxunicode":return h(t.MaxUnicode,a.ModuleProperties);case"meta_path":return h(t.MetaPath,a.ModuleProperties);case"modules":return h(t.Modules,a.ModuleProperties);case"orig_argv":return h(t.OrigArgv,a.ModuleProperties);case"path":return h(t.Path,a.ModuleProperties);case"path_hooks":return h(t.PathHooks,a.ModuleProperties);case"path_importer_cache":return h(t.PathImporterCache,a.ModuleProperties);case"platform":return h(t.Platform,a.ModuleProperties);case"prefix":return h(t.Prefix,a.ModuleProperties);case"ps1":return h(t.PS1,a.ModuleProperties);case"ps2":return h(t.PS2,a.ModuleProperties);case"stdin":return h(t.StdIn,a.ModuleProperties);case"stdout":return h(t.StdOut,a.ModuleProperties);case"stderr":return h(t.StdErr,a.ModuleProperties);case"stdlib_module_names":return h(t.StdLibModuleNames,a.ModuleProperties);case"thread_info":return h(t.ThreadInfo,a.ModuleProperties);case"tracebacklimit":return h(t.TracebackLimit,a.ModuleProperties);case"version":return h(t.Version,a.ModuleProperties);case"api_version":return h(t.ApiVersion,a.ModuleProperties);case"version_info":return h(t.VersionInfo,a.ModuleProperties);case"warnoptions":return h(t.WarnOptions,a.ModuleProperties);case"winver":return h(t.WinVer,a.ModuleProperties);case"_xoptions":return h(t.XOptions,a.ModuleProperties);default:return h(t.Unknown,a.Unknown)}},Ir=g=>{switch(g){case"str":return h(t.StrType,a.Types);case"int":return h(t.IntType,a.Types);case"float":return h(t.FloatType,a.Types);case"bool":return h(t.BoolType,a.Types);case"list":return h(t.ListType,a.Types);case"set":return h(t.SetType,a.Types);case"dict":return h(t.DictType,a.Types);case"tuple":return h(t.TupleType,a.Types);default:return h(t.Unknown,a.Unknown)}},Mt=new Map([[t.AbsFunction,d.Number],[t.AllFunction,d.Bool],[t.AnyFunction,d.Bool],[t.AsciiFunction,d.String],[t.AssertFunction,d.None],[t.BinFunction,d.String],[t.BoolFunction,d.Bool],[t.CallableFunction,d.Bool],[t.ChrFunction,d.String],[t.DictFunction,d.Dict],[t.DivModFunction,d.Tuple],[t.EnumerateFunction,d.Tuple],[t.EvalFunction,d.Unknown],[t.ExecFunction,d.None],[t.ExitFunction,d.None],[t.FilterFunction,d.Unknown],[t.FloatFunction,d.Float],[t.GetAttrFunction,d.Unknown],[t.GlobalsFunction,d.Dict],[t.HasAttrFunction,d.Bool],[t.InputFunction,d.String],[t.IntFunction,d.Int],[t.IsInstanceFunction,d.Bool],[t.LenFunction,d.Int],[t.ListFunction,d.List],[t.MapFunction,d.Unknown],[t.MaxFunction,d.Number],[t.MinFunction,d.Number],[t.OpenFunction,d.File],[t.OrdFunction,d.Int],[t.PowFunction,d.Number],[t.PrintFunction,d.None],[t.QuitFunction,d.None],[t.RangeFunction,d.Unknown],[t.ReversedFunction,d.Unknown],[t.RoundFunction,d.Float],[t.SetFunction,d.Set],[t.SortedFunction,d.List],[t.StrFunction,d.String],[t.SumFunction,d.Number],[t.TupleFunction,d.Tuple],[t.TypeFunction,d.Class],[t.Capitalize,d.String],[t.Casefold,d.String],[t.Center,d.String],[t.Count,d.Int],[t.Encode,d.String],[t.EndsWith,d.Bool],[t.ExpandTabs,d.String],[t.Find,d.Int],[t.Format,d.String],[t.FormatFunction,d.String],[t.Index,d.Int],[t.IsAlnum,d.Bool],[t.IsAlpha,d.Bool],[t.IsAscii,d.Bool],[t.IsDecimal,d.Bool],[t.IsDigit,d.Bool],[t.IsIdentifier,d.Bool],[t.IsLower,d.Bool],[t.IsNumeric,d.Bool],[t.IsPrintable,d.Bool],[t.IsSpace,d.Bool],[t.IsTitle,d.Bool],[t.IsUpper,d.Bool],[t.Join,d.String],[t.LJust,d.String],[t.Lower,d.String],[t.LStrip,d.String],[t.MakeTrans,d.Dict],[t.Partition,d.Tuple],[t.Replace,d.String],[t.RFind,d.Int],[t.RIndex,d.Int],[t.RJust,d.String],[t.RPartition,d.Tuple],[t.RSplit,d.List],[t.RStrip,d.String],[t.Split,d.List],[t.SplitLines,d.List],[t.StartsWith,d.Bool],[t.Strip,d.String],[t.SwapCase,d.String],[t.Title,d.String],[t.Translate,d.String],[t.Upper,d.String],[t.ZFill,d.String],[t.Append,d.None],[t.Clear,d.None],[t.Copy,d.Unknown],[t.Extend,d.None],[t.Insert,d.None],[t.Pop,d.Unknown],[t.Remove,d.None],[t.Reverse,d.None],[t.Sort,d.None],[t.FromKeys,d.Dict],[t.Get,d.Unknown],[t.Items,d.List],[t.Keys,d.Unknown],[t.PopItem,d.None],[t.SetDefault,d.Unknown],[t.Update,d.None],[t.Values,d.Unknown],[t.Add,d.None],[t.Difference,d.Set],[t.DifferenceUpdate,d.None],[t.Discard,d.None],[t.Intersection,d.Set],[t.IntersectionUpdate,d.None],[t.IsDisjoint,d.Bool],[t.IsSubset,d.Bool],[t.IsSuperset,d.Bool],[t.SymmetricDifference,d.Set],[t.SymmetricDifferenceUpdate,d.None],[t.Union,d.Set],[t.Close,d.None],[t.FileNo,d.Int],[t.Flush,d.None],[t.IsAtty,d.Bool],[t.Read,d.String],[t.Readable,d.Bool],[t.ReadLine,d.String],[t.ReadLines,d.List],[t.Seek,d.None],[t.Seekable,d.Bool],[t.Tell,d.Unknown],[t.Truncate,d.None],[t.Writable,d.Bool],[t.Write,d.None],[t.WriteLines,d.None],[t.Main,d.None],[t.Cmp,d.Int],[t.Eq,d.Bool],[t.Ne,d.Bool],[t.Lt,d.Bool],[t.Gt,d.Bool],[t.Le,d.Bool],[t.Ge,d.Bool],[t.Str,d.String],[t.SpecialContains,d.Bool],[t.SpecialLen,d.Int],[t.ZipFunction,d.Unknown],[t.Seed,d.None],[t.GetState,d.Unknown],[t.SetState,d.None],[t.GetRandBits,d.Int],[t.RandRange,d.Int],[t.RandInt,d.Int],[t.Choice,d.Unknown],[t.Choices,d.List],[t.Shuffle,d.Shuffle],[t.Sample,d.List],[t.RandomMethod,d.Float],[t.Uniform,d.Float],[t.Triangular,d.Float],[t.BetaVariate,d.Float],[t.ExpoVariate,d.Float],[t.GammaVariate,d.Float],[t.Gauss,d.Float],[t.LogNormVariate,d.Float],[t.NormalVariate,d.Float],[t.VonMisesVariate,d.Float],[t.ParetoVariate,d.Float],[t.WeibullVariate,d.Float],[t.Acos,d.Float],[t.Acosh,d.Float],[t.Asin,d.Float],[t.Asinh,d.Float],[t.Atan,d.Float],[t.Atan2,d.Float],[t.Atanh,d.Float],[t.Ceil,d.Int],[t.Comb,d.Int],[t.CopySign,d.Float],[t.Cos,d.Float],[t.Cosh,d.Float],[t.Degrees,d.Float],[t.Dist,d.Float],[t.Erf,d.Float],[t.Erfc,d.Float],[t.Exp,d.Float],[t.Expm1,d.Float],[t.Fabs,d.Float],[t.Factorial,d.Int],[t.Floor,d.Int],[t.Fmod,d.Float],[t.Frexp,d.Tuple],[t.Fsum,d.Float],[t.Gamma,d.Float],[t.Gcd,d.Int],[t.Hypot,d.Float],[t.IsClose,d.Bool],[t.IsFinite,d.Bool],[t.IsInf,d.Bool],[t.IsNaN,d.Bool],[t.ISqrt,d.Int],[t.Ldexp,d.Float],[t.LGamma,d.Float],[t.Log,d.Float],[t.Log10,d.Float],[t.Log1P,d.Float],[t.Log2,d.Float],[t.Perm,d.Int],[t.Pow,d.Float],[t.Prod,d.Float],[t.Radians,d.Float],[t.Remainder,d.Float],[t.Sin,d.Float],[t.Sinh,d.Float],[t.Sqrt,d.Float],[t.Tan,d.Float],[t.Tanh,d.Float],[t.Trunc,d.Int],[t.E,d.Float],[t.Inf,d.Float],[t.Nan,d.Float],[t.Pi,d.Float],[t.Tau,d.Float],[t.AsciiLetters,d.String],[t.AsciiLowercase,d.String],[t.AsciiUppercase,d.String],[t.Digits,d.String],[t.Hexdigits,d.String],[t.Octdigits,d.String],[t.Punctuation,d.String],[t.Printable,d.String],[t.Whitespace,d.String],[t.Formatter,d.String],[t.Template,d.String],[t.Capwords,d.String],[t.ReA,d.Unknown],[t.ReASCII,d.Unknown],[t.ReDebug,d.Unknown],[t.ReI,d.Unknown],[t.ReIGNORECASE,d.Unknown],[t.ReL,d.Unknown],[t.ReLOCALE,d.Unknown],[t.ReM,d.Unknown],[t.ReMULTILINE,d.Unknown],[t.ReS,d.Unknown],[t.ReDOTALL,d.Unknown],[t.ReX,d.Unknown],[t.ReVERBOSE,d.Unknown],[t.Compile,d.Pattern],[t.Search,d.Unknown],[t.Match,d.Unknown],[t.FullMatch,d.Unknown],[t.FindAll,d.List],[t.FindIter,d.Unknown],[t.Sub,d.String],[t.SubN,d.Tuple],[t.Escape,d.String],[t.Purge,d.None],[t.AddAuditHook,d.None],[t.Audit,d.None],[t.CallTracing,d.Unknown],[t.ClearTypeCache,d.None],[t.CurrentFrames,d.Dict],[t.CurrentExceptions,d.Dict],[t.BreakpointHook,d.None],[t.DebugMallocStats,d.None],[t.DisplayHook,d.None],[t.ExceptHook,d.None],[t.ExcInfo,d.Tuple],[t.SysExit,d.None],[t.GetAllocatedBlocks,d.Int],[t.GetAndroidApiLevel,d.Int],[t.GetDefaultEncoding,d.String],[t.GetDLOpenFlags,d.Int],[t.GetFileSystemEncoding,d.String],[t.GetFileSystemEncodeErrors,d.String],[t.GetRefCount,d.Int],[t.GetRecursionLimit,d.Int],[t.GetSizeOf,d.Int],[t.GetSwitchInterval,d.Float],[t.GetFrame,d.Unknown],[t.GetProfile,d.None],[t.GetTrace,d.None],[t.GetWindowsVersion,d.Tuple],[t.GetAsyncGenHooks,d.Unknown],[t.GetCoroutineOriginTrackingDepth,d.Int],[t.Intern,d.Unknown],[t.IsFinalizing,d.Bool],[t.SetDLOpenFlags,d.None],[t.SetProfile,d.Unknown],[t.SetRecursionLimit,d.None],[t.SetSwitchInterval,d.None],[t.SetTrace,d.None],[t.SetAsyncgenHooks,d.None],[t.EnableLegacyWindowsFSEncoding,d.None],[t.ABIFlags,d.String],[t.Argv,d.List],[t.BaseExecPrefix,d.String],[t.BasePrefix,d.String],[t.ByteOrder,d.String],[t.BuiltInModuleNames,d.Tuple],[t.Copyright,d.String],[t.DllHandle,d.Int],[t.DontWriteBytecode,d.Bool],[t.PycachePrefix,d.Unknown],[t.ExecPrefix,d.String],[t.Executable,d.String],[t.Flags,d.Unknown],[t.FloatInfo,d.Unknown],[t.FloatReprStyle,d.String],[t.HashInfo,d.Unknown],[t.HexVersion,d.Int],[t.Implementation,d.Unknown],[t.IntInfo,d.Unknown],[t.LastType,d.Unknown],[t.LastValue,d.Unknown],[t.LastTraceback,d.Unknown],[t.MaxSize,d.Int],[t.MaxUnicode,d.Int],[t.MetaPath,d.List],[t.Modules,d.Dict],[t.OrigArgv,d.List],[t.Path,d.List],[t.PathHooks,d.List],[t.PathImporterCache,d.Dict],[t.Platform,d.String],[t.Prefix,d.String],[t.PS1,d.String],[t.PS2,d.String],[t.StdIn,d.Unknown],[t.StdOut,d.Unknown],[t.StdErr,d.Unknown],[t.StdLibModuleNames,d.Unknown],[t.ThreadInfo,d.Unknown],[t.TracebackLimit,d.Unknown],[t.Version,d.String],[t.ApiVersion,d.Int],[t.VersionInfo,d.Tuple],[t.WarnOptions,d.List],[t.WinVer,d.Int],[t.XOptions,d.Dict]]),wc=new Set([t.Add,t.Append,t.Clear,t.DifferenceUpdate,t.Discard,t.Extend,t.Insert,t.IntersectionUpdate,t.Pop,t.PopItem,t.Remove,t.Reverse,t.SetDefault,t.Sort,t.SymmetricDifferenceUpdate,t.Update]),br=new Set([t.Capitalize,t.Casefold,t.Center,t.Encode,t.ExpandTabs,t.Format,t.FormatMap,t.LJust,t.Lower,t.LStrip,t.Replace,t.RJust,t.RStrip,t.Strip,t.SwapCase,t.Title,t.Translate,t.Upper,t.ZFill]),yr=new Map([[t.Seed,t.RandomModule],[t.GetState,t.RandomModule],[t.SetState,t.RandomModule],[t.GetRandBits,t.RandomModule],[t.RandRange,t.RandomModule],[t.RandInt,t.RandomModule],[t.Choice,t.RandomModule],[t.Choices,t.RandomModule],[t.Shuffle,t.RandomModule],[t.Sample,t.RandomModule],[t.RandomMethod,t.RandomModule],[t.Uniform,t.RandomModule],[t.Triangular,t.RandomModule],[t.BetaVariate,t.RandomModule],[t.ExpoVariate,t.RandomModule],[t.GammaVariate,t.RandomModule],[t.Gauss,t.RandomModule],[t.LogNormVariate,t.RandomModule],[t.NormalVariate,t.RandomModule],[t.VonMisesVariate,t.RandomModule],[t.ParetoVariate,t.RandomModule],[t.WeibullVariate,t.RandomModule],[t.Acos,t.MathModule],[t.Acosh,t.MathModule],[t.Asin,t.MathModule],[t.Asinh,t.MathModule],[t.Atan,t.MathModule],[t.Atan2,t.MathModule],[t.Atanh,t.MathModule],[t.Ceil,t.MathModule],[t.Comb,t.MathModule],[t.CopySign,t.MathModule],[t.Cos,t.MathModule],[t.Cosh,t.MathModule],[t.Degrees,t.MathModule],[t.Dist,t.MathModule],[t.Erf,t.MathModule],[t.Erfc,t.MathModule],[t.Exp,t.MathModule],[t.Expm1,t.MathModule],[t.Fabs,t.MathModule],[t.Factorial,t.MathModule],[t.Floor,t.MathModule],[t.Fmod,t.MathModule],[t.Frexp,t.MathModule],[t.Fsum,t.MathModule],[t.Gamma,t.MathModule],[t.Gcd,t.MathModule],[t.Hypot,t.MathModule],[t.IsClose,t.MathModule],[t.IsFinite,t.MathModule],[t.IsInf,t.MathModule],[t.IsNaN,t.MathModule],[t.ISqrt,t.MathModule],[t.Ldexp,t.MathModule],[t.LGamma,t.MathModule],[t.Log,t.MathModule],[t.Log10,t.MathModule],[t.Log1P,t.MathModule],[t.Log2,t.MathModule],[t.Perm,t.MathModule],[t.Pow,t.MathModule],[t.Prod,t.MathModule],[t.Radians,t.MathModule],[t.Remainder,t.MathModule],[t.Sin,t.MathModule],[t.Sinh,t.MathModule],[t.Sqrt,t.MathModule],[t.Tan,t.MathModule],[t.Tanh,t.MathModule],[t.Trunc,t.MathModule],[t.E,t.MathModule],[t.Inf,t.MathModule],[t.Nan,t.MathModule],[t.Pi,t.MathModule],[t.Tau,t.MathModule],[t.AsciiLetters,t.StringModule],[t.AsciiLowercase,t.StringModule],[t.AsciiUppercase,t.StringModule],[t.Digits,t.StringModule],[t.Hexdigits,t.StringModule],[t.Octdigits,t.StringModule],[t.Punctuation,t.StringModule],[t.Printable,t.StringModule],[t.Whitespace,t.StringModule],[t.Formatter,t.StringModule],[t.Template,t.StringModule],[t.Capwords,t.StringModule],[t.Pattern,t.ReModule],[t.Match,t.ReModule],[t.ReA,t.ReModule],[t.ReASCII,t.ReModule],[t.ReDebug,t.ReModule],[t.ReI,t.ReModule],[t.ReIGNORECASE,t.ReModule],[t.ReL,t.ReModule],[t.ReLOCALE,t.ReModule],[t.ReM,t.ReModule],[t.ReMULTILINE,t.ReModule],[t.ReS,t.ReModule],[t.ReDOTALL,t.ReModule],[t.ReX,t.ReModule],[t.ReVERBOSE,t.ReModule],[t.Compile,t.ReModule],[t.Search,t.ReModule],[t.Match,t.ReModule],[t.FullMatch,t.ReModule],[t.FindAll,t.ReModule],[t.FindIter,t.ReModule],[t.Sub,t.ReModule],[t.SubN,t.ReModule],[t.Escape,t.ReModule],[t.Purge,t.ReModule],[t.Split,t.ReModule],[t.AddAuditHook,t.Sys],[t.Audit,t.Sys],[t.CallTracing,t.Sys],[t.ClearTypeCache,t.Sys],[t.CurrentFrames,t.Sys],[t.CurrentExceptions,t.Sys],[t.BreakpointHook,t.Sys],[t.DebugMallocStats,t.Sys],[t.DisplayHook,t.Sys],[t.ExceptHook,t.Sys],[t.ExcInfo,t.Sys],[t.SysExit,t.Sys],[t.GetAllocatedBlocks,t.Sys],[t.GetAndroidApiLevel,t.Sys],[t.GetDefaultEncoding,t.Sys],[t.GetDLOpenFlags,t.Sys],[t.GetFileSystemEncoding,t.Sys],[t.GetFileSystemEncodeErrors,t.Sys],[t.GetRefCount,t.Sys],[t.GetRecursionLimit,t.Sys],[t.GetSizeOf,t.Sys],[t.GetSwitchInterval,t.Sys],[t.GetFrame,t.Sys],[t.GetProfile,t.Sys],[t.GetTrace,t.Sys],[t.GetWindowsVersion,t.Sys],[t.GetAsyncGenHooks,t.Sys],[t.GetCoroutineOriginTrackingDepth,t.Sys],[t.Intern,t.Sys],[t.IsFinalizing,t.Sys],[t.SetDLOpenFlags,t.Sys],[t.SetProfile,t.Sys],[t.SetRecursionLimit,t.Sys],[t.SetSwitchInterval,t.Sys],[t.SetTrace,t.Sys],[t.SetAsyncgenHooks,t.Sys],[t.EnableLegacyWindowsFSEncoding,t.Sys],[t.ABIFlags,t.Sys],[t.Argv,t.Sys],[t.BaseExecPrefix,t.Sys],[t.BasePrefix,t.Sys],[t.ByteOrder,t.Sys],[t.BuiltInModuleNames,t.Sys],[t.Copyright,t.Sys],[t.DllHandle,t.Sys],[t.DontWriteBytecode,t.Sys],[t.PycachePrefix,t.Sys],[t.ExecPrefix,t.Sys],[t.Executable,t.Sys],[t.Flags,t.Sys],[t.FloatInfo,t.Sys],[t.FloatReprStyle,t.Sys],[t.HashInfo,t.Sys],[t.HexVersion,t.Sys],[t.Implementation,t.Sys],[t.IntInfo,t.Sys],[t.LastType,t.Sys],[t.LastValue,t.Sys],[t.LastTraceback,t.Sys],[t.MaxSize,t.Sys],[t.MaxUnicode,t.Sys],[t.MetaPath,t.Sys],[t.Modules,t.Sys],[t.OrigArgv,t.Sys],[t.Path,t.Sys],[t.PathHooks,t.Sys],[t.PathImporterCache,t.Sys],[t.Platform,t.Sys],[t.Prefix,t.Sys],[t.PS1,t.Sys],[t.PS2,t.Sys],[t.StdIn,t.Sys],[t.StdOut,t.Sys],[t.StdErr,t.Sys],[t.StdLibModuleNames,t.Sys],[t.ThreadInfo,t.Sys],[t.TracebackLimit,t.Sys],[t.Version,t.Sys],[t.ApiVersion,t.Sys],[t.VersionInfo,t.Sys],[t.WarnOptions,t.Sys],[t.WinVer,t.Sys],[t.XOptions,t.Sys]]),ui={assert:{entity:t.AssertFunction,category:a.BuiltInFunctions},random:{entity:t.RandomMethod,category:a.BuiltInMethods},exit:{entity:t.SysExit,category:a.ModuleFunctions}},Gn=new Map([[d.String,new Set([t.Capitalize,t.Casefold,t.Center,t.Count,t.Encode,t.ExpandTabs,t.Find,t.Format,t.Index,t.IsAlnum,t.IsAlpha,t.IsAscii,t.IsDecimal,t.IsDigit,t.IsIdentifier,t.IsLower,t.IsNumeric,t.IsPrintable,t.IsSpace,t.IsTitle,t.IsUpper,t.Join,t.LJust,t.Lower,t.LStrip,t.MakeTrans,t.Partition,t.Replace,t.RFind,t.RIndex,t.RJust,t.RPartition,t.RSplit,t.RStrip,t.Split,t.SplitLines,t.StartsWith,t.Strip,t.SwapCase,t.Title,t.Translate,t.Upper,t.ZFill])],[d.List,new Set([t.Append,t.Clear,t.Copy,t.Count,t.Extend,t.Index,t.Insert,t.Pop,t.Remove,t.Reverse,t.Sort,a.MagicMethods])],[d.Tuple,new Set([t.Count,t.Index])],[d.Set,new Set([t.Add,t.Clear,t.Copy,t.Difference,t.DifferenceUpdate,t.Discard,t.Intersection,t.IntersectionUpdate,t.IsDisjoint,t.IsSubset,t.IsSuperset,t.Pop,t.Remove,t.SymmetricDifference,t.SymmetricDifferenceUpdate,t.Union,t.Update])],[d.Dict,new Set([t.Clear,t.Copy,t.FromKeys,t.Get,t.Items,t.Keys,t.Pop,t.PopItem,t.SetDefault,t.Update,t.Values])],[d.File,new Set([t.Close,t.FileNo,t.Flush,t.IsAtty,t.Read,t.Readable,t.ReadLine,t.ReadLines,t.Seek,t.Seekable,t.Tell,t.Truncate,t.Writable,t.Write,t.WriteLines])],[d.Random,new Set([t.Seed,t.GetState,t.SetState,t.GetRandBits,t.RandRange,t.RandInt,t.Choice,t.Choices,t.Shuffle,t.Sample,t.RandomMethod,t.Uniform,t.Triangular,t.BetaVariate,t.ExpoVariate,t.GammaVariate,t.Gauss,t.LogNormVariate,t.NormalVariate,t.VonMisesVariate,t.ParetoVariate,t.WeibullVariate,a.MagicMethods])],[d.Math,new Set([t.Acos,t.Acosh,t.Asin,t.Asinh,t.Atan,t.Atan2,t.Atanh,t.Ceil,t.Comb,t.CopySign,t.Cos,t.Cosh,t.Degrees,t.Dist,t.Erf,t.Erfc,t.Exp,t.Expm1,t.Fabs,t.Factorial,t.Floor,t.Fmod,t.Frexp,t.Fsum,t.Gamma,t.Gcd,t.Hypot,t.IsClose,t.IsFinite,t.IsInf,t.IsNaN,t.ISqrt,t.Ldexp,t.LGamma,t.Log,t.Log10,t.Log1P,t.Log2,t.Perm,t.Pow,t.Prod,t.Radians,t.Remainder,t.Sin,t.Sinh,t.Sqrt,t.Tan,t.Tanh,t.Trunc])],[d.StringModule,new Set([t.Formatter,t.Template,t.Capwords])],[d.Re,new Set([t.Compile,t.Search,t.Match,t.FullMatch,t.FindAll,t.FindIter,t.Sub,t.SubN,t.Escape,t.Purge,t.Split])],[d.Sys,new Set([t.AddAuditHook,t.Audit,t.CallTracing,t.ClearTypeCache,t.CurrentFrames,t.CurrentExceptions,t.BreakpointHook,t.DebugMallocStats,t.DisplayHook,t.ExceptHook,t.ExcInfo,t.SysExit,t.GetAllocatedBlocks,t.GetAndroidApiLevel,t.GetDefaultEncoding,t.GetDLOpenFlags,t.GetFileSystemEncoding,t.GetFileSystemEncodeErrors,t.GetRefCount,t.GetRecursionLimit,t.GetSizeOf,t.GetSwitchInterval,t.GetFrame,t.GetProfile,t.GetTrace,t.GetWindowsVersion,t.GetAsyncGenHooks,t.GetCoroutineOriginTrackingDepth,t.Intern,t.IsFinalizing,t.SetDLOpenFlags,t.SetProfile,t.SetRecursionLimit,t.SetSwitchInterval,t.SetTrace,t.SetAsyncgenHooks,t.EnableLegacyWindowsFSEncoding])]]);class z{constructor(i,e,n,s,o,c="",f={}){I(this,Dt);I(this,xt);I(this,Bt);I(this,At);I(this,kt);I(this,en);I(this,tn);y(this,Dt,i),y(this,xt,e),y(this,tn,n),y(this,Bt,s),y(this,At,o),y(this,kt,c),y(this,en,f)}getID(){return u(this,Dt)}getLineNumber(){return u(this,xt)}getBlock(){return u(this,tn)}getDocIndex(){return u(this,Bt)}getLineIndex(){return u(this,At)}getAffectedText(){return u(this,kt)}getAdditionalInfo(){return u(this,en)}toString(){return`{line: ${u(this,xt)}, type: ${u(this,Dt)}, text: ${u(this,kt)}, docIndex: ${u(this,Bt)}, lineIndex: ${u(this,At)}, additionalInfo: ${u(this,en)}`}toJSON(){return{line:u(this,xt),type:u(this,Dt),text:u(this,kt),block:u(this,tn),docIndex:u(this,Bt),lineIndex:u(this,At)}}}Dt=new WeakMap,xt=new WeakMap,Bt=new WeakMap,At=new WeakMap,kt=new WeakMap,en=new WeakMap,tn=new WeakMap;class Sc extends z{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("parentText")&&(i.parentText=e.parentText),i}}class Ic extends z{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();if(e.hasOwnProperty("expression")){let n=e.expression.getCategory().name;e.expression.getEntity()===t.VariableName?n=ec:e.expression.is(t.UserDefinedFunctionCall)?n=zt:e.expression.is(t.BuiltInFunctionCall)&&(n=Qt),i.expressionNoValue={type:n,value:e.expression.getTextValue()}}return e.hasOwnProperty("usage")&&(i.usage=e.usage),e.hasOwnProperty("target")&&(i.target=e.target),i}}class bc extends z{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("assignedVariables")&&(i.assignedVariables=e.assignedVariables),i}}class yc extends z{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("boolValue")&&(i.boolValue=e.boolValue),e.hasOwnProperty("operator")&&(i.operator=e.operator),e.hasOwnProperty("boolLiteral")&&(i.boolLiteral=e.boolLiteral),e.hasOwnProperty("usedIn")&&(i.usedIn=e.usedIn),i}}class Fc extends z{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("definitionType")&&(i.boolValue=e.definitionType),e.hasOwnProperty("reservedWord")&&(i.reservedWord=e.reservedWord),i}}class Tc extends z{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("definitionText")&&(i.definitionText=e.definitionText),e.hasOwnProperty("loopVarTypeAtDefinition")&&(i.loopVarTypeAtDefinition=e.loopVarTypeAtDefinition),e.hasOwnProperty("modificationText")&&(i.modificationText=e.modificationText),i}}class Nc extends z{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("printLines")&&(i.printLines=e.printLines),e.hasOwnProperty("functionReturns")&&(i.functionReturns=e.functionReturns),i}}class Cc extends z{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("loopType")&&(i.loopType=e.loopType),e.hasOwnProperty("exitLevel")&&(i.exitLevel=e.exitLevel),e.hasOwnProperty("exitTypes")&&(i.exitTypes=e.exitTypes),i}}class Mc extends z{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("modifiedIn")&&(i.modifiedIn=e.modifiedIn),i}}class Oc extends z{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("unmodifiedVars")&&(i.unmodifiedVars=e.unmodifiedVars),e.hasOwnProperty("loopText")&&(i.loopText=e.loopText),i}}class Dc extends z{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("form")&&(i.form=e.form),e.hasOwnProperty("leftSideType")&&(i.leftSideType=e.leftSideType.name),e.hasOwnProperty("leftSideText")&&(i.leftSideText=e.leftSideText),e.hasOwnProperty("leftSideEntity")&&(i.leftSideEntity=e.leftSideEntity.name),e.hasOwnProperty("operator")&&(i.operator=e.operator),e.hasOwnProperty("rightSideType")&&(i.rightSideType=e.rightSideType.name),e.hasOwnProperty("rightSideText")&&(i.rightSideText=e.rightSideText),e.hasOwnProperty("rightSideEntity")&&(i.rightSideEntity=e.rightSideEntity.name),e.hasOwnProperty("parentText")&&(i.parentText=e.parentText),e.hasOwnProperty("parentEntity")&&(i.parentEntity=e.parentEntity.name),e.hasOwnProperty("completeBooleanExpression")&&(i.completeBooleanExpression=e.completeBooleanExpression),i}}class xc extends z{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("form")&&(i.form=e.form),e.hasOwnProperty("variableAssigned")&&(i.variableAssigned=e.variableAssigned),e.hasOwnProperty("condition")&&(i.condition=e.condition),i}}class Bc extends z{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("isParameter")&&(i.isParameter=e.isParameter),e.hasOwnProperty("prevUsageIsDefinition")&&(i.prevUsageIsDefinition=e.prevUsageIsDefinition),e.hasOwnProperty("overwriteType")&&(i.overwriteType=e.overwriteType),e.hasOwnProperty("overwriteValue")&&(i.overwriteValue=e.overwriteValue),e.hasOwnProperty("overwrittenVar")&&(i.overwrittenVar=e.overwrittenVar),e.hasOwnProperty("functionBlock")&&(i.functionBlock=e.functionBlock),e.hasOwnProperty("usageText")&&(i.usageText=e.usageText),i}}class Ac extends z{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("contents")&&(i.contents=e.contents),e.hasOwnProperty("textInParentheses")&&(i.textInParentheses=e.textInParentheses),i}}class kc extends z{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("branchMatches")&&(i.branchMatches=e.branchMatches),i}}class Pc extends z{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("isUndefined")&&(i.isUndefined=e.isUndefined),e.hasOwnProperty("subscriptedType")&&(i.subscriptedType=e.subscriptedType.name),e.hasOwnProperty("varName")&&(i.varName=e.varName),i}}class Lc extends z{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("boolValue")&&(i.boolValue=e.boolValue),e.hasOwnProperty("boolLiteralIfTrue")&&(i.boolLiteralIfTrue=e.boolLiteralIfTrue),e.hasOwnProperty("boolLiteralIfFalse")&&(i.boolLiteralIfFalse=e.boolLiteralIfFalse),e.hasOwnProperty("parentText")&&(i.parentText=e.parentText),e.hasOwnProperty("parentEntity")&&(i.parentEntity=e.parentEntity),i}}class Vc extends z{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("parts")&&(i.parts=e.parts),i}}class vc extends z{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("convertedValue")&&(i.convertedValue=e.convertedValue),e.hasOwnProperty("argType")&&(i.argType=e.argType),e.hasOwnProperty("convertedType")&&(i.convertedType=e.convertedType),i}}class Rc extends z{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("variable")&&(i.variable=e.variable.toJSON()),e.hasOwnProperty("localVariables")&&(i.localVariables=e.localVariables),i}}class Uc extends z{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("before")&&(i.before=e.before),e.hasOwnProperty("after")&&(i.after=e.after),i}}class Ec extends z{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("objectType")&&(i.objectType=e.objectType),i}}class Gc extends z{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("exitKeyword")&&(i.exitKeyword=e.exitKeyword),i}}class $c extends z{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("infiniteLoopLine")&&(i.infiniteLoopLine=e.infiniteLoopLine),i}}class Jc extends z{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();if(e.hasOwnProperty("expression")){let n=e.expression.getCategory().name;e.expression.getEntity()===t.FunctionName?n=zt:e.expression.getCategory()===a.BuiltInFunctions&&(n=Qt),i.unusedFunc={type:n,value:e.expression.getTextValue(),returnType:e.expression.getDataType().name.replace(" (int or float)","")}}return i}}class Kc extends z{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("funcType")&&(i.funcType=e.funcType),e.hasOwnProperty("numArgsExpected")&&(i.numArgsExpected=e.numArgsExpected),e.hasOwnProperty("varIsParameter")&&(i.varIsParameter=e.varIsParameter),i}}class Wc extends z{toJSON(){let i=super.toJSON();const e=this.getAdditionalInfo();return e.hasOwnProperty("expectedMinArgs")&&(i.expectedMinArgs=e.expectedMinArgs),e.hasOwnProperty("expectedMaxArgs")&&(i.expectedMinArgs=e.expectedMaxArgs),e.hasOwnProperty("receivedArgs")&&(i.receivedArgs=e.receivedArgs),i}}class O{static createStatementSymptom(i,e,n,s,o={},c="",f=!1){const p=e[n].getStartLineNumber(),w=c===""?e[n].getBlockId():c,S=e[n].getDocumentStartIndex(),F=e[n].getIndexOnLine(),N=oe(e.slice(n,s+1),f);switch(i){case b.AssignmentInBoolean:return new Sc(i.name,p,w,S,F,N,o);case b.AssignedNone:return new Ic(i.name,p,w,S,F,N,o);case b.AssignmentInReturn:return new bc(i.name,p,w,S,F,N,o);case b.CompareBoolLiteral:return new yc(i.name,p,w,S,F,N,o);case b.DefinitionFollowedByReservedWord:return new Fc(i.name,p,w,S,F,N,o);case b.FunctionPrints:return new Nc(i.name,p,w,S,F,N,o);case b.ForLoopIteratorModified:return new Tc(i.name,p,w,S,F,N,o);case b.LoopReturn:return new Cc(i.name,p,w,S,F,N,o);case b.LoopVarModifiedInChildLoop:return new Mc(i.name,p,w,S,F,N,o);case b.LoopVarNotModified:return new Oc(i.name,p,w,S,F,N,o);case b.NaturalLanguageBoolean:return new Dc(i.name,p,w,S,F,N,o);case b.OneLineConditional:return new xc(i.name,p,w,S,F,N,o);case b.OverwrittenVariable:return new Bc(i.name,p,w,S,F,N,o);case b.ReturnInParentheses:return new Ac(i.name,p,w,S,F,N,o);case b.SequentialIfs:return new kc(i.name,p,w,S,F,N,o);case b.SubscriptedNonSubscriptable:return new Pc(i.name,p,w,S,F,N,o);case b.TernaryReturnsBool:return new Lc(i.name,p,w,S,F,N,o);case b.TypeErrorInvalid:return new Vc(i.name,p,w,S,F,N,o);case b.TypeUnnecessary:return new vc(i.name,p,w,S,F,N,o);case b.UndefinedVariable:return new Rc(i.name,p,w,S,F,N,o);case b.UnexpectedColon:return new Uc(i.name,p,w,S,F,N,o);case b.UnknownMethod:return new Ec(i.name,p,w,S,F,N,o);case b.UnreachableExit:return new Gc(i.name,p,w,S,F,N,o);case b.UnreachableInfiniteLoop:return new $c(i.name,p,w,S,F,N,o);case b.UnusedReturn:return new Jc(i.name,p,w,S,F,N,o);case b.VariableWithSameNameAsFunction:return new Kc(i.name,p,w,S,F,N,o);case b.WrongArgNumber:return new Wc(i.name,p,w,S,F,N,o);default:return new z(i.name,p,w,S,F,N,o)}}static checkBooleanCompare(i){const e=i.getParent();e!==void 0&&(e.is(t.AssignmentStatement)||e.isOneOf([t.BooleanExpression,t.UserDefinedFunctionCall,t.BuiltInFunctionCall,t.IfDefinitionStatement,t.ElifDefinitionStatement,t.WhileDefinitionStatement,t.ReturnStatement,t.AssertStatement,t.ComparisonExpression,t.GroupStatement,t.TernaryStatement,t.BuiltInMethodCall,t.UserDefinedMethodCall]))}}l(O,"symptoms",[]),l(O,"constructs",[]),l(O,"text","");class Ps{constructor(){I(this,nn,[]);I(this,sn,[])}checkRules(i){for(const e of u(this,nn))O.symptoms.push(...e(i))}checkForConstructs(i){for(const e of u(this,sn))O.constructs.push(...e(i))}addRule(i){u(this,nn).push(i)}addConstructRule(i){u(this,sn).push(i)}addRules(i){u(this,nn).push(...i)}addConstructRules(i){u(this,sn).push(...i)}}nn=new WeakMap,sn=new WeakMap;class Ls extends Ps{constructor(){super();l(this,"observers");this.observers=new Set}addObserver(e,n=void 0){this.observers.add(e),e instanceof Ls&&n!==void 0&&e.typeUpdateReceived(n)}getObservers(){return this.observers}removeObserver(e){this.observers.delete(e)}sendUpdate(e){for(let n of this.observers)n instanceof Ls&&n.typeUpdateReceived(e)}typeUpdateReceived(e){}}class Fr extends Ps{constructor(e,n,s){super();I(this,Be);I(this,Pt);I(this,ve,[]);I(this,ct);I(this,st);I(this,rn,!1);I(this,Kn,[]);I(this,Wn,[]);if(!e.getVariable().isOneOf([t.VariableName,t.PropertyName]))throw new Error("First expression of variable is not a variable.");y(this,Pt,e.getVariable().getTextValue()),u(this,ve).push(e);const o=n.getExpressions();o.length>0&&o[0].is(t.FunctionDefinitionStatement)&&y(this,rn,!0),y(this,ct,s),y(this,st,s.getScope()),this.addRules([m(this,Be,Wr),m(this,Be,Jr)])}getName(){return u(this,Pt)}getUsages(){return u(this,ve)}addUsages(e){for(let n of e)this.addUsage(n)}insertUsages(e){const n=[...u(this,ve)];y(this,ve,e),this.addUsages(n)}addUsage(e){const n=e.getVariable();if(u(this,ve).length>0){let s=u(this,ve).length-1,o=!1;const c=new Set,f=[];for(;s>=0&&!o;){const p=u(this,ve)[s],w=p.getVariable();if(p.isInConditionalDefinition()){const S=p.getBodyOfConditional();if(c.has(S)){s--;continue}}if(e.isInSameBlock(p)||p.isInParentBlock(e)||m(this,Be,$r).call(this,w,n))n.addLastUsage(w),o=!0;else if(!e.isInAlternateBranch(p)&&!c.has(p.getBlock())){n.addLastUsage(w);const S=p.getBlock();c.add(S),S.isBranchBlock()&&S.isBranchOfConditional()&&(S.getBlockEntity()===t.ElseDefinition||S.getBlockEntity()===t.ExceptDefinition?f.push(new Set([...S.getSiblingConditionalBranches()])):S.isBranchOfExhaustiveConditional()&&(o=m(this,Be,xi).call(this,S,e.getBlock(),f,c)))}s--}if(!o&&!n.isAssignedOrChanged()){const p=new _t("Undefined Variable",t.VariableName,a.Identifiers,-1,-1,-1);p.setDataType(d.Undefined),n.addLastUsage(p)}}n.isProxy()||u(this,ve).push(e)}checkAndAdjustUndefined(){const e=this.getUsages();e[0].getVariable().isProxy()&&(e[0].getVariable().setDataType(d.Undefined),e.shift())}getDefinedInBlock(){return u(this,ct)}setDefinedInBlock(e){y(this,ct,e),e.isScopeBlock()||y(this,st,e.getScope())}isSameVariable(e){return u(this,Pt)===e.getName()&&u(this,ct).getId()===e.getDefinedInBlock().getId()&&u(this,st).hasChild(e.getScope()||e.getScope().hasChild(u(this,st)))}getScope(){return u(this,st)}isParameter(){return u(this,rn)}getChildScopesWithUsages(){return u(this,Kn)}addChildScopeWithUsages(e){u(this,Kn).push(e)}addChildScopeVariable(e){u(this,Wn).push(e)}getChildScopeVariables(){return u(this,Wn)}toJSON(){return{name:u(this,Pt),definitionBlock:u(this,ct).getId(),scopeBlock:u(this,st).getId(),isParameter:u(this,rn),usages:u(this,ve).map(e=>e.toJSON())}}}Pt=new WeakMap,ve=new WeakMap,ct=new WeakMap,st=new WeakMap,rn=new WeakMap,Kn=new WeakMap,Wn=new WeakMap,Be=new WeakSet,$r=function(e,n){return e.is(t.VariableName)||n.is(t.VariableName)?!1:e.getOwnerType().name===n.getOwnerType().name},xi=function(e,n,s,o){for(const c of s)if(c.has(e)&&(c.delete(e),c.size===0)){if(e.getParentBlock().hasChild(n))return!0;o.add(e.getParentBlock());const f=e.getParentBlock();if(f.isBranchBlock()){if(f.getBlockEntity()===t.ElseDefinition||f.getBlockEntity()===t.ExceptDefinition)s.push(new Set([...f.getSiblingConditionalBranches()]));else if(f.isBranchOfExhaustiveConditional())return m(this,Be,xi).call(this,f,n,s,o)}}return!1},Jr=function(e){var o;const n=[],s=e.getUsages();if(s.length===1){const f=s[0].getVariable(),p=f.getParent()&&f.getParent().is(t.MethodDefinitionStatement)&&f.getParent().getClassVar().getTextValue()===f.getTextValue();s.length===1&&f.isAssignedOrChanged()&&!p&&!m(o=e,Be,Kr).call(o,f)&&f.getDataType()!==d.Undefined&&n.push(O.createStatementSymptom(b.UnusedVariable,[s[0].getVariable()],0,0))}return n},Kr=function(e){if(e.getParent()===void 0)return!1;if(e.getParent().is(t.AssignmentStatement)){const n=e.getParent().getParent();return n===void 0?!1:n.isOneOf([a.FunctionCall,a.MethodCall])}return!1},Wr=function(e){const n=[],s=e.getUsages();let o;for(const c of s)if(!c.isPrecededByGlobal()){o=c;break}return o!==void 0&&s.length>0&&o.getVariable().getDataType()===d.Undefined&&(n.push(O.createStatementSymptom(b.UndefinedVariable,[o.getVariable()],0,0,{variable:e})),We(o.getVariable().getTextValue()).category===a.BuiltInFunctions&&n.push(O.createStatementSymptom(b.VariableWithSameNameAsFunction,[o.getVariable()],0,0,{funcType:Qt,varIsParameter:o.getVariable().isParameter()}))),n};class Tr{constructor(i,e,n=!1){I(this,dt);I(this,ut);I(this,Fe);I(this,on,!1);I(this,jn);y(this,ut,i),y(this,jn,n);const s=e.getStatements();e.isBranchBlock()&&e.getBlockEntity()!==t.ForDefinition&&e.getBlockEntity()!==t.WhileDefinition&&s.length>0?s[0].getDefinitionStatement().containsExpression(i)?(y(this,Fe,e.getParentBlock()),y(this,on,!0)):y(this,Fe,e):(y(this,Fe,e),s.length>0&&s[s.length-1].isBlockStatement()&&s[s.length-1].containsExpression(i)&&y(this,on,!0))}getVariable(){return u(this,ut)}getBlock(){return u(this,Fe)}isInConditionalDefinition(){return u(this,on)}getBodyOfConditional(){const i=u(this,Fe).getChildBlocks(),e=this.getVariable().getStartLineNumber();for(const n of i)if(n.isBranchBlock()&&n.isBranchOfConditional()&&n.getStatements()[0].getLineNumbers().has(e))return n;return u(this,Fe)}isInSameBlock(i){return u(this,Fe)===i.getBlock()}isInParentBlock(i){return!this.isInSameBlock(i)&&u(this,Fe).hasChild(i.getBlock())}isInAlternateBranch(i){if(u(this,Fe).getBlockEntity()===t.ExceptDefinition&&i.getBlock().getBlockEntity()===t.TryDefinition&&u(this,Fe).getParentBlock()===i.getBlock().getParentBlock())return!1;const e=this.isInConditionalDefinition(),n=i.isInConditionalDefinition();let s=u(this,Fe);e&&!n&&(s=this.getBodyOfConditional());let o=m(this,dt,ti).call(this,s);const c=m(this,dt,ti).call(this,i.getBlock());return o!==void 0&&c!==void 0?m(this,dt,jr).call(this,o,c,i.getBlock()):o!==void 0&&c===void 0||o===void 0&&c!==void 0?!1:!s.hasChild(i.getBlock())&&!i.getBlock().hasChild(s)}isPrecededByGlobal(){return u(this,jn)}toJSON(){return{line:u(this,ut).getStartLineNumber(),docIndex:u(this,ut).getDocumentStartIndex(),type:u(this,ut).getDataType().name}}}ut=new WeakMap,Fe=new WeakMap,on=new WeakMap,jn=new WeakMap,dt=new WeakSet,jr=function(i,e,n){for(;i!==void 0&&e!==void 0&&i!==e;){const s=i.getSiblingConditionalBranches();for(let o of s)if(o.hasChild(n))return!0;i=m(this,dt,ti).call(this,i.getParentBlock())}return!1},ti=function(i){return i!==void 0&&i.isBranchBlock()&&i.isBranchOfConditional()?i:i.getNearestParentOfAny([t.IfDefinition,t.ElifDefinition,t.ElseDefinition])};class jc{constructor(i,e,n=i){I(this,qn);I(this,Hn);I(this,an);I(this,it);I(this,Lt);y(this,qn,i),y(this,Hn,e),y(this,an,n),y(this,it,new Map),y(this,Lt,!1)}getName(){return u(this,qn)}getEntity(){return u(this,Hn)}getAlias(){return u(this,an)}setAlias(i){y(this,an,i)}addDirectImport(i,e){u(this,it).set(i,e)}hasDirectImport(i){return u(this,it).has(i)}getDirectImport(i){return u(this,it).get(i)}getDirectImports(){return u(this,it)}setImportAll(){y(this,Lt,!0)}didImportAll(){return u(this,Lt)}hasDirectImports(){return u(this,Lt)||u(this,it).size>0}}qn=new WeakMap,Hn=new WeakMap,an=new WeakMap,it=new WeakMap,Lt=new WeakMap;const qc=(g,i)=>({entity:g,category:i});class Nr{constructor(i){I(this,ln);I(this,ht,0);I(this,ft,0);y(this,ln,i);for(let e=0;e<i.length;e++)i.charAt(e)==="	"?ei(this,ft)._++:ei(this,ht)._++}getText(){return u(this,ln)}getSpaceCount(){return u(this,ht)}getTabCount(){return u(this,ft)}noIndentation(){return u(this,ln).length===0}isAllSpaces(){return u(this,ht)>0&&u(this,ft)===0}isAllTabs(){return u(this,ft)>0&&u(this,ht)===0}isMixed(){return u(this,ft)>0&&u(this,ht)>0}}ln=new WeakMap,ht=new WeakMap,ft=new WeakMap;class Cr extends Ps{constructor(e=t.DocumentDefinition,n=void 0,s=0){super();I(this,W);I(this,Re);I(this,gt);I(this,ae);I(this,zn);I(this,X);y(this,Re,e),y(this,gt,n),y(this,ae,[]),y(this,zn,s),y(this,X,[]),this.addRules([m(this,W,Xr),m(this,W,Qr),m(this,W,zr),m(this,W,qr)])}getBlockEntity(){return u(this,Re)}getId(){return`${u(this,Re)===t.DocumentDefinition?0:u(this,X).length>0?u(this,X)[0].getFirstLineNumber():-1}-${u(this,Re).name}`}getParentBlock(){return u(this,gt)}setParentBlock(e){y(this,gt,e)}getRootBlock(){return u(this,gt)===void 0?this:u(this,gt).getRootBlock()}getChildBlocks(){return u(this,ae)}getChildBlocksOfKind(e){let n=[];for(const s of u(this,ae))n=n.concat(s.getChildBlocksOfKind(e));return u(this,Re)===e&&n.push(this),n}addChildBlock(e){u(this,ae).push(e),e.setParentBlock(this)}hasParentOfEntity(e){return this.stepsToParentBlockOfEntity(e)>=0}stepsToParentBlockOfEntity(e){if(u(this,Re)===e)return 0;let n=this.getParentBlock(),s=1;for(;n!==void 0;){if(n.getBlockEntity()===e)return s;n=n.getParentBlock(),s++}return-1}getNearestParentOfAny(e){if(e.includes(u(this,Re)))return this;let n=this.getParentBlock();for(;n!==void 0;){if(e.includes(n.getBlockEntity()))return n;n=n.getParentBlock()}}getNearestParentChildOf(e){if(this===e||!e.hasChild(this))return;let n=this.getParentBlock();for(;n!==void 0&&n.getParentBlock()!==e;)n=n.getParentBlock();return n}getIndentation(){return u(this,zn)}getStartLine(){return u(this,Re)===t.DocumentDefinition?0:u(this,X).length>0?u(this,X)[0].getFirstLineNumber():-1}isScopeBlock(){return!1}isBranchBlock(){return!1}getScope(){if(this.isScopeBlock())return this;let e=this.getParentBlock();for(;e!==void 0&&!e.isScopeBlock();)e=e.getParentBlock();if(e!==void 0)return e;throw new Error("Could not find a scope block...block structure must be incorrect")}addStatement(e){u(this,X).push(e);for(const n of e.getExpressions())n.setBlockId(this.getId()),n.setScopeId(this.getScope().getId());K.makeGraphConnections(u(this,X))}getLastStatement(){if(u(this,X).length===0)throw new Error("No statements in the block. Could not get the last statement.");return u(this,X)[u(this,X).length-1]}replaceLastStatement(e){if(u(this,X).length===0)throw new Error("No statements in block. Cannot replace last statement.");u(this,X)[u(this,X).length-1]=e}updateLastStatement(e){const n=this.getLastStatement();if(!n.isBlockStatement())throw new Error("The last statement is not a block statement.");for(const s of e.getExpressions())s.setBlockId(this.getId()),s.setScopeId(this.getScope().getId());n.addStatement(e)}getStatements(){return u(this,X)}hasChild(e){if(this===e)return!0;{let n=e.getParentBlock();for(;n!==void 0;){if(n===this)return!0;n=n.getParentBlock()}return!1}}getBlockContainingLineNumber(e){if(u(this,X).length===0&&console.log("stop"),!(u(this,X)[0].getFirstLineNumber()>e||this.getLastStatement().getLastLineNumber()<e)){for(let n of u(this,ae))if(n.getBlockContainingLineNumber()!==void 0)return n;return this}}getLastExecutedStatements(){let e=[];for(let n of u(this,ae))n.isScopeBlock()||(e=e.concat(n.getLastExecutedStatements()));for(let n=0;n<u(this,X).length;n++)if(!u(this,X)[n].isBlockStatement()){if(n===u(this,X).length-1)e.push(u(this,X)[n]);else if(!u(this,X)[n].isBlank()&&u(this,X)[n].getFirstExpression().isOneOf([t.ReturnStatement,t.BreakKeyword])){e.push(u(this,X)[n]);break}}return e}alwaysReturnsAValue(){if(u(this,Re)===t.DocumentDefinition)return!1;if(u(this,ae).length===0){const e=this.getLastExecutedStatements();return e.length===1&&!e[0].isBlank()&&e[0].getFirstExpression().is(t.ReturnStatement)}else{if(this.hasTopLevelReturn())return!0;let e=!1,n=u(this,ae).length-1;for(;n>=0;){if(u(this,ae)[n].getBlockEntity()===t.ElseDefinition&&u(this,ae)[n].alwaysReturnsAValue())e=!0;else if(e&&u(this,ae)[n].getBlockEntity()===t.ElifDefinition&&u(this,ae)[n].alwaysReturnsAValue())e=!0;else{if(e&&u(this,ae)[n].getBlockEntity()===t.IfDefinition&&u(this,ae)[n].alwaysReturnsAValue())return!0;e=!1}n--}return!1}}hasTopLevelReturn(){for(let e of u(this,X))if(!e.isBlockStatement()&&!e.isBlank()&&e.getFirstExpression().is(t.ReturnStatement))return!0;return!1}checkRules(e){super.checkRules(e);for(const n of e.getChildBlocks())n.checkRules(n)}toJSON(){return{id:this.getId(),startLine:this.getStartLine(),children:u(this,ae).map(e=>e.toJSON())}}toTree(){return{id:this.getId(),statements:u(this,X).map(e=>e.toJSON()),children:u(this,ae).map(e=>e.toTree())}}static blockFactory(e=t.DocumentDefinition,n=void 0,s=0){switch(e){case t.DocumentDefinition:case t.FunctionDefinition:case t.ClassDefinition:case t.ListComprehension:return new $n(e,n,s);default:return new Mr(e,n,s)}}}Re=new WeakMap,gt=new WeakMap,ae=new WeakMap,zn=new WeakMap,X=new WeakMap,W=new WeakSet,qr=function(e){var o;const n=[];let s=e.getStatements();s.length===1&&s[0].isBlockStatement()&&s[0].getFirstExpression().getBlockId()===e.getId()&&(s=s[0].getStatements().slice(1));for(let c=0;c<s.length;c++){const f=s[c].getFirstExpression();if(f.is(t.WhileDefinitionStatement)&&m(o=e,W,Hr).call(o,s[c])){const p=s[c].getDefinitionStatement().getFirstExpression();if(n.push(O.createStatementSymptom(b.InfiniteLoop,[p],0,0)),c<s.length-1){const w=ks(s.slice(c+1));n.push(O.createStatementSymptom(b.UnreachableInfiniteLoop,w,0,w.length-1,{infiniteLoopLine:f.getStartLineNumber()}))}}if(Xt(f)&&c<s.length-1){const p=s.slice(c+1),w=ks(p),S=f.getFirstExpressionOf([t.ReturnKeyword,t.BreakKeyword,t.ExitFunction,t.SysExit,t.QuitFunction]);n.push(O.createStatementSymptom(b.UnreachableExit,w,0,w.length-1,{exitKeyword:S!==void 0?S.getTextValue():"undefined"}))}}return n},Hr=function(e){const o=e.getDefinitionStatement().getFirstExpression().getVariableExpressions();for(const c of e.getStatements()){const f=c.getExpressions();for(const p of f){if(Xt(p))return!1;const w=p.getVariableExpressions().filter(F=>F.isAssignedOrChanged()),S=new Set(w.map(F=>F.getTextValue()));for(const F of o)if(S.has(F.getTextValue()))return!1}}return!0},zr=function(e){const n=[];for(const s of e.getChildBlocks())if(s.getBlockEntity()===t.IfDefinition&&s.isBranchOfExhaustiveConditional()&&s.hasTopLevelExit()){const o=s.getSiblingConditionalBranches();let c=!0,f=-1;for(const p of o){if(!p.hasTopLevelExit()){c=!1;break}p.getBlockEntity()===t.ElseDefinition&&(f=p.getStartLine())}if(c&&f>0){const p=e.getStatements().filter(w=>w.getFirstLineNumber()>f);if(p.length>0){const w=ks(p);n.push(O.createStatementSymptom(b.UnreachableExhaustiveConditional,w,0,w.length-1))}}}return n},Qr=function(e){var c,f,p,w;const n=[];let s=e.getStatements();s.length===1&&s[0].isBlockStatement()&&(s=s[0].getStatements().slice(1));let o=[];for(let S=0;S<s.length-1;S++){const F=s[S].getFirstExpression(),N=s[S+1].getFirstExpression();if(F.is(t.IfDefinitionStatement)&&N.is(t.IfDefinitionStatement)&&!m(c=e,W,Bi).call(c,s[S])&&!m(f=e,W,Bi).call(f,s[S+1]))o.length===0&&o.push(s[S]),o.push(s[S+1]);else if(o.length>0){const R=m(p=e,W,Ai).call(p,o);R!==void 0&&n.push(R),o=[]}}if(o.length>0){const S=m(w=e,W,Ai).call(w,o);S!==void 0&&n.push(S)}return n},Bi=function(e){const n=e.getStatements().slice(1);for(const s of n)if(!s.isBlockStatement()&&Xt(s.getFirstExpression()))return!0;return!1},Ai=function(e){if(e.length===0)return;const n=[];let s=[];for(let c=0;c<e.length-1;c++){let f=e[c].getFirstExpression().getCondition();f=f.length===1&&f[0].is(t.GroupStatement)?f[0].getContents():f;let p=e[c+1].getFirstExpression().getCondition();p=p.length===1&&p[0].is(t.GroupStatement)?p[0].getContents():p,m(this,W,ki).call(this,f,p)&&m(this,W,ki).call(this,p,f)?((s.length===0||s[s.length-1].docIndex!==e[c].getFirstExpression().getDocumentStartIndex())&&s.push({lineNum:e[c].getFirstExpression().getStartLineNumber(),docIndex:e[c].getFirstExpression().getDocumentStartIndex()}),s.push({lineNum:e[c+1].getFirstExpression().getStartLineNumber(),docIndex:e[c+1].getFirstExpression().getDocumentStartIndex()})):s.length>0&&(n.push(s),s=[])}s.length>0&&(n.push(s),s=[]);const o=ks(e);return O.createStatementSymptom(b.SequentialIfs,o,0,o.length-1,{branchMatches:n})},ki=function(e,n){if(e.length!==n.length)return!1;for(const s of e){let o=!1;for(const c of n)if(s.matchesPattern(c)){o=!0;break}if(!o)return!1}return!0},Xr=function(e){var c,f,p,w;const n=S=>{try{const N=S.getFirstExpression().getCondition();if(N.length>0)return N.map(R=>R.getTextValue()).join(" ")}catch{return""}},s=[];let o=e.getStatements();o.length===1&&o[0].isBlockStatement()&&o[0].getFirstExpression().getBlockId()===e.getId()&&(o=o[0].getStatements().slice(1));for(let S=0;S<o.length-1;S++){let F={};const N=o[S].getFirstExpression(),R=o[S+1].getFirstExpression();if(N.is(t.IfDefinitionStatement)){const k=o[S].getStatements();if(R.is(t.ElseDefinitionStatement)){const M=o[S+1].getStatements();if(k.length===2&&M.length===2&&m(c=e,W,Li).call(c,k[1],M[1])){const jt=n(k[0]);F={form:ii,condition:jt}}else if(k.length===2&&M.length===2&&m(f=e,W,Pi).call(f,k[1],M[1])){const jt=n(k[0]);F={form:ri,variableAssigned:k[1].getFirstExpression().getTargetVariables()[0].getTextValue(),condition:jt}}}else if(k.length===2&&m(p=e,W,Li).call(p,k[1],o[S+1])){const M=n(k[0]);F={form:ii,condition:M}}else if(k.length===2&&m(w=e,W,Pi).call(w,k[1],o[S+1])){const M=n(k[0]);F={form:ri,variableAssigned:k[1].getFirstExpression().getTargetVariables()[0].getTextValue(),condition:M}}if(F.hasOwnProperty("form")){const M=[...o[S].getExpressions(),...o[S+1].getExpressions()];s.push(O.createStatementSymptom(b.OneLineConditional,M,0,M.length-1,F))}}}return s},Pi=function(e,n){const s=e.getFirstExpression(),o=n.getFirstExpression();if(s.getDataType()===d.Bool&&o.getDataType()===d.Bool&&s.is(t.AssignmentStatement)&&o.is(t.AssignmentStatement)){const c=m(this,W,Ms).call(this,s.getAssignedValues()),f=m(this,W,Ms).call(this,o.getAssignedValues()),p=s.getTargetVariables(),w=o.getTargetVariables();return c.length!==1||f.length!==1||p.length!==1||w.length!==1?!1:p[0].getTextValue()===w[0].getTextValue()&&m(this,W,Vi).call(this,c[0],f[0])}return!1},Li=function(e,n){const s=e.getFirstExpression(),o=n.getFirstExpression();if(s.getDataType()===d.Bool&&o.getDataType()===d.Bool&&s.is(t.ReturnStatement)&&o.is(t.ReturnStatement)){const c=m(this,W,Ms).call(this,s.getReturnedValue()),f=m(this,W,Ms).call(this,o.getReturnedValue());return c.length!==1||f.length!==1?!1:m(this,W,Vi).call(this,c[0],f[0])}return!1},Vi=function(e,n){return e.is(t.TrueType)&&n.is(t.FalseType)||e.is(t.FalseType)&&n.is(t.TrueType)},Ms=function(e){return e.length!==1?e:e[0].is(t.GroupStatement)?e[0].getContents():e};class $n extends Cr{constructor(e=t.DocumentDefinition,n=void 0,s=0){if(e!==t.DocumentDefinition&&e!==t.FunctionDefinition&&e!==t.ClassDefinition&&e!==t.ListComprehension)throw new Error(`${e.name} is not a scope block`);super(e,n,s);l(this,"variableMap",new Map);l(this,"globalVars",new Set);l(this,"moduleMap",new Map);l(this,"userDefinedFunctionMap",new Map);l(this,"unconnectedFunctionCalls",new Map);l(this,"userDefinedClassMap",new Map);l(this,"unconnectedMethodCalls",new Map);I(this,yi);I(this,Fi)}isScopeBlock(){return!0}getScope(){return this}addStatement(e){super.addStatement(e),K.connectVariableUsages(e,this);const n=this.getParentBlock()!==void 0&&this.getBlockEntity()!==t.ListComprehension?this.getParentBlock().getScope():this;K.connectUserDefinedFunctions(e,n!==void 0?n:this),K.connectUserDefinedMethods(e,n!==void 0?n:this)}getVariableMap(){return this.variableMap}getModuleMap(){return this.moduleMap}getStatementToUpdate(e,n){if(this.getStatements().length>0&&this.getLastStatement().isBlockStatement())return this.getLastStatement().getLastLineNumber()!==n?this.getLastStatement().getBlockStatementForIndent(e):this.getLastStatement().getLastBlockStatement()}addUserDefinedFunction(e){if(e!==void 0){const n=e.getTextValue();if(this.userDefinedFunctionMap.set(n,e),this.unconnectedFunctionCalls.has(n)){for(let s of this.unconnectedFunctionCalls.get(n))e.addObserver(s);this.unconnectedFunctionCalls.delete(n)}}}addUserDefinedClass(e){this.userDefinedClassMap.set(e.name,e)}getUserDefinedFunctions(){return this.userDefinedFunctionMap}getUserDefinedClasses(){return this.userDefinedClassMap}getUnconnectedFunctionCalls(){return this.unconnectedFunctionCalls}getUnconnectedMethodCalls(){return this.unconnectedMethodCalls}addUnconnectedFunctionCall(e){const n=e.getFunctionName();this.unconnectedFunctionCalls.has(n)||this.unconnectedFunctionCalls.set(n,[]),this.unconnectedFunctionCalls.get(n).push(e)}addUnconnectedMethodCall(e){const n=e.getMethodName();this.unconnectedMethodCalls.has(n)||this.unconnectedMethodCalls.set(n,[]),this.unconnectedMethodCalls.get(n).push(e)}addGlobalVar(e){this.globalVars.add(e)}getGlobalVars(){return this.globalVars}findAllFunctions(){const e=new Map(this.getUserDefinedFunctions());let n=this.getParentBlock();for(;n!==void 0&&n.getScope()!==void 0;){n=n.getScope();const s=n.getUserDefinedFunctions();for(const[o,c]of s)e.set(o,c);n=n.getParentBlock()}return e}findAllModules(){const e=new Map(this.getModuleMap());let n=this.getParentBlock();for(;n!==void 0&&n.getScope()!==void 0;){n=n.getScope();const s=n.getModuleMap();for(const[o,c]of s)e.set(o,c);n=n.getParentBlock()}return e}}yi=new WeakMap,Fi=new WeakMap;class Hc extends $n{constructor(e,n){super(t.ClassDefinition,e,n.getIndentation());I(this,cn);y(this,cn,n.getFirstExpression().getDataType()),e.getScope().addUserDefinedClass(u(this,cn)),this.addStatement(n)}getClassType(){return u(this,cn)}toTree(){const e=this.getStatements();return{id:this.getId(),definition:e.length>0?e[0].toJSON():{},statements:e.slice(1).map(n=>n.toJSON())}}}cn=new WeakMap;const $s=class $s extends $n{constructor(e,n){super(t.FunctionDefinition,e,n.getIndentation());I(this,Gs);I(this,Ti);I(this,Qn);const s=n.getFirstExpression(),o=s.getEntity()===t.FunctionDefinitionStatement?s.getFunctionNameExpression():s.getMethodNameExpression();if(y(this,Qn,o!==void 0?o.getTextValue():"not parsed"),e.getScope().addUserDefinedFunction(o),s.is(t.MethodDefinitionStatement)&&s.getClassVar()&&e.getBlockEntity()===t.ClassDefinition){const f=e.getStatements()[0].getFirstExpression().getDataType();s.getClassVar().setDataType(f)}this.addStatement(n),this.addRules([m(this,Gs,Zr)])}getReturnType(){const n=this.getLastExecutedStatements().filter(s=>!s.isBlank()&&s.getFirstExpression().is(t.ReturnStatement)).map(s=>s.getFirstExpression().getDataType());return this.alwaysReturnsAValue()||n.push(d.None),Nt(n)}getFunctionName(){return u(this,Qn)}getFunctionExpression(){const e=this.getStatements();if(e.length>0&&e[0].getFirstExpression().is(t.FunctionDefinitionStatement))return e[0].getFirstExpression().getFunctionNameExpression()}toTree(){const e=this.getStatements();return{id:this.getId(),definition:e.length>0?e[0].toJSON():{},statements:e.slice(1).map(n=>n.toJSON())}}};Ti=new WeakMap,Qn=new WeakMap,Gs=new WeakSet,Zr=function(e){var o;const n=[],s=e.getFunctionExpression();if(s!==void 0){const c=e.getStatements(),f=m(o=$s,Xn,vi).call(o,c);f.length>0&&n.push(O.createStatementSymptom(b.FunctionPrints,[s],0,0,{printLines:f,functionReturns:s.getReturnType()!==d.None}))}return n},Xn=new WeakSet,vi=function(e){let n=[];for(let s=0;s<e.length;s++)if(e[s].isBlockStatement())n=n.concat(m(this,Xn,vi).call(this,e[s].getStatements()));else{const o=e[s].getFirstExpression();o.is(t.BuiltInFunctionCall)&&o.getFunctionEntity()===t.PrintFunction?n.push({lineNumber:o.getStartLineNumber(),followsReturn:s>0&&e[s].getFirstExpression().is(t.ReturnStatement),precedesReturn:s<e.length-1&&e[s+1].getFirstExpression().is(t.ReturnStatement),isReturned:!1,isEndOfExitBranch:s===e.length-1,blockId:o.getBlockId()}):o.is(t.ReturnStatement)&&o.getExpressionsOfKind(t.PrintFunction).length>0&&n.push({lineNumber:o.getStartLineNumber(),followsReturn:!1,precedesReturn:!1,isReturned:!0,isEndOfExitBranch:s===e.length-1,blockId:o.getBlockId()})}return n},I($s,Xn);let di=$s;class zc extends $n{constructor(i,e){super(t.ListComprehension,i);const n=new Ot(e.getTextValue(),e.getStartLineNumber(),new Nr(""),[e]);this.addStatement(n)}getId(){const i=this.getStatements();return`${super.getId()}-${i.length>0&&!i[0].isBlank()?i[0].getFirstExpression().getDocumentStartIndex():"-1"}`}}class Mr extends Cr{constructor(e,n){const s=n.getFirstExpression().getBlockEntity();if(s===t.DocumentDefinition||s===t.FunctionDefinition||s===t.ClassDefinition||s===t.ListComprehension)throw new Error(`${s.name} is a scope block`);super(s,e,n.getIndentation());I(this,j);l(this,"conditionalSiblings",new Set);this.addStatement(n),this.addRules([m(this,j,eo),m(this,j,no),m(this,j,_r),m(this,j,to)])}isScopeBlock(){return!1}isBranchBlock(){return!0}getLastExecutedStatements(){let e=[];for(let s of this.getChildBlocks())e=e.concat(s.getLastExecutedStatements());const n=m(this,j,tt).call(this);for(let s=0;s<n.length;s++)if(!n[s].isBlockStatement()){if(s===n.length-1&&this.isBranchOfExhaustiveConditional())e.push(n[s]);else if(!n[s].isBlank()&&n[s].getFirstExpression().isOneOf([t.ReturnStatement,t.BreakKeyword])){e.push(n[s]);break}}return e}hasTopLevelReturn(){const e=m(this,j,tt).call(this);for(let n of e)if(!n.isBlockStatement()&&!n.isBlank()&&n.getFirstExpression().is(t.ReturnStatement))return!0;return!1}hasTopLevelExit(){const e=m(this,j,tt).call(this);for(let n of e)if(!n.isBlockStatement()&&!n.isBlank()&&n.getExpressions().filter(s=>Xt(s)).length>0)return!0;return!1}isBranchOfConditional(){return this.getBlockEntity()===t.IfDefinition||this.getBlockEntity()===t.ElifDefinition||this.getBlockEntity()===t.ElseDefinition||this.getBlockEntity()===t.TryDefinition||this.getBlockEntity()===t.ExceptDefinition||this.getBlockEntity()===t.FinallyDefinition}isBranchOfExhaustiveConditional(){if(this.getBlockEntity()===t.ElseDefinition)return m(this,j,Os).call(this,t.IfDefinition);if(this.getBlockEntity()===t.ElifDefinition){let e=!1,n=!1;for(const s of this.conditionalSiblings)if(s.getBlockEntity()===t.IfDefinition?e=!0:s.getBlockEntity()===t.ElseDefinition&&(n=!0),e&&n)return!0}else{if(this.getBlockEntity()===t.IfDefinition)return m(this,j,Os).call(this,t.ElseDefinition);if(this.getBlockEntity()===t.TryDefinition)return m(this,j,Os).call(this,t.ExceptDefinition);if(this.getBlockEntity()===t.ExceptDefinition)return m(this,j,Os).call(this,t.TryDefinition)}return!1}getSiblingConditionalBranches(){return this.conditionalSiblings}addSibling(e){if(!this.isBranchOfConditional())throw new Error("Cannot add a sibling to a branch that is not a conditional");if(!e.isBranchOfConditional())throw new Error("Trying to add a non-conditional branch as a sibling.");this.conditionalSiblings.add(e)}}j=new WeakSet,tt=function(){const e=this.getStatements();return e.length,e[0].getStatements()},Os=function(e){for(const n of this.conditionalSiblings)if(n.getBlockEntity()===e)return!0;return!1},Yr=function(){const e=m(this,j,tt).call(this).flatMap(s=>s.getExpressions());return oe(e,!0)},_r=function(e){return[]},eo=function(e){var s;const n=[];if(e.getBlockEntity()===t.ForDefinition||e.getBlockEntity()===t.WhileDefinition&&e.hasTopLevelExit())for(const o of m(s=e,j,tt).call(s))!o.isBlockStatement()&&!o.isBlank()&&Xt(o.getFirstExpression())&&n.push(O.createStatementSymptom(b.LoopReturn,[o.getFirstExpression()],0,0,{loopType:e.getBlockEntity().name,exitLevel:cc,exitTypes:[o.getFirstExpression().isOneOf([t.ReturnKeyword,t.ReturnStatement])?"return":o.getFirstExpression().getTextValue()]},e.getId()));else if(e.isBranchOfExhaustiveConditional()&&e.getBlockEntity()===t.IfDefinition&&e.hasTopLevelExit()&&(e.getParentBlock()!==void 0&&e.getParentBlock().getBlockEntity()===t.ForDefinition||e.getParentBlock().getBlockEntity()===t.WhileDefinition)){for(const p of e.getSiblingConditionalBranches())if(!p.hasTopLevelExit())return n;const c=e.getParentBlock().getStatements()[0].getExpressions(),f=c.flatMap(p=>p.getExpressionsOfKind(t.ReturnKeyword).concat(p.getExpressionsOfKind(t.BreakKeyword),p.getExpressionsOfKind(t.ExitFunction),p.getExpressionsOfKind(t.SysExit),p.getExpressionsOfKind(t.QuitFunction))).map(p=>p.getTextValue());n.push(O.createStatementSymptom(b.LoopReturn,[c[0]],0,0,{loopType:e.getParentBlock().getBlockEntity().name,exitLevel:uc,exitTypes:f},e.getParentBlock().getId()))}return n},to=function(e){var s,o;const n=[];if(e.getBlockEntity()===t.WhileDefinition){const c=m(s=e,j,tt).call(s)[0].getFirstExpression(),f=new Set(c.getVariableExpressions().map(F=>F.getTextValue())),p=m(o=e,j,tt).call(o).slice(1),w=new Map,S=new Map;for(const F of f)w.set(F,!1),S.set(F,[]);for(const F of p)for(const N of F.getExpressions()){const R=N.getExpressionsOfKind(t.ChangeStatement).flatMap(M=>M.getTargetVariables()).filter(M=>f.has(M.getTextValue())),k=N.getExpressionsOfKind(t.AssignmentStatement).flatMap(M=>M.getTargetVariables()).filter(M=>f.has(M.getTextValue()));for(const M of R)w.has(M.getTextValue())&&w.set(M.getTextValue(),!0);for(const M of k)S.has(M.getTextValue())&&S.get(M.getTextValue()).push(M)}for(const F of f)if(!w.get(F)&&S.get(F).length>0){let N=[],R=!1;for(const k of S.get(F)){const M=k.getParent().getAssignedValues();if(M.length===1&&M[0].is(t.IntLiteral))N.push(k);else{R=!0;break}}if(!R)for(const k of N)n.push(O.createStatementSymptom(b.WhileLoopVarAssignedIntLiteral,[k],0,0))}}return n},no=function(e){var s,o,c;const n=[];if(e.getBlockEntity()===t.WhileDefinition){const f=m(s=e,j,tt).call(s)[0].getFirstExpression(),p=new Set(f.getVariableExpressions());if(p.size>0){const w=m(o=e,j,Ri).call(o,p),S=new Set,F=new Map;for(const N of p){const R=w.get(N);for(const k of R){k===e&&S.add(N);const M=k.getNearestParentOfAny([t.WhileDefinition,t.ForDefinition]);M!==void 0&&M!==e&&e.hasChild(M)?(F.has(N)||F.set(N,new Set),F.get(N).add(M)):M!==void 0&&M===e&&S.add(N)}}S.size===0&&n.push(O.createStatementSymptom(b.LoopVarNotModified,[f],0,0,{unmodifiedVars:Array.from(p).map(N=>N.getTextValue()),loopText:m(c=e,j,Yr).call(c)},e.getId()));for(const[N,R]of F){const k=O.createStatementSymptom(b.LoopVarModifiedInChildLoop,[N],0,0,{modifiedIn:[],varDataType:[]},e.getId());for(const M of R)k.getAdditionalInfo().modifiedIn.push({loopType:M.getBlockEntity().name,startLine:M.getStatements()[0].getFirstLineNumber(),varDataType:N.getDataType().name});n.push(k)}}}return n},Ri=function(e){var o;const n=m(this,j,tt).call(this).filter(c=>!c.isBlockStatement()),s=new Map;for(const c of e)s.set(c,new Set);for(const c of n){const f=c.getExpressions();for(const p of f){const w=p.getVariableExpressions().filter(F=>F.isAssignedOrChanged()),S=new Set(w.map(F=>F.getTextValue()));for(const F of e)S.has(F.getTextValue())&&s.get(F).add(this)}}for(const c of this.getChildBlocks().filter(f=>f.isBranchBlock())){const f=m(o=c,j,Ri).call(o,e);for(const p of e)f.get(p).size>0&&s.get(p).add(...f.get(p))}return s};class Jn{constructor(i,e,n,{multilineCommentDelimiter:s=void 0,stringLiteralDelimiter:o=void 0,groupCharCounts:c={"(":0,"[":0,"{":0},lastLineExpressions:f=[],startFrom:p=0,moduleNames:w=[],varsWithTypeNames:S=[],classDefinitionInProgress:F=!1}={}){I(this,T);I(this,_,[]);I(this,Vt,[]);I(this,Zn,!1);I(this,un,!1);I(this,je);I(this,Te);I(this,U);I(this,vt);I(this,Yn);I(this,Ne);I(this,Ae);I(this,ge);I(this,pt);I(this,Ni,[]);y(this,U,i),y(this,pt,u(this,U).length-1),y(this,Ne,e),y(this,Ae,n),y(this,je,s),y(this,Te,o),y(this,ge,c),y(this,vt,m(this,T,io).call(this,i)),y(this,Yn,new Nr(i.substring(0,u(this,vt)))),y(this,Vt,f),u(this,U).length>0?m(this,T,so).call(this,p>0?p:u(this,vt),S,w,F):m(this,T,Ui).call(this)}getText(){return u(this,U)}getLineNumber(){return u(this,Ne)}getExpressions(){return u(this,_)}getDocumentStartIndex(){return u(this,Ae)}getLineEndIndex(){return u(this,pt)}getIndentation(){return u(this,vt)}getIndent(){return u(this,Yn)}continuesOnNextLine(){return u(this,Zn)}followedBySeparateStatement(){return u(this,un)}hasOpenComment(){return u(this,je)!==void 0}getCommentDelimiter(){if(!this.hasOpenComment())throw new Error("This line of source code does not have an open multiline comment delimiter. Line",u(this,Ne));return u(this,je)}hasOpenString(){return u(this,Te)!==void 0}getStringLiteralDelimiter(){if(!this.hasOpenString())throw new Error("This line of source code does not have an open string literal delimiter. Line",u(this,Ne));return u(this,Te)}hasOpenGroupChars(){return Object.entries(u(this,ge)).filter(([i,e])=>e>0).length>0}getOpenGroupChars(){return u(this,ge)}}_=new WeakMap,Vt=new WeakMap,Zn=new WeakMap,un=new WeakMap,je=new WeakMap,Te=new WeakMap,U=new WeakMap,vt=new WeakMap,Yn=new WeakMap,Ne=new WeakMap,Ae=new WeakMap,ge=new WeakMap,pt=new WeakMap,Ni=new WeakMap,T=new WeakSet,so=function(i,e,n,s){u(this,je)!==void 0?i=m(this,T,Ei).call(this,u(this,je),0)+1:u(this,Te)!==void 0&&(i=m(this,T,Gi).call(this,B.getCategory(u(this,Te).charCodeAt(0)),0)+1);for(let o=i;o<u(this,U).length;o++){const c=B.getCategory(u(this,U).charCodeAt(o));if(c===B.Hash)o=u(this,U).length-1;else if(c.isQuote())o=m(this,T,oo).call(this,c,o);else if(m(this,T,go).call(this,c))o=m(this,T,po).call(this,o,e,n,s);else if(m(this,T,To).call(this,c,o,o===0||B.getCategory(u(this,U).charCodeAt(o-1))===B.Space))o=m(this,T,Co).call(this,o);else if(m(this,T,Mo).call(this,c))o=m(this,T,Oo).call(this,o);else if(m(this,T,uo).call(this,c))o=m(this,T,fo).call(this,o);else if(m(this,T,Do).call(this,c)&&(m(this,T,xo).call(this,o),o<u(this,pt)&&m(this,T,Bo).call(this,c))){y(this,pt,o),m(this,T,ro).call(this);break}}m(this,T,Ui).call(this)},io=function(i){return Math.max(i.search(/\S/),0)},Ui=function(){(u(this,je)!==void 0||u(this,Te)!==void 0||this.hasOpenGroupChars()||m(this,T,ze).call(this)&&m(this,T,xe).call(this).isOneOf([t.ContinuationLine,t.AddOperator,t.Comma]))&&y(this,Zn,!0)},ro=function(){const i=u(this,U).substring(u(this,pt)+1).trim();i.length===0||B.getCategory(i.charCodeAt(0))===B.Hash?y(this,un,!1):y(this,un,!0)},qt=function(i){for(let e of u(this,_))if(e.is(i))return!0;return!1},ze=function(){return u(this,_).length>0},xe=function(){if(u(this,_).length===0)throw new Error("Attempted to get last expression when there are no expressions.");return u(this,_)[u(this,_).length-1]},oo=function(i,e){return m(this,T,co).call(this,i,e)?m(this,T,ao).call(this,e):m(this,T,Gi).call(this,i,e)},ao=function(i){const e=u(this,U).substring(i,i+3);let n=i+3;return m(this,T,Ei).call(this,e,n)},Ei=function(i,e){if(e<u(this,U).length){const s=m(this,T,$i).call(this,u(this,U)).substring(e).indexOf(i);if(s>-1)return y(this,je,void 0),e+s+2}return y(this,je,i),u(this,U).length-1},Gi=function(i,e){const n=m(this,T,$i).call(this,u(this,U)),s=u(this,Te)===void 0?m(this,T,lo).call(this,i,e,n):u(this,Te);let o=u(this,Te)===void 0?e+s.length:e,c=o+n.substring(o).indexOf(s);c===-1||c<o?(y(this,Te,s),c=u(this,U).length):y(this,Te,void 0);const f=Math.min(u(this,U).length-1,c+s.length-1),p=u(this,U).substring(e,f+1),w=new xr(p,u(this,Ne),u(this,Ae)+e,e,u(this,Ae)+f);if(m(this,T,ze).call(this)&&m(this,T,xe).call(this).is(t.F)){const S=[m(this,T,xe).call(this),w],F=new iu(oe(S),S);u(this,_)[u(this,_).length-1]=F}else u(this,_).push(w);return f},lo=function(i,e,n){const s=i===B.SingleQuote?"'":'"';return e<n.length-2&&B.getCategory(n.charCodeAt(e))===i&&B.getCategory(n.charCodeAt(e+1))===i&&B.getCategory(n.charCodeAt(e+2))===i?s+s+s:s},$i=function(i){return i.replace(/\\.{1}/g,"  ")},co=function(i,e){return m(this,T,ze).call(this)&&m(this,T,xe).call(this).is(t.AssignmentOperator)||u(this,ge)["("]>0||u(this,ge)["["]>0||u(this,ge)["{"]>0?!1:i.isQuote()&&u(this,U).length>e+2&&B.getCategory(u(this,U).charCodeAt(e))===i&&B.getCategory(u(this,U).charCodeAt(e+1))===i&&B.getCategory(u(this,U).charCodeAt(e+2))===i},uo=function(i){return i===B.At},ho=function(i){let e=i;for(let n=i+1;n<u(this,U).length;n++){const s=B.getCategory(u(this,U).charCodeAt(n));if(s!==B.Space&&s!==B.NewLine)e=n;else break}return u(this,U).substring(i,e+1)},fo=function(i){const e=m(this,T,ho).call(this,i),n=new q(t.Decorator,a.SyntacticSugar),s=Yt(e,n,u(this,Ne),u(this,Ae)+i,i);return u(this,_).push(s),i+e.length-1},go=function(i){return i===B.Underscore||i===B.Letter},po=function(i,e,n,s){let o=m(this,T,mo).call(this,i),c=m(this,T,wo).call(this,o,m(this,T,Fo).call(this,i+o.length),e,n,s);const f=Yt(o,c,u(this,Ne),u(this,Ae)+i,i);return m(this,T,ze).call(this)&&(c.entity===t.InKeyword&&m(this,T,xe).call(this).is(t.NotOperator)||c.entity===t.NotOperator&&m(this,T,xe).call(this).is(t.IsKeyword))?(o=oe([m(this,T,xe).call(this),f]),c=new q(c.entity===t.InKeyword?t.NotInKeyword:t.IsNotKeyword,a.ComparisonOperators),i=m(this,T,xe).call(this).getDocumentStartIndex()-u(this,Ae),u(this,_)[u(this,_).length-1]=Yt(o,c,u(this,Ne),m(this,T,xe).call(this).getDocumentStartIndex())):u(this,_).push(f),i+o.length-1},mo=function(i){let e=i;for(let n=i+1;n<u(this,U).length;n++){const s=B.getCategory(u(this,U).charCodeAt(n));if(s===B.Underscore||s===B.Letter||s===B.Digit)e=n;else break}return u(this,U).substring(i,e+1)},wo=function(i,e,n,s,o){const c=We(i);if(m(this,T,ze).call(this)){const f=m(this,T,xe).call(this);if(f.is(t.FunctionDefinition))return o?new q(t.MethodName,a.Identifiers):new q(t.FunctionName,a.Identifiers);if(f.is(t.ClassDefinition))return new q(t.ClassName,a.Identifiers);if(f.is(t.FromKeyword)||m(this,T,qt).call(this,t.ImportKeyword)&&!m(this,T,qt).call(this,t.FromKeyword))if(f.is(t.AsKeyword)&&u(this,_).length>1){const p=u(this,_)[u(this,_).length-2];return new q(p.getEntity(),p.getCategory())}else return c.entity===t.Unknown?new q(t.ModuleName,a.Identifiers):c;else if(m(this,T,Rn).call(this)){if(e!=="(")return c.category===a.Unknown?new q(t.PropertyName,a.ModuleProperties):c;{const p=this.getExpressions();if(p.length>=2){const w=p[p.length-2];return w.is(a.BuiltInModules)&&c.category===a.ModuleFunctions||c.category===a.BuiltInMethods?c:w.is(t.ModuleName)?new q(t.MethodName,a.ModuleFunctions):new q(t.MethodName,a.OtherMethods)}}}else{if(m(this,T,qt).call(this,t.FromKeyword)&&m(this,T,qt).call(this,t.ImportKeyword))return m(this,T,yo).call(this,i);if((i==="sep"||i==="end")&&!(f.is(t.Comma)&&e==="="))return new q(t.VariableName,a.Identifiers);if(c.entity!==t.VariableName&&fc(i)&&m(this,T,qt).call(this,t.FunctionDefinition)&&f.isOneOf([t.OpenParenthesis,t.Comma]))return new q(t.VariableName,a.Identifiers)}}else if(i==="sep"||i==="end")return new q(t.VariableName,a.Identifiers);return e===t.OpenParenthesis.name?m(this,T,So).call(this,c,i):(c.entity===t.R||c.entity===t.F)&&e!=="'"&&e!=='"'?new q(t.VariableName,a.Identifiers):c.category===a.Types&&n.includes(i)?new q(t.VariableName,a.Identifiers):c.category===a.BuiltInModules&&!s.includes(i)?new q(t.VariableName,a.Identifiers):c.category===a.BuiltInFunctions&&Ir(i).entity!==t.Unknown&&e!=="="?n.includes(i)?new q(t.VariableName,a.Identifiers):Ir(i):c.category===a.OtherKeywords||c.category===a.BlockDefinitions||c.category===a.LogicalOperators||c.category===a.BuiltInExceptions||c.category===a.BuiltInModules||c.category===a.Types||c.category===a.SpecialVariables||c.category===a.ComparisonOperators?c:c.category===a.Unknown&&s.includes(i)?new q(t.ModuleName,a.Identifiers):new q(t.VariableName,a.Identifiers)},So=function(i,e){return m(this,T,Io).call(this,i)||m(this,T,bo).call(this,i)?i:i.entity===t.Format?m(this,T,Rn).call(this)?new q(t.Format,a.BuiltInMethods):new q(t.FormatFunction,a.BuiltInFunctions):m(this,T,Rn).call(this)?e==="exit"?ui[e]:new q(t.MethodName,a.OtherMethods):ui.hasOwnProperty(e)?ui[e]:i.category!==a.BuiltInFunctions&&i.category!==a.BuiltInMethods&&i.category!==a.Unknown&&i.category!==a.ModuleFunctions?i:new q(t.FunctionName,a.Identifiers)},Io=function(i){return i.category===a.BuiltInFunctions&&!m(this,T,Rn).call(this)},bo=function(i){return(i.category===a.BuiltInMethods||i.category===a.MagicMethods||i.category===a.ModuleFunctions)&&m(this,T,Rn).call(this)},Rn=function(){return m(this,T,ze).call(this)&&m(this,T,xe).call(this).is(t.Dot)||!m(this,T,ze).call(this)&&u(this,Vt).length>0&&u(this,Vt)[u(this,Vt).length-1].is(t.Dot)},yo=function(i){if(u(this,_).length>=2&&u(this,_)[1].is(a.BuiltInModules)){let e=We(i);if(e.category===a.ModuleFunctions||e.category===a.ModuleProperties){const n=yr.has(e.entity)?yr.get(e.entity):void 0;return n&&m(this,T,qt).call(this,n)?e:new q(t.NamedImport,a.Identifiers)}return e.entity===t.Unknown?new q(t.NamedImport,a.Identifiers):e}return new q(t.NamedImport,a.Identifiers)},Dd=function(i,e){return new q(t.ModuleName,a.Identifiers)},Fo=function(i){for(;B.getCategory(u(this,U).charCodeAt(i))===B.Space;)i++;return u(this,U).charAt(i)},To=function(i,e,n){if(i===B.Minus&&m(this,T,ze).call(this)&&!n&&m(this,T,xe).call(this).isOneOf([a.Identifiers,t.CloseBrace,t.CloseParenthesis,t.CloseSquareBracket,a.Properties,a.ModuleProperties]))return!1;let s=0,o=0,c=0,f=e;for(;f<u(this,U).length&&(i===B.Digit||i===B.Decimal||i===B.Minus&&f===e);)i===B.Digit?s++:i===B.Decimal?o++:c++,f++,i=B.getCategory(u(this,U).charCodeAt(f));return s>=1&&o<=1&&c<=1},No=function(i){let e=i;for(let n=i+1;n<u(this,U).length;n++){const s=B.getCategory(u(this,U).charCodeAt(n));if(s===B.Digit||s===B.Decimal)e=n;else break}return u(this,U).substring(i,e+1)},Co=function(i){const e=m(this,T,No).call(this,i);return u(this,_).push(new hi(e,u(this,Ne),u(this,Ae)+i,i)),i+e.length-1},Mo=function(i){return i===B.Equals||i===B.Exclamation||i===B.Minus||i===B.Plus||i===B.Asterisk||i===B.ForwardSlash||i===B.Modulo||i===B.GreaterThan||i===B.LessThan},Oo=function(i){let e=u(this,U).charAt(i),n=e,s=i;for(;(n==="!"||We(n).entity!==t.Unknown)&&s<u(this,U).length;)e=n,s++,n+=u(this,U).charAt(s);let o=We(e);return e==="*"&&m(this,T,ze).call(this)&&m(this,T,xe).call(this).is(t.ImportKeyword)&&(o=new q(t.ImportAll,a.OtherKeywords)),u(this,_).push(Yt(e,o,u(this,Ne),u(this,Ae)+i,i)),i+e.length-1},Do=function(i){return i!==B.Space&&i!==B.Tab},xo=function(i){let e=u(this,U).charAt(i);m(this,T,Ao).call(this,e);const n=We(e);u(this,_).push(Yt(e,n,u(this,Ne),u(this,Ae)+i,i))},Bo=function(i){return i===B.Semicolon?!0:!!(i===B.Colon&&m(this,T,ze).call(this)&&u(this,_)[0].isOneOf([t.IfDefinition,t.ElifDefinition,t.ElseDefinition,t.FunctionDefinition,t.ClassDefinition,t.ForDefinition,t.WhileDefinition,t.TryDefinition,t.ExceptDefinition])&&u(this,ge)["{"]<=0&&u(this,ge)["("]<=0&&u(this,ge)["["]<=0)},Ao=function(i){u(this,ge).hasOwnProperty(i)?u(this,ge)[i]++:i===")"?u(this,ge)["("]--:i==="]"?u(this,ge)["["]--:i==="}"&&u(this,ge)["{"]--};const _n=class _n{static createTree(i){let e=i.filter(n=>!n.is(t.ContinuationLine));return m(this,D,Vo).call(this,i)?[m(this,D,Ro).call(this,i)]:(e.length>1&&(e=m(this,D,qo).call(this,e),e=m(this,D,jo).call(this,e),e=m(this,D,Eo).call(this,e),e=m(this,D,Wo).call(this,e),e=m(this,D,Ho).call(this,e),e=m(this,D,zo).call(this,e),e=m(this,D,Qo).call(this,e),e=m(this,D,Xo).call(this,e),e=m(this,D,Zo).call(this,e),e=m(this,D,_o).call(this,e)),e)}static split(i,e){return this.splitMultiple(i,[e])}static splitMultiple(i,e){const n=[];let s=0,o=0,c=0,f=0;for(let p=0;p<i.length;p++)if(p===f&&i[p].isOneOf(e))f++;else if(i[p].isOneOf(e)&&p>f||p===i.length-1){if(s===0&&o===0&&c===0||p===i.length-1&&(s===1&&i[p].is(t.CloseParenthesis)||c===1&&i[p].is(t.CloseSquareBracket)||o===1&&i[p].is(t.CloseBrace))){const w=i.slice(f,i[p].isOneOf(e)?p:p+1);n.push(w),f=p+1}}else i[p].is(t.OpenParenthesis)?s++:i[p].is(t.CloseParenthesis)?s--:i[p].is(t.OpenBrace)?o++:i[p].is(t.CloseBrace)?o--:i[p].is(t.OpenSquareBracket)?c++:i[p].is(t.CloseSquareBracket)&&c--;return n}static connectVariableUsages(i,e){var w,S;const n=e.getScope();!i.isBlank()&&i.getFirstExpression().is(t.ImportStatement)&&m(w=_n,D,Lo).call(w,i,n),i.isBlockStatement()&&!i.isBlank()&&i.getFirstExpression().is(t.ForDefinitionStatement)&&(e=m(S=_n,D,Po).call(S,e));const s=i.getVariableUsages(),o=n.getVariableMap(),c=n.findAllModules(),f=new Map(Array.from(c.values()).flatMap(F=>Array.from(F.getDirectImports()))),p=!i.isBlank()&&i.getFirstExpression().is(t.GlobalStatement);for(let[F,N]of s){if(e.getBlockEntity()===t.ClassDefinition&&N.length>0&&(N[0].getParent()===void 0||N[0].getParent().is(t.AssignmentStatement)&&N[0].getParent().getTargetVariables().includes(N[0]))){m(this,D,Ji).call(this,N[0],e.getClassType(),i,e,n);continue}let R=N.map(k=>new Tr(k,e,p));if(p&&n.addGlobalVar(F),o.has(F)){o.get(F).addUsages(R);for(const k of R){const M=k.getVariable().getParent();if(M&&M.is(t.PropertyCallExpression)&&M.getObject().getDataType().isCustom){const jt=M.getObject().getDataType();m(this,D,Ji).call(this,M.getProperty(),jt,i,e,n)}}}else{if(c.has(F))R[0].getVariable().setDataType(Bs(c.get(F).getEntity()));else if(f.has(F)){const M=Mt.has(f.get(F).entity)?Mt.get(f.get(F).entity):d.Unknown;R[0].getVariable().setDataType(M)}const k=new Fr(R[0],i,e);if(R.length>1&&k.addUsages(R.slice(1)),m(this,D,ko).call(this,e,F,k.getUsages()[0].getVariable())&&this.checkIfVariableExistsInParent(k,e))continue;o.set(F,k)}}}static makeGraphConnections(i){const e=i.filter(s=>!s.isBlank());if(e.length<=1)return;const n=e[e.length-1];if(!n.isBlank()){let s=e[e.length-2],o;if(s.isBlockStatement()){o=s.getDefinitionStatement().getExpressions();let c=s.getFirstExpression(),f=n.getFirstExpression();if(!(c.isOneOf([t.IfDefinitionStatement,t.ElifDefinitionStatement])&&f.isOneOf([t.ElseDefinitionStatement,t.ElifDefinitionStatement]))){const p=s.getExpressions();p[p.length-1].addConnection(n.getFirstExpression());const w=s.getStatements();w.length>1&&w[w.length-1].isBlockStatement()&&w[w.length-1].getDefinitionStatement().getFirstExpression().addConnection(n.getFirstExpression())}if(!f.isOneOf([t.ElifDefinitionStatement,t.ElseDefinitionStatement,t.ReturnStatement])&&c.isOneOf([t.IfDefinitionStatement,t.ElifDefinitionStatement,t.ElseDefinitionStatement])){const p=[];for(let w=e.length-2;w>=0;w--){const S=e[w].getFirstExpression();if(S.isOneOf([t.IfDefinitionStatement,t.ElifDefinitionStatement,t.ElseDefinitionStatement])&&(p.push(e[w]),S.is(t.IfDefinitionStatement)))break}for(const w of p)try{const S=w.getStatements();S[S.length-1].getFirstExpression().addConnection(n.getFirstExpression())}catch(S){console.log(S),console.log(w)}}}else o=s.getExpressions();o[0].addConnection(n.getFirstExpression())}}static connectUserDefinedFunctions(i,e){const n=e.findAllFunctions(),s=e.getRootBlock().getUserDefinedClasses(),o=i.getExpressions();for(let c of o){const f=c.getExpressionsOfKind(t.UserDefinedFunctionCall);for(let p of f){const w=p.getFunctionName();if(n.has(w)){const S=n.get(w);p.setDataType(S.getDataType()),S.addObserver(p)}else if(s.has(w)){const S=s.get(w);p.setDataType(S)}else e.addUnconnectedFunctionCall(p)}}}static connectUserDefinedMethods(i,e){const n=e.findAllFunctions();for(const[o,c]of n.entries())c.is(t.MethodName)||n.delete(o);const s=i.getExpressions();for(let o of s){const c=o.getExpressionsOfKind(t.UserDefinedMethodCall);for(let f of c){const p=f.getMethodName();if(n.has(p)){const w=n.get(p);f.setDataType(w.getDataType()),w.addObserver(f)}else e.addUnconnectedMethodCall(f)}}}static checkIfVariableExistsInParent(i,e){let n=e.getScope().getParentBlock();const s=i.getUsages()[0].getVariable();if(!i.isParameter()&&(e.getScope().getGlobalVars().has(i.getName())||!s.isAssignedOrChanged()||s.isObjectOfMethodCall()||s.isSubscripted()))for(;n!==void 0&&n.getScope()!==void 0;){const o=n.getScope().getVariableMap();if(o.has(i.getName())){const c=o.get(i.getName());i.setDefinedInBlock(c.getDefinedInBlock());const f=c.getUsages();return i.insertUsages(f),!0}n=n.getScope().getParentBlock()}return!1}static checkForListComp(i){const e=this.split(i,t.Comma);let n=[];for(let s=0;s<e.length;s++)s<e.length-1&&En(e[s],t.ForDefinition)&&En(e[s+1],t.InKeyword)?(n.push(e[s].concat(i[n.length+e[s].length],e[s+1])),s++):n.push(e[s]);return n}};D=new WeakSet,Ji=function(i,e,n,s,o){const c=i.getTextValue(),f=new Tr(i,s);if(e.attributes.has(c))e.attributes.get(c).addUsage(f);else{const p=o.getNearestParentOfAny([t.ClassDefinition]),w=new Fr(f,n,s);p&&p.getClassType().name===e.name?e.attributes.set(c,w):console.log("add to unconnected attribute tracking")}},ko=function(i,e,n){let s=i.getScope();for(;s!==void 0;){if(s.getVariableMap().has(e)){if(!n.isAssignedOrChanged()||n.isObjectOfMethodCall()||n.isSubscripted())return!0}else if(s.getGlobalVars().has(e))return!0;s=s.getParentBlock(),s!==void 0&&(s=s.getScope())}return!1},Po=function(i){const e=i.getChildBlocks();return e.length>0&&e[e.length-1].getBlockEntity()===t.ForDefinition&&(i=e[e.length-1]),i},Lo=function(i,e){const n=i.getRawExpressions(),s=e.getModuleMap(),o=[];let c=!1;for(const f of n)if(f.isOneOf([t.ModuleName,a.BuiltInModules]))if(c)for(const p of o)p.getEntity()===f.getEntity()&&p.setAlias(f.getTextValue());else{const p=new jc(f.getTextValue(),f.getEntity());o.push(p)}else if(f.is(t.AsKeyword))c=f;else if(f.isOneOf([a.ModuleProperties,t.NamedImport]))for(const p of o)p.addDirectImport(f.getTextValue(),qc(f.getEntity(),f.getCategory()));else if(f.is(t.ImportAll))for(const p of o)p.setImportAll();for(const f of o)s.set(f.getAlias(),f)},Vo=function(i){return i.length>0&&i[0].is(a.BlockDefinitions)&&!m(this,D,vo).call(this,i)},vo=function(i){if(i.length===1)return!1;const e=Zt(i,t.AssignmentOperator);return e===-1?!1:e===1?!0:!!(i[1].is(t.Comma)&&e%2===1)},Ro=function(i){const e=oe(i);switch(i[0].getEntity()){case t.FunctionDefinition:return m(this,D,Uo).call(this,e,i);case t.IfDefinition:return new nt(e,i,t.IfDefinitionStatement);case t.ElifDefinition:return new nt(e,i,t.ElifDefinitionStatement);case t.WhileDefinition:return new nt(e,i,t.WhileDefinitionStatement);case t.ForDefinition:return new nt(e,i,t.ForDefinitionStatement);case t.ExceptDefinition:return new nt(e,i,t.ExceptDefinitionStatement);case t.ElseDefinition:return new nt(e,i,t.ElseDefinitionStatement);case t.TryDefinition:return new nt(e,i,t.TryDefinitionStatement);case t.FinallyDefinition:return new nt(e,i,t.FinallyDefinitionStatement);case t.ClassDefinition:return new Zc(e,i);case t.LambdaDefinition:return new gu(e,i);case t.WithKeyword:return new nt(e,i,t.WithDefinitionStatement);default:return i}},Uo=function(i,e){return e.length<2||e[1].is(t.FunctionName)?new Qc(i,e):new Xc(i,e)},Eo=function(i){let e=m(this,D,Ki).call(this,i);if(e.sort((o,c)=>o[0]-c[0]),e.length===0)return i;let n=i,s;for(;e.length>0&&(s===void 0||e.length!==s.length);){const o=n[e[0][0]];o.is(t.OpenParenthesis)?n=m(this,D,Go).call(this,e[0],n):o.is(t.OpenSquareBracket)?n=m(this,D,$o).call(this,e[0],n):n=m(this,D,Ko).call(this,e[0],n),s=e,e=m(this,D,Ki).call(this,n),e.sort((c,f)=>c[0]-f[0])}return n},Ki=function(i){let e=[],n=[];for(let s=0;s<i.length;s++)if(Sr(i[s].getEntity()))n.push({openEntity:i[s].getEntity(),closeEntity:mc(i[s].getEntity()),openIndex:s,closeIndex:-1});else if(pc(i[s].getEntity())){let o=n.length-1;for(;o>=0;){if(n[o].closeEntity===i[s].getEntity()){n[o].closeIndex=s,e.push([n[o].openIndex,n[o].closeIndex]),n.splice(o,1);break}o--}}return e},Go=function(i,e){const n=i[0],s=i[1];if(n>0&&e[n-1].isOneOf([a.BuiltInFunctions,t.FunctionName])){const c=e[n-1].is(a.BuiltInFunctions)?t.BuiltInFunctionCall:t.UserDefinedFunctionCall,f=m(this,D,fe).call(this,e.slice(n-1,s+1),c);return e.slice(0,n-1).concat([f],e.slice(s+1))}else if(n>2&&e[n-1].isOneOf([a.BuiltInMethods,t.MethodName,a.MagicMethods,a.ModuleFunctions])&&e[n-2].is(t.Dot)){const c=e[n-1].is(t.MethodName)&&!e[n-1].is(a.ModuleFunctions)?t.UserDefinedMethodCall:t.BuiltInMethodCall,f=m(this,D,fe).call(this,e.slice(n-3,s+1),c);return e.slice(0,n-3).concat([f],e.slice(s+1))}else if(n>0&&e[n-1].is(t.ExceptionName)){const c=m(this,D,fe).call(this,e.slice(n-1,s+1),t.ExceptionCall);return e.slice(0,n-1).concat([c],e.slice(s+1))}else if(s>n+1){const c=e.slice(n+1,s),f=this.split(c,t.Comma);if(f.length>1){const p=m(this,D,fe).call(this,e.slice(n,s+1),t.TupleDefinition,f);return e.slice(0,n).concat([p],e.slice(s+1))}}const o=m(this,D,fe).call(this,e.slice(n,s+1),t.GroupStatement);return e.slice(0,n).concat([o],e.slice(s+1))},$o=function(i,e){const n=i[0],s=i[1];let o=[],c=[];if(s>n+1&&(c=e.slice(n+1,s),o=this.checkForListComp(c)),n===0||o.length===0||e[n-1].isOneOf([a.ComparisonOperators,a.LogicalOperators,a.MathsOperators,t.OpenParenthesis,t.OpenSquareBracket,t.OpenBrace,t.Comma,t.Colon,t.Separator,a.OtherKeywords,t.ContinuationLine])){const f=m(this,D,fe).call(this,e.slice(n,s+1),t.ListDefinition,o);return e.slice(0,n).concat([f],e.slice(s+1))}else{let f=this.split(c,t.Colon);const p=m(this,D,Jo).call(this,f,e,n,s)?m(this,D,fe).call(this,e.slice(n,s+1),t.Slice,f):m(this,D,fe).call(this,e.slice(n,s+1),t.IndexKey);let w=n-1;for(;w>=0&&!e[w].isOneOf([a.Identifiers,a.BuiltInFunctions,a.CompoundTypes,t.BuiltInFunctionCall,t.BuiltInMethodCall,t.UserDefinedFunctionCall,t.UserDefinedMethodCall,t.SubscriptedExpression,t.PropertyCallExpression]);)w--;w=Math.max(w,0);const S=m(this,D,fe).call(this,[...e.slice(w,n),p],t.SubscriptedExpression);return e.slice(0,w).concat([S],e.slice(s+1))}},Jo=function(i,e,n,s){return i.length>1||e[n+1].is(t.Colon)||e[s-1].is(t.Colon)},Ko=function(i,e){const n=i[0],s=i[1];let o;if(s===n+1)o=m(this,D,fe).call(this,e.slice(n,s+1),t.DictDefinition);else{const c=e.slice(n+1,s),f=this.split(c,t.Comma),p=[];for(let w of f){const S=this.split(w,t.Colon);S.length===2&&p.push(S)}p.length===f.length?o=m(this,D,fe).call(this,e.slice(n,s+1),t.DictDefinition,p):o=m(this,D,fe).call(this,e.slice(n,s+1),t.SetDefinition,f)}return e.slice(0,n).concat([o],e.slice(s+1))},fe=function(i,e,n=[]){const s=oe(i);switch(e){case t.BuiltInFunctionCall:return new Yc(s,i);case t.UserDefinedFunctionCall:return new _c(s,i);case t.BuiltInMethodCall:return new tu(s,i);case t.UserDefinedMethodCall:return new nu(s,i);case t.ExceptionCall:return new eu(s,i);case t.TupleDefinition:case t.ListDefinition:case t.SetDefinition:case t.DictDefinition:return new Rs(s,i,e,n);case t.GroupStatement:return new fu(s,i);case t.Slice:return new Vr(s,i,n);case t.IndexKey:return new vr(s,i);case t.SubscriptedExpression:return new Us(s,i);case t.CalculatedExpression:return new Es(s,i);case t.ComparisonExpression:return new pi(s,i);case t.IteratorExpression:return new wi(s,i);case t.BooleanExpression:return new mi(s,i);default:throw new Error("Unknown multipart expression type")}},Wo=function(i){let e=m(this,D,Wi).call(this,i);for(;e>-1;){const n=e>0&&!i[e-1].isOneOf([a.MathsOperators,a.LogicalOperators,a.ComparisonOperators,a.OtherKeywords])?e-1:e,s=m(this,D,fe).call(this,i.slice(n,e+2),t.CalculatedExpression);i=i.slice(0,n).concat([s],i.slice(e+2)),e=m(this,D,Wi).call(this,i)}return i},jo=function(i){if(i.length<3)return i;let e=1;for(;e<i.length-1;)if(i[e].is(t.Dot)&&i[e+1].isOneOf([t.PropertyName,a.ModuleProperties])){const n=oe([i[e-1],i[e],i[e+1]]),s=new Dr(n,[i[e-1],i[e],i[e+1]],t.PropertyCallExpression,a.MultipartValue);i=i.slice(0,e-1).concat([s],i.slice(e+2)),e--}else if(i[e].is(t.Dot)&&!i[e+1].isOneOf([t.PropertyName,a.ModuleProperties])&&(e+2>=i.length||!i[e+2].isOneOf([t.OpenParenthesis]))){const n=oe([i[e-1],i[e],i[e+1]]),s=new Dr(n,[i[e-1],i[e],i[e+1]],t.PropertyCallExpression,a.MultipartValue);i=i.slice(0,e-1).concat([s],i.slice(e+2)),e--}else e++;return i},qo=function(i){if(i.length<2)return i;let e=0;for(;e<i.length-1;)if(i[e].isStringLiteral()&&i[e+1].isStringLiteral()){const n=oe([i[e],i[e+1]]),s=new ru(n,[i[e],i[e+1]]);i=i.slice(0,e).concat([s],i.slice(e+2))}else e++;return i},Wi=function(i){const e=[],n=[];for(let s=0;s<i.length;s++){if(i[s].is(t.ExponentOperator))return s;i[s].isOneOf([t.MultiplyOperator,t.DivideOperator,t.IntDivideOperator,t.ModulusOperator])?e.push(s):i[s].isOneOf([t.AddOperator,t.SubtractOperator])&&n.push(s)}return e.length>0?e[0]:n.length>0?n[0]:-1},Ho=function(i){let e=m(this,D,ji).call(this,i);for(;e>0;){let n=e-1,s;i[e].is(t.InKeyword)&&n>1&&i[n-1].is(t.Comma)?(n=n-2,s=m(this,D,fe).call(this,i.slice(n,e+2),t.IteratorExpression)):i[e].is(t.InKeyword)&&e===1&&e+1<i.length&&i[e+1].is(t.BuiltInFunctionCall)&&i[e+1].getFunctionExpression().isOneOf([t.EnumerateFunction])?(n=0,s=m(this,D,fe).call(this,i.slice(n,e+2),t.IteratorExpression)):s=m(this,D,fe).call(this,i.slice(n,e+2),t.ComparisonExpression),i=i.slice(0,n).concat([s],i.slice(e+2)),e=m(this,D,ji).call(this,i)}return i},ji=function(i){for(let e=0;e<i.length;e++)if(i[e].is(a.ComparisonOperators))return e;return-1},zo=function(i){let e=m(this,D,qi).call(this,i);for(;e>-1;){const s=(i[e].is(t.NotOperator)?2:3)===2?e:e-1,o=s>=0?i.slice(s,e+2):i.slice(e,e+2),c=m(this,D,fe).call(this,o,t.BooleanExpression);i=s>=0?i.slice(0,s).concat([c],i.slice(e+2)):i.slice(0,e).concat([c],i.slice(e+2)),e=m(this,D,qi).call(this,i)}return i},qi=function(i){let e=[],n=[];for(let s=0;s<i.length;s++){if(i[s].is(t.NotOperator))return s;i[s].is(t.AndOperator)?e.push(s):i[s].is(t.OrOperator)&&n.push(s)}return e.length>0?e[0]:n.length>0?n[0]:-1},Qo=function(i){let e=Zt(i,t.IfDefinition);for(;e>-1&&i.length>=e+3&&i[e+2].is(t.ElseDefinition);){const s=i.slice(e-1,e+4),o=oe(s),c=new Si(o,s);i=i.slice(0,e-1).concat([c],i.slice(e+4)),e=Zt(i,t.IfDefinition)}return i},Xo=function(i){for(;i.length>=3&&i[1].is(t.ForDefinition);){const e=i.length>=5&&i[3].is(t.IfDefinition),n=i.slice(0,e?5:3),s=oe(n);n[2].is(t.ComparisonExpression)&&(n[2]=i[2].convertToIterator()),i=[new Ii(s,n)].concat(i.slice(e?5:3))}return i},Zo=function(i){let e=m(this,D,Hi).call(this,i);for(;e>-1;){const n=m(this,D,Yo).call(this,i,e-1),s=i.slice(n),o=oe(s),c=i[e].is(t.AssignmentOperator)?new Lr(o,s):new hu(o,s);i=i.slice(0,n).concat([c]),e=m(this,D,Hi).call(this,i)}return i},Yo=function(i,e){let n=-1;for(let s=e;s>=0&&!(i[s].isChangeOperator()||i[s].isOneOf([a.OtherKeywords,a.BlockDefinitions]));s--)n=s;return Math.max(n,0)},Hi=function(i){for(let e=i.length-1;e>0;e--)if(i[e].isChangeOperator())return e;return-1},_o=function(i){return i.length>0&&(i[0].is(t.ReturnKeyword)?i=[new pu(oe(i),i)]:i[0].isOneOf([t.ImportKeyword,t.FromKeyword])?i=[new mu(oe(i),i)]:i[0].isOneOf([t.GlobalKeyword,t.AssertKeyword,t.RaiseKeyword])&&(i=[new wu(oe(i),i)])),i},I(_n,D);let K=_n;function Yt(g,i,e,n,s,o=n+g.length,c=e){switch(i.entity){case t.ExceptionName:return new uu(g,i.entity,i.category,e,n,s);case t.VariableName:return new _t(g,i.entity,i.category,e,n,s);case t.FunctionName:return new Pr(g,i.entity,i.category,e,n,s);case t.MethodName:return new ou(g,i.entity,i.category,e,n,s);case t.ClassName:return new du(g,i.entity,i.category,e,n,s);case t.PropertyName:return new fi(g,i.entity,i.category,e,n,s);case t.ModuleName:return new Ar(g,i.entity,i.category,e,n,s);case t.StringLiteral:return new xr(g,e,n,s,o,c);case t.TrueType:case t.FalseType:case t.NoneType:return new lu(g,i.entity,i.category,e,n,s);case t.ListDefinition:case t.TupleDefinition:case t.SetDefinition:case t.DictDefinition:return new Rs(g,[],i.entity,[]);case t.IndexKey:return new vr(g,[]);case t.Slice:return new Vr(g,[],[]);case t.NamedImport:return new fi(g,i.entity,i.category,e,n,s)}switch(i.category){case a.BuiltInFunctions:case a.BuiltInMethods:case a.ModuleFunctions:case a.MagicMethods:return new au(g,i.entity,i.category,e,n,s);case a.BuiltInModules:return new Ar(g,i.entity,i.category,e,n,s);case a.Types:return new cu(g,i.entity,i.category,e,n,s);case a.SpecialVariables:return new _t(g,i.entity,i.category,e,n,s);case a.ModuleProperties:return new fi(g,i.entity,i.category,e,n,s);case a.LogicalOperators:case a.MathsOperators:case a.ComparisonOperators:case a.OtherKeywords:case a.BlockDefinitions:case a.Other:case a.TypeHint:return new Br(g,i.entity,i.category,e,n,s);default:return new Qe(g,i.entity,i.category,e,n,s,d.Unknown)}}class Qe extends Ls{constructor(e,n,s,o,c,f,p=d.NotParsed,w=c+e.length-1,S=o){super();I(this,mt);I(this,wt);I(this,St);I(this,rt);I(this,dn);I(this,hn);I(this,fn);I(this,es);I(this,gn);I(this,Se);I(this,Rt,"unknown");I(this,pn,"unknown");I(this,ts,[]);if(w<c)throw new Error("Could not create expression: end index cannot be less than start index");y(this,mt,e),y(this,wt,n),y(this,St,s),y(this,dn,o),y(this,fn,c),y(this,es,f),y(this,gn,w),y(this,hn,S),y(this,Se,p)}getTextValue(){return u(this,mt)}setTextValue(e){y(this,mt,e)}getEntity(){return u(this,wt)}setEntity(e){y(this,wt,e)}getCategory(){return u(this,St)}setCategory(e){y(this,St,e)}getStartLineNumber(){return u(this,dn)}getEndLineNumber(){return u(this,hn)}setEndLineNumber(e){y(this,hn,e)}getDocumentStartIndex(){return u(this,fn)}getIndexOnLine(){return u(this,es)}getDocumentEndIndex(){return u(this,gn)}setDocumentEndIndex(e){y(this,gn,e)}getDataType(){return u(this,Se)}setDataType(e){e!==u(this,Se)&&(y(this,Se,e),super.sendUpdate(e))}setBlockId(e){u(this,Rt)!==e&&y(this,Rt,e)}getBlockId(){return u(this,Rt)==="unknown"&&u(this,rt)!==void 0?u(this,rt).getBlockId():u(this,Rt)}setScopeId(e){u(this,pn)==="unknown"&&y(this,pn,e)}getScopeId(){return u(this,pn)}typeUpdateReceived(e){this.setDataType(e)}getParent(){return u(this,rt)}setParent(e){y(this,rt,e)}hasParentOfKind(e){let n=this.getParent();for(;n!==void 0;)if(n.is(e))return!0;return!1}getContextOfUse(){return u(this,rt)===void 0?"none":u(this,rt).getEntity().name}contains(e){return this===e}is(e){return u(this,wt)===e||u(this,St)===e||u(this,mt)===e}isOneOf(e){try{for(let n of e)if(this.is(n))return!0}catch{try{return this.is(e)}catch{return!1}}return!1}isSubscriptable(){return!1}isNumeric(){return u(this,Se)===d.Int||u(this,Se)===d.Float||u(this,Se)===d.Number||u(this,Se)===d.Bool}isIntLike(){return u(this,Se)===d.Int||u(this,Se)===d.Bool}isNonFloatNumeric(){return this.isIntLike()||u(this,Se)===d.Number}isChangeOperator(){return this.isOneOf([t.AssignmentOperator,t.IncrementOperator,t.DecrementOperator,t.MultiplyAssignOperator,t.DivideAssignOperator,t.ExponentAssignOperator,t.IntDivideAssignOperator,t.RemainderAssignOperator])}matchesPattern(e){return this.getTextValue()===e.getTextValue()&&this.getEntity()===e.getEntity()}isStringLiteral(){return!1}hasChildExpressions(){return!1}getExpressionsOfKind(e){const n=[];return this.is(e)&&n.push(this),n}getFirstExpressionOf(e){if(this.isOneOf(e))return this}getVariableExpressions(){return[]}getAllNestedExpressions(){return[this]}checkForSymptoms(){this.checkRules(this)}getConnectedTo(){return u(this,ts)}addConnection(e){u(this,ts).push(e)}toJSON(){return{entity:u(this,wt).name,category:u(this,St).name,textValue:u(this,mt),dataType:u(this,Se).name,lineNumber:u(this,dn),docIndex:u(this,fn)}}}mt=new WeakMap,wt=new WeakMap,St=new WeakMap,rt=new WeakMap,dn=new WeakMap,hn=new WeakMap,fn=new WeakMap,es=new WeakMap,gn=new WeakMap,Se=new WeakMap,Rt=new WeakMap,pn=new WeakMap,ts=new WeakMap;class Y extends Qe{constructor(e,n,s,o,c=d.NotParsed){super(e,s,o,n.length>0?n[0].getStartLineNumber():-1,n.length>0?n[0].getDocumentStartIndex():-1,n.length>0?n[0].getIndexOnLine():-1,c,n.length>0?n[n.length-1].getDocumentEndIndex():-1,n.length>0?n[n.length-1].getEndLineNumber():-1);I(this,Js);I(this,ke);y(this,ke,n),m(this,Js,ea).call(this,u(this,ke))}isSubscriptable(){return As(this.getDataType())}hasChildExpressions(){return u(this,ke).length>0}getVariableExpressions(){let e=[];for(let n of u(this,ke))n.getTextValue()!=="Placeholder"&&(e=e.concat(n.getVariableExpressions()));return e}matchesPattern(e){return this.getEntity()===e.getEntity()}getExpressionsOfKind(e){let n=super.getExpressionsOfKind(e);for(let s of u(this,ke))s.is(e)?n.push(s):n=n.concat(s.getExpressionsOfKind(e));return n}getFirstExpressionOf(e){let n=super.getFirstExpressionOf(e);if(n===void 0)for(const s of u(this,ke)){if(s.isOneOf(e))return s;if(n=s.getFirstExpressionOf(e),n!==void 0)return n}return n}contains(e){if(super.contains(e))return!0;for(let n of u(this,ke))if(n.contains(e))return!0;return!1}checkForSymptoms(){this.checkRules(this);for(const e of this.getChildren())e.checkForSymptoms()}checkForConstructs(e){super.checkForConstructs(this);for(const n of this.getChildren())n.checkForConstructs(n)}setBlockId(e){super.setBlockId(e);for(const n of this.getChildren())n.setBlockId(e)}setScopeId(e){super.setScopeId(e);for(const n of this.getChildren())n.setScopeId(e)}getChildren(){return u(this,ke)}setChildren(e){y(this,ke,e)}addChild(e){u(this,ke).push(e)}isComplete(){return this.hasChildExpressions()}}ke=new WeakMap,Js=new WeakSet,ea=function(e){for(const n of e)n.setParent(this)};const ss=class ss extends Y{constructor(e,n,s){var p;const o=m(p=ss,wn,sa).call(p,n);super(e,o,s,a.BlockDefinitionStatement,d.NA);I(this,mn);I(this,pe);I(this,ns,0);const c=3,f=o.length-3;if(f<c)y(this,pe,[]);else{const w=o.slice(c,f+1);y(this,pe,K.split(w,t.Comma)),m(this,mn,ia).call(this)}this.addRule(m(this,mn,ta))}isComplete(){const e=this.getChildren();return e.length>=5&&e[0].is(t.FunctionDefinition)&&e[1].isOneOf([t.FunctionName,t.MethodName])&&e[2].is(t.OpenParenthesis)&&e[e.length-2].is(t.CloseParenthesis)&&e[e.length-1].is(t.Colon)&&ci(e,t.OpenParenthesis,t.CloseParenthesis)}getVariableExpressions(){let e=[];for(let n of u(this,pe))for(let s of n)s.is(t.VariableName)?e.push(s):e=e.concat(s.getVariableExpressions());return e}getExpressionsOfKind(e){let n=super.getExpressionsOfKind(e);for(let s of u(this,pe))for(const o of s)o.is(e)?n.push(o):n=n.concat(o.getExpressionsOfKind(e));return n}getFirstExpressionOf(e){let n=super.getFirstExpressionOf(e);if(n===void 0)for(const s of u(this,pe)){if(s.isOneOf(e))return s;if(n=s.getFirstExpressionOf(e),n!==void 0)return n}return n}checkForSymptoms(){this.checkRules(this);for(const e of u(this,pe))for(const n of e)n.checkForSymptoms()}getParameters(){return u(this,pe)}getOptionalParameterCount(){return u(this,ns)}};pe=new WeakMap,ns=new WeakMap,mn=new WeakSet,ta=function(e){const n=[],s=e.getChildren();if(s.length>1){const o=We(s[1].getTextValue()).category;(o===a.BlockDefinitions||o===a.LogicalOperators||o===a.Types||o===a.OtherKeywords)&&n.push(O.createStatementSymptom(b.DefinitionFollowedByReservedWord,s,0,1,{definitionType:s[0].getTextValue(),reservedWord:s[1].getTextValue()}))}return n},wn=new WeakSet,na=function(e){let n=-1,s=-1,o=0;for(let c=0;c<e.length;c++)if(e[c].is(t.OpenParenthesis))o++,n===-1&&(n=c);else if(e[c].is(t.CloseParenthesis)&&(o--,o===0)){s=c;break}return[n,s]},sa=function(e){var c;let s=m(c=ss,wn,na).call(c,e)[1]+1,o=-1;for(;s<e.length;){if(e[s].is(t.Colon)){o>=0&&e.splice(o,s-o);break}else e[s].is(t.TypeHintReturn)&&(o=s);s++}return e},ia=function(){for(let e=0;e<u(this,pe).length;e++){if(u(this,pe)[e]=K.createTree(u(this,pe)[e]),u(this,pe)[e].length>1){const n=K.split(u(this,pe)[e],t.Colon);u(this,pe)[e]=n[0]}for(let n of u(this,pe)[e])if(n.is(t.VariableName))n.setDataType(d.Unknown),n.setAssignedOrChanged(),n.setIsParameter();else if(n.is(t.AssignmentStatement)){const s=n.getVariableExpressions();ei(this,ns)._++;for(let o of s)o.setDataType(d.Unknown),o.setAssignedOrChanged(),o.setIsParameter()}}},I(ss,wn);let Vs=ss;class Qc extends Vs{constructor(i,e){if(super(i,e,t.FunctionDefinitionStatement,a.BlockDefinitionStatement,d.NA),this.addConnection(this.getFunctionNameExpression()),this.getFunctionNameExpression()!==void 0){this.getFunctionNameExpression().addConnection(this);for(const n of this.getParameters())for(const s of n)this.getFunctionNameExpression().addConnection(s)}}isComplete(){return super.isComplete()&&this.getChildren()[1].is(t.FunctionName)}getFunctionNameExpression(){return this.getChildren()[1]}getConnectedTo(){return this.getFunctionNameExpression().getConnectedTo()}addConnection(i){this.getFunctionNameExpression()!==void 0&&this.getFunctionNameExpression().addConnection(i)}getAllNestedExpressions(){try{return[...super.getAllNestedExpressions(),...this.getFunctionNameExpression().getAllNestedExpressions(),...this.getParameters().flatMap(e=>e.flatMap(n=>n.getAllNestedExpressions()))]}catch{return[]}}toJSON(){const i=super.toJSON();return i.functionName=this.getFunctionNameExpression().getTextValue(),i.parameters=this.getParameters().map(e=>e.map(n=>n.toJSON())),i}}class Xc extends Vs{constructor(e,n){super(e,n,t.MethodDefinitionStatement,a.BlockDefinitionStatement,d.NA);I(this,is);const s=super.getParameters();s.length>0&&y(this,is,s[0][0]),this.addConnection(this.getMethodNameExpression()),this.getMethodNameExpression().addConnection(this);for(const o of this.getParameters())for(const c of o)this.getMethodNameExpression().addConnection(c)}isComplete(){return super.isComplete()&&this.getChildren()[1].is(t.MethodName)}getMethodNameExpression(){return this.getChildren()[1]}getParameters(){return super.getParameters().slice(1)}getClassVar(){return u(this,is)}getConnectedTo(){return this.getMethodNameExpression().getConnectedTo()}addConnection(e){this.getMethodNameExpression().addConnection(e)}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...this.getMethodNameExpression().getAllNestedExpressions(),...this.getParameters().flatMap(n=>n.flatMap(s=>s.getAllNestedExpressions()))]}toJSON(){const e=super.toJSON();return e.methodName=this.getMethodNameExpression().getTextValue(),e.parameters=this.getParameters().map(n=>n.map(s=>s.toJSON())),e}}is=new WeakMap;class Zc extends Y{constructor(i,e){super(i,e,t.ClassDefinitionStatement,a.BlockDefinitionStatement,e.length>=2&&e[1].is(t.ClassName)?d.createCustomType(e[1].getTextValue()):d.Class)}isComplete(){return super.isComplete()&&this.getChildren()[1].is(t.ClassName)}getAllNestedExpressions(){return super.getAllNestedExpressions()+[this.getChildren()[1]]}getClassNameExpression(){return this.getChildren()[1]}toJSON(){const i=super.toJSON();return i.className=this.getClassNameExpression().getTextValue(),i}}const Ks=class Ks extends Y{constructor(e,n,s,o){super(e,n,s,o);I(this,Ce);I(this,ue);if(m(this,Ce,ni).call(this),this.isComplete()){const f=n.length-2;if(f<2)y(this,ue,[]);else{const p=n.slice(2,f+1);y(this,ue,K.checkForListComp(p));for(let w=0;w<u(this,ue).length;w++)u(this,ue)[w].length>1&&(u(this,ue)[w]=K.createTree(u(this,ue)[w]))}}else y(this,ue,[]);m(this,Ce,oa).call(this),this.addRules([m(this,Ce,la),m(this,Ce,aa)]),m(this,Ce,ra).call(this)}isComplete(){const e=this.getChildren();return e.length>=3&&e[0].isOneOf([a.BuiltInFunctions,t.FunctionName])&&e[1].is(t.OpenParenthesis)&&e[e.length-1].is(t.CloseParenthesis)&&ci(e,t.OpenParenthesis,t.CloseParenthesis)}addChild(e){super.addChild(e),m(this,Ce,ni).call(this)}setChildren(e){super.setChildren(e),m(this,Ce,ni).call(this)}getVariableExpressions(){let e=[];for(let n of u(this,ue))for(let s of n)s.is(t.VariableName)?e.push(s):e=e.concat(s.getVariableExpressions());return e}getExpressionsOfKind(e){let n=super.getExpressionsOfKind(e);if(this.getChildren()[0].is(e))return[this.getChildren()[0]];for(let s of u(this,ue))for(let o of s)o.is(e)?n.push(o):n=n.concat(o.getExpressionsOfKind(e));return n}getFirstExpressionOf(e){let n=super.getFirstExpressionOf(e);if(this.getChildren()[0].isOneOf(e))return this.getChildren()[0];if(n===void 0)for(const s of u(this,ue)){if(s.isOneOf(e))return s;if(n=s.getFirstExpressionOf(e),n!==void 0)return n}return n}checkForSymptoms(){this.checkRules(this);for(const e of u(this,ue))for(const n of e)n.checkForSymptoms()}matchesPattern(e){return super.matchesPattern(e)&&this.getFunctionName()===e.getFunctionName()&&this.getTextValue()===e.getTextValue()}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...this.getFunctionExpression().getAllNestedExpressions(),...u(this,ue).flatMap(n=>n.flatMap(s=>s.getAllNestedExpressions()))]}toJSON(){const e=super.toJSON();return e.functionName=this.getFunctionName(),e.arguments=this.getArguments().map(n=>n.map(s=>s.toJSON())),e}getFunctionEntity(){const e=this.getChildren();if(e.length<1)throw new Error("No function expression available");return e[0].getEntity()}getFunctionName(){const e=this.getChildren();if(e.length<1)throw new Error("No function expression available");return e[0].getTextValue()}getFunctionExpression(){const e=this.getChildren();if(e.length<1)throw new Error("No function expression available");return e[0]}getArguments(){return u(this,ue)}};ue=new WeakMap,Ce=new WeakSet,ra=function(){for(const e of u(this,ue))for(const n of e)n.addConnection(this);this.addConnection(this.getFunctionExpression())},oa=function(){for(const e of u(this,ue))for(const n of e)n.setParent(this)},ni=function(){this.getChildren()[0].addObserver(this),this.isComplete()?Di(Ks.prototype,this,"setDataType").call(this,this.getChildren()[0].getDataType()):Di(Ks.prototype,this,"setDataType").call(this,d.NotParsed)},aa=function(e){const n=[];return e.getDataType()!==d.None&&(e.getParent()===void 0||e.getParent().is(t.GroupStatement)&&e.getParent().getParent()===void 0)&&(e.is(t.BuiltInFunctionCall)||e.getFunctionExpression().getReturnStatements().length>0)&&n.push(O.createStatementSymptom(b.UnusedReturn,[e],0,0,{expression:e.getFunctionExpression()})),n},la=function(e){const n=[],s=e.getArguments();for(const o of s){const f=o.flatMap(p=>p.is(t.GroupStatement)?p.getContents():p).filter(p=>Ct(p)||p.getDataType()===d.None&&!p.isOneOf([t.NoneType,t.VariableName]));f.length>0&&n.push(...f.map(p=>O.createStatementSymptom(b.AssignedNone,[p],0,0,{expression:p,usage:e.getFunctionEntity()===t.PrintFunction?"print":wr})))}return n};let vs=Ks;class Yc extends vs{constructor(e,n){super(e,n,t.BuiltInFunctionCall,a.FunctionCall);I(this,Ws);n.length>0&&n[0].isOneOf([t.StrFunction,t.IntFunction,t.FloatFunction,t.BoolFunction,t.ListFunction,t.TupleFunction,t.SetFunction,t.DictFunction])&&this.addRule(m(this,Ws,ca))}isComplete(){return super.isComplete()&&this.getChildren()[0].is(a.BuiltInFunctions)}convertToUserDefinedFunction(e){this.setEntity(t.UserDefinedFunctionCall);const n=this.getChildren()[0];n.setEntity(t.FunctionName),n.setCategory(a.Identifiers),n.setDataType(e.getReturnType()),n.addReturns=(s,o=!1)=>e.addReturns(s,o),n.getReturnType=()=>e.getReturnType(),n.getReturnStatements=()=>e.getReturnStatements()}}Ws=new WeakSet,ca=function(e){const n=[],s=e.getDataType(),o=e.getArguments(),c=e.getChildren();return o.length===1&&o[0].length===1&&(o[0][0].getDataType()===s||s===d.List&&o[0][0].getDataType()===d.String)&&n.push(O.createStatementSymptom(b.TypeUnnecessary,c,0,c.length-1,{convertedValue:o[0][0].getTextValue(),argType:o[0][0].getDataType().name,convertedType:s.name})),n};class _c extends vs{constructor(i,e){super(i,e,t.UserDefinedFunctionCall,a.FunctionCall);const n=this.getFunctionExpression(),s=this.getArguments();if(s.length>0&&n.getParent().is(a.FunctionCall)&&s.length<=n.getParent().getArguments().length){const o=n.getParent().getArguments();for(let c=0;c<s.length;c++)s[c][0].addConnection(o[c][0])}}isComplete(){return super.isComplete()&&this.getChildren()[0].is(t.FunctionName)}convertToImportedFunction(){this.setEntity(t.BuiltInFunctionCall);const i=this.getChildren()[0];i.setEntity(t.Unknown),i.setCategory(a.ModuleFunctions),i.setDataType(d.Unknown)}}class eu extends Y{constructor(i,e){super(i,e,t.ExceptionCall,a.ExceptionCall,d.Exception)}isComplete(){return super.isComplete()&&this.getChildren()[0].is(a.BuiltInExceptions)}getAllNestedExpressions(){return this.getChildren()[0].getAllNestedExpressions()}}class Or extends Y{constructor(e,n,s,o){super(e,n,s,o);I(this,Ie);I(this,de);if(m(this,Ie,Ds).call(this),this.isComplete()){const f=n.length-2;if(f<4)y(this,de,[]);else{let p=n.slice(4,f+1);y(this,de,K.checkForListComp(p));for(let w=0;w<u(this,de).length;w++)u(this,de)[w].length>1&&(u(this,de)[w]=K.createTree(u(this,de)[w]))}}else y(this,de,[]);m(this,Ie,da).call(this),m(this,Ie,ua).call(this),this.addRules([m(this,Ie,fa),m(this,Ie,ha)])}isComplete(){const e=this.getChildren();return e.length>=5&&e[1].is(t.Dot)&&e[3].is(t.OpenParenthesis)&&e[e.length-1].is(t.CloseParenthesis)&&ci(e,t.OpenParenthesis,t.CloseParenthesis)}addChild(e){super.addChild(e),m(this,Ie,Ds).call(this)}setChildren(e){super.setChildren(e),m(this,Ie,Ds).call(this)}getVariableExpressions(){let e=[];for(let n of this.getChildren()){if(n.is(t.Dot))break;n.is(t.VariableName)?e.push(n):e=e.concat(n.getVariableExpressions())}for(let n of u(this,de))for(let s of n)s.is(t.VariableName)?e.push(s):e=e.concat(s.getVariableExpressions());return e}getExpressionsOfKind(e){let n=super.getExpressionsOfKind(e);for(let s of u(this,de))for(let o of s)o.is(e)?n.push(o):n=n.concat(o.getExpressionsOfKind(e));return n}getFirstExpressionOf(e){let n=super.getFirstExpressionOf(e);if(n===void 0)for(const s of u(this,de)){if(s.isOneOf(e))return s;if(n=s.getFirstExpressionOf(e),n!==void 0)return n}return n}checkForSymptoms(){this.checkRules(this),this.isComplete()&&this.getChildren()[0].checkForSymptoms();for(const e of u(this,de))for(const n of e)n.checkForSymptoms()}typeUpdateReceived(e){m(this,Ie,Ds).call(this)}matchesPattern(e){return super.matchesPattern(e)&&this.getMethodName()===e.getMethodName()}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),this.getMethodExpression(),...u(this,de).flatMap(n=>n.flatMap(s=>s.getAllNestedExpressions()))]}toJSON(){const e=super.toJSON();return e.methodName=this.getMethodName(),e.arguments=this.getArguments().map(n=>n.map(s=>s.toJSON())),e.object=this.getObject().toJSON(),e}getMethodEntity(){const e=this.getChildren();if(e.length<3)throw new Error("No method expression available");return e[2].getEntity()}getMethodExpression(){const e=this.getChildren();if(e.length<3)throw new Error("No method expression available");return e[2]}getMethodName(){const e=this.getChildren();if(e.length<3)throw new Error("No method expression available");return e[2].getTextValue()}getMethod(){const e=this.getChildren();if(e.length<3)throw new Error("No method expression available");return e[2]}getObject(){const e=this.getChildren();if(e.length===0)throw new Error("No children");return e[0]}getArguments(){return u(this,de)}}de=new WeakMap,Ie=new WeakSet,ua=function(){for(const e of u(this,de))for(const n of e)n.addConnection(this);this.addConnection(this.getMethodExpression())},da=function(){for(const e of u(this,de))for(const n of e)n.setParent(this)},Ds=function(){if(this.isComplete()){const e=this.getObject(),n=this.getMethod();Gn.has(e.getDataType())&&Gn.get(e.getDataType()).has(n.getEntity())?this.setDataType(n.getDataType()):n.is(a.BuiltInMethods)&&e.getDataType()===d.NotParsed?e.addObserver(this):this.setDataType(d.Unknown)}else this.setDataType(d.NotParsed)},ha=function(e){const n=[],s=e.getMethod();return s.getDataType()!==d.None&&s.getDataType()!==d.NotParsed&&s.getDataType()!==d.Unknown&&e.getDataType()!==d.Unknown&&e.getDataType()!==d.None&&e.getDataType()!==d.NotParsed&&(e.getParent()===void 0||e.getParent().is(t.GroupStatement)&&e.getParent().getParent()===void 0)&&n.push(O.createStatementSymptom(b.UnusedReturn,[e],0,0,{expression:e.getMethodExpression()})),n},fa=function(e){const n=[],s=e.getArguments();for(const o of s){const f=o.flatMap(p=>p.is(t.GroupStatement)?p.getContents():p).filter(p=>Ct(p)||p.getDataType()===d.None&&!p.isOneOf([t.NoneType,t.VariableName]));f.length>0&&n.push(...f.map(p=>O.createStatementSymptom(b.AssignedNone,[p],0,0,{expression:p,usage:wr})))}return n};class tu extends Or{constructor(e,n){super(e,n,t.BuiltInMethodCall,a.MethodCall);I(this,Sn);m(this,Sn,ga).call(this),this.addRule(m(this,Sn,pa))}isComplete(){return super.isComplete()&&this.getChildren()[2].isOneOf([a.BuiltInMethods,a.MagicMethods,a.ModuleFunctions])}isStringLiteral(){return this.getMethodEntity()===t.Format}}Sn=new WeakSet,ga=function(){if(wc.has(this.getMethodEntity())){const e=this.getObject();e.is(t.VariableName)?e.setAssignedOrChanged():e.is(t.SubscriptedExpression)&&e.getChildren()[0].is(t.VariableName)&&e.getChildren()[0].setAssignedOrChanged()}},pa=function(e){const n=[],o=e.getObject().getDataType(),c=e.getMethod();let f=!0;switch(o){case d.Number:case d.Int:case d.Float:case d.Bool:case d.None:f=!1}if(f&&Gn.has(o)&&(f=Gn.get(o).has(c.getEntity())||c.is(a.MagicMethods)),!f){const p=e.getChildren();n.push(O.createStatementSymptom(b.UnknownMethod,p,0,p.length-1,{objectType:o.name}))}return n};class nu extends Or{constructor(e,n){super(e,n,t.UserDefinedMethodCall,a.MethodCall);I(this,js);this.addRule(m(this,js,ma))}isComplete(){return super.isComplete()&&this.getChildren()[2].is(t.MethodName)}}js=new WeakSet,ma=function(e){const n=[],o=e.getObject().getDataType();if(Gn.has(o)){const c=e.getChildren();n.push(O.createStatementSymptom(b.UnknownMethod,c,0,c.length-1,{objectType:o.name}))}return n};class Dr extends Y{constructor(e,n,s,o){super(e,n,s,o);I(this,In);I(this,Xe);I(this,Me);this.isComplete()&&(y(this,Xe,n[0]),y(this,Me,n[2])),m(this,In,Sa).call(this),this.addRule(m(this,In,wa))}isComplete(){const e=this.getChildren();return e.length==3&&e[1].is(t.Dot)}getVariableExpressions(){let e=[];return u(this,Xe).is(t.VariableName)?e.push(u(this,Xe)):e=e.concat(u(this,Xe).getVariableExpressions()),e}getExpressionsOfKind(e){let n=super.getExpressionsOfKind(e);for(let s of this.getChildren())s.is(e)?n.push(s):n=n.concat(s.getExpressionsOfKind(e));return n}getFirstExpressionOf(e){let n=super.getFirstExpressionOf(e);if(n===void 0)for(const s of this.getChildren()){if(s.isOneOf(e))return s;if(n=s.getFirstExpressionOf(e),n!==void 0)return n}return n}matchesPattern(e){return super.matchesPattern(e)&&this.getTextValue()===e.getTextValue()}setDataType(e){if((e!==this.getDataType()||e!==u(this,Me).getDataType())&&(super.setDataType(e),!u(this,Me).is(a.ModuleProperties)))try{u(this,Me).setDataType(e)}catch{}}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...u(this,Xe).getAllNestedExpressions(),...u(this,Me).getAllNestedExpressions()]}toJSON(){const e=super.toJSON();return e.object=u(this,Xe).toJSON(),e.propertyName=u(this,Me).getTextValue(),e}getObject(){return u(this,Xe)}getProperty(){return u(this,Me)}}Xe=new WeakMap,Me=new WeakMap,In=new WeakSet,wa=function(e){const n=[];return(e.getParent()===void 0||e.getParent().is(t.GroupStatement)&&e.getParent().getParent()===void 0)&&n.push(O.createStatementSymptom(b.UnusedValue,[e],0,0)),n},Sa=function(){if(this.isComplete())if(u(this,Me).getCategory()===a.ModuleProperties){const e=Mt.get(u(this,Me).getEntity());this.setDataType(e||u(this,Me).getDataType())}else this.setDataType(d.Unknown);else this.setDataType(d.NotParsed);u(this,Me).addObserver(this)};class su extends Qe{isSubscriptable(){return!0}}class xr extends su{constructor(e,n,s,o,c=s+e.length,f=n){super(e,t.StringLiteral,a.Literals,n,s,o,d.String,c,f);I(this,qs);this.addRule(m(this,qs,Ia))}isStringLiteral(){return!0}matchesPattern(e){return e.getEntity()===t.StringLiteral||e.getEntity()===t.CombinedStringLiteral||e.getEntity()===t.FString}setDataType(e){throw new Error(`Cannot change the data type of a String literal. Attempted to change the type to: ${e.name}.`)}update(e,n,s){this.setEndLineNumber(e),this.documentEndIndex(n),this.setTextValue(this.getTextValue+s)}}qs=new WeakSet,Ia=function(e){const n=[];return(e.getParent()===void 0||e.getParent().is(t.GroupStatement)&&e.getParent().getParent()===void 0)&&n.push(O.createStatementSymptom(b.UnusedValue,[e],0,0)),n};class hi extends Qe{constructor(e,n,s,o){const c=e.indexOf(".")>=0?t.FloatLiteral:t.IntLiteral;super(e,c,a.Literals,n,s,o,c===t.FloatLiteral?d.Float:d.Int);I(this,Hs);this.addRule(m(this,Hs,ba))}setDataType(e){throw new Error(`Cannot change the data type of a bumber literal. Attempted to change the type to: ${e.name}.`)}matchesPattern(e){return e.getEntity()===t.FloatLiteral||e.getEntity()===t.IntLiteral}}Hs=new WeakSet,ba=function(e){const n=[];return(e.getParent()===void 0||e.getParent().is(t.GroupStatement)&&e.getParent().getParent()===void 0)&&n.push(O.createStatementSymptom(b.UnusedValue,[e],0,0)),n};class iu extends Y{constructor(e,n){super(e,n,t.FString,a.Literals,d.String);I(this,bn);I(this,Ze);y(this,Ze,m(this,bn,ya).call(this));for(const s of u(this,Ze))for(const o of s)o.setParent(this),this.addConnection(o);this.addRule(m(this,bn,Fa))}isStringLiteral(){return!0}matchesPattern(e){return e.getEntity()===t.StringLiteral||e.getEntity()===t.CombinedStringLiteral||e.getEntity()===t.FString}getVariableExpressions(){let e=[];for(let n of u(this,Ze))for(let s of n)s.is(t.VariableName)?e.push(s):e=e.concat(s.getVariableExpressions());return e}checkForSymptoms(){this.checkRules(this);for(const e of u(this,Ze))for(const n of e)n.checkForSymptoms()}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...u(this,Ze).flatMap(e=>e.flatMap(n=>n.getAllNestedExpressions()))]}toJSON(){const e=super.toJSON();return e.values=u(this,Ze).map(n=>n.map(s=>s.toJSON())),e}getValues(){return u(this,Ze)}}Ze=new WeakMap,bn=new WeakSet,ya=function(){const e=[];if(this.isComplete()){const n=this.getChildren()[1],s=n.getTextValue();let o=0,c=0,f=-1,p=-1;for(let w=0;w<s.length;w++)if(s.charAt(w)==="{")o===0&&(f=w+1),o++;else if(o>0)if(s.charAt(w)==="}"){if(o--,o===0){const S=p===-1?s.substring(f,w):s.substring(f,p),F=new Jn(S,n.getStartLineNumber(),n.getDocumentStartIndex());e.push(K.createTree(F.getExpressions()))}}else s.charAt(w)==="["?c++:s.charAt(w)==="]"?c--:c===0&&s.charAt(w)===":"&&(p=w)}return e},Fa=function(e){const n=[];return(e.getParent()===void 0||e.getParent().is(t.GroupStatement)&&e.getParent().getParent()===void 0)&&n.push(O.createStatementSymptom(b.UnusedValue,[e],0,0)),n};class ru extends Y{constructor(e,n){super(e,n,t.CombinedStringLiteral,a.Literals,d.String);I(this,zs);this.addRule(m(this,zs,Ta))}isStringLiteral(){return!0}matchesPattern(e){return e.getEntity()===t.StringLiteral||e.getEntity()===t.CombinedStringLiteral||e.getEntity()===t.FString}getVariableExpressions(){let e=[];for(let n of this.getChildren())e=e.concat(n.getVariableExpressions());return e}}zs=new WeakSet,Ta=function(e){const n=[];return(e.getParent()===void 0||e.getParent().is(t.GroupStatement)&&e.getParent().getParent()===void 0)&&n.push(O.createStatementSymptom(b.UnusedValue,[e],0,0)),n};class Br extends Qe{constructor(i,e,n,s,o,c){super(i,e,n,s,o,c,d.NA)}setDataType(i){throw new Error(`Cannot change the data type of a keyword or operator. Attempted to change the type to: ${i.name}.`)}setTextValue(i){throw new Error(`Cannot change the value of a keyword or operator. Attempted to change the value to ${i}.`)}matchesPattern(i){return this.getEntity()===i.getEntity()?!0:this.isOneOf([a.ComparisonOperators,a.LogicalOperators,a.MathsOperators])?i.getCategory():!1}}class Ar extends Qe{constructor(e,n,s,o,c,f){super(e,n,s,o,c,f,Bs(n));I(this,It);y(this,It,e)}hasAlias(){return u(this,It)!==this.getTextValue()}getModuleName(){return u(this,It)}setModuleName(e){y(this,It,e)}setDataType(e){throw new Error(`The data type of a module cannot be changed. Attempted to change the data type to ${e}.`)}setTextValue(e){throw new Error(`The text value of a module cannot be changed. Attempted to change the value to ${e}.`)}matchesPattern(e){return this.getEntity()===e.getEntity()===this.getTextValue()&&e.getTextValue()}toJSON(){const e=super.toJSON();return e.moduleAlias=u(this,It),e}}It=new WeakMap;class _t extends Qe{constructor(e,n,s,o,c,f,p=!1){var i=(...Ad)=>(super(...Ad),I(this,re),I(this,bt,[]),I(this,rs,!1),I(this,os),I(this,as,!1),this);if(s===a.Identifiers)i(e,n,s,o,c,f);else if(s===a.SpecialVariables)i(e,n,s,o,c,f,Bs(n));else if(s===a.ModuleProperties)i(e,n,s,o,c,f,Mt.has(n)?Mt.get(n):d.Unknown);else throw new Error(`No constructor for VariableExpression with ${n.name}`);y(this,os,p),this.addRules([m(this,re,Ma),m(this,re,Ca)]),this.addConstructRule(m(this,re,Na))}setTextValue(e){throw new Error(`Cannot change the text value of a variable (its name). Attempted to change the value to ${e}.`)}setIsParameter(){y(this,as,!0)}isParameter(){return u(this,as)}isSubscriptable(){return As(this.getDataType())}getVariableExpressions(){return this.is(t.VariableName)?[this]:[]}setDataType(e){(!this.isAssignedOrChanged()||this.isObjectOfMethodCall()||this.isSubscripted())&&u(this,bt).length>0&&(e=m(this,re,si).call(this)),super.setDataType(e),e.isCustom&&this.getParent()&&this.getParent().is(t.PropertyCallExpression)&&(this.getParent().getProperty().setCategory(a.ClassAttributes),this.getParent().getProperty().setOwnerType(e))}matchesPattern(e){let n=e;return n.is(t.BooleanExpression)&&e.getChildren().length===2&&e.getChildren()[0].is(t.NotOperator)&&e.getChildren()[1].is(t.VariableName)&&(n=e.getChildren()[1]),this.getEntity()===n.getEntity()&&this.getTextValue()===n.getTextValue()}getLastUsages(){return u(this,bt)}addLastUsage(e){u(this,bt).push(e),e.addConnection(this),(!this.isAssignedOrChanged()||this.isObjectOfMethodCall()||this.isSubscripted())&&(this.setDataType(m(this,re,si).call(this)),e.addObserver(this))}isSubscripted(){const e=this.getParent();return e===void 0?!1:e.is(t.SubscriptedExpression)}isObjectOfMethodCall(){const e=this.getParent();return e===void 0?!1:e.is(t.BuiltInMethodCall)&&e.getChildren()[0].getTextValue()===this.getTextValue()}setLastUsages(e){y(this,bt,e),this.setDataType(m(this,re,si).call(this));for(let n of e)n.addObserver(this),n.addConnection(this)}isAssignedOrChanged(){return u(this,rs)}setAssignedOrChanged(){y(this,rs,!0)}isProxy(){return u(this,os)}compareValues(e,n){const s=e.getParent();if(s===void 0)return xs;const o=s.is(t.AssignmentStatement)?m(this,re,zi).call(this,e):s.is(t.IteratorExpression)?m(this,re,xa).call(this,e):void 0,c=m(this,re,Da).call(this,o,n);return c.size===1?Array.from(c)[0]:xs}}bt=new WeakMap,rs=new WeakMap,os=new WeakMap,as=new WeakMap,re=new WeakSet,si=function(){return Nt(u(this,bt).map(e=>e.getDataType()))},Na=function(e){const n=[];return e.getDataType()===d.Bool&&O.checkBooleanCompare(e),n},Ca=function(e){const n=[];return(e.getParent()===void 0||e.getParent().is(t.GroupStatement)&&e.getParent().getParent()===void 0)&&n.push(O.createStatementSymptom(b.UnusedValue,[e],0,0)),n},Ma=function(e){var c;const n=[],s=e.getLastUsages(),o=e.getParent();if(!e.getScopeId().includes("listComprehension")&&!e.isProxy()&&e.isAssignedOrChanged()&&s.length>0&&o!==void 0&&o.isOneOf([t.AssignmentStatement,t.IteratorExpression])){if(o.is(t.AssignmentStatement)&&m(c=e,re,Oa).call(c,e.getTextValue(),o))return n;let f=!0;const p=e.getBlockId().split("-")[1];for(const w of s)if(w.getScopeId()===e.getScopeId()&&(!w.isAssignedOrChanged()||p!=="for"&&w.getBlockId()!==e.getBlockId())){f=!1;break}if(f){const w=s.length===1&&s[0].isParameter(),S=o.is(t.IteratorExpression)?o.getParent().getTextValue():o.getTextValue();n.push(O.createStatementSymptom(b.OverwrittenVariable,[e],0,0,{isParameter:w,functionBlock:w?s[0].getBlockId():"",prevUsageIsDefinition:s.length===1&&s[0].getLastUsages().length===0,overwriteType:o.is(t.AssignmentStatement)?ai:oi,overwriteValue:e.compareValues(e,s),usageText:S,overwrittenVar:s.map(F=>({lineNum:F.getStartLineNumber(),block:F.getBlockId(),docIndex:F.getDocumentStartIndex(),forLoopDefinition:F.getParent().is(t.IteratorExpression)&&F.getParent().getLoopVariables().filter(N=>N.getTextValue()===F.getTextValue()).length>0}))}))}}return n},Oa=function(e,n){const s=n.getAssignedValues();for(const o of s)if(o.getExpressionsOfKind(e).length>0)return!0;return!1},Da=function(e,n){const s=new Set;if(e!==void 0&&e.isOneOf([a.Literals,a.Types]))for(const o of n)if(o.getParent()!==void 0&&o.getParent().is(t.AssignmentStatement)){const c=m(this,re,zi).call(this,o);c!==void 0&&c.isOneOf([a.Literals,a.Types])?s.add(e.getTextValue()===c.getTextValue()?li:mr):s.add(xs)}else s.add(xs);return s},xa=function(e){const n=e.getParent(),s=n.getIterable();if(s.is(t.BuiltInFunctionCall)){const o=s.getFunctionExpression();if(o.is(t.RangeFunction)){const c=s.getArguments();if(c.length===1)return new hi("0",-1,-1,-1);if(c.length>1)return c[0][0]}else if(o.is(t.EnumerateFunction)){const c=n.getLoopVariables();if(c.length===2&&c[0].getTextValue()===e.getTextValue())return new hi("0",-1,-1,-1)}}},zi=function(e){const n=e.getParent();if(n===void 0)return;const s=n.getTargetVariables(),o=n.getAssignedValues();let c=-1;for(let f=0;f<s.length;f++)if(s[f].getTextValue()===e.getTextValue()){c=f;break}if(c>-1&&c<o.length)return o[c]};class fi extends _t{constructor(e,n,s,o,c,f){super(e,n,s,o,c,f);I(this,ls)}setDataType(e){if(this.is(t.PropertyName))super.setDataType(e);else throw new Error(`Cannot change the data type of an attribute of a built-in module. Attempted to change the data type to ${e.name}.`)}getVariableExpressions(){return[]}getOwnerType(){return u(this,ls)}setOwnerType(e){y(this,ls,e)}matchesPattern(e){return this.getEntity()===e.getEntity()&&this.getTextValue()===e.getTextValue()}}ls=new WeakMap;class kr extends Qe{constructor(i,e,n,s,o,c,f=d.NotParsed){super(i,e,n,s,o,c,f)}setTextValue(i){throw new Error(`Cannot change the name of a function node. Attempted to change the name to ${i}.`)}isSubscriptable(){return As(this.getDataType())}matchesPattern(i){return this.getEntity()===i.getEntity()&&this.getTextValue()===i.getTextValue()}}class Pr extends kr{constructor(e,n,s,o,c,f){super(e,n,s,o,c,f,d.NotParsed);I(this,cs);I(this,Ye,[])}setDataType(e){const n=u(this,Ye).map(s=>s.getDataType());super.setDataType(Nt(n))}toJSON(){const e=this.getReturnStatements(),n=this.getParent(),s=n!==void 0&&n.isOneOf([t.FunctionDefinitionStatement,t.MethodDefinitionStatement])?n.getParameters().length:-1,o=n!==void 0&&n.isOneOf([t.FunctionDefinitionStatement,t.MethodDefinitionStatement])?n.getOptionalParameterCount():-1;return{name:this.getTextValue(),block:this.getBlockId(),callLineNumbers:Array.from(this.getObservers()).filter(c=>c.is(t.UserDefinedFunctionCall)).map(c=>c.getStartLineNumber()),hasReturn:e.length>0,hasBranchWithoutReturn:u(this,Ye).length>e.length,numOptionalParameters:o,parameters:s>-1?n.getParameters().flatMap(c=>c).map(c=>c.getTextValue()):[],returnDetail:e.map(c=>({line:c.getStartLineNumber(),dataType:c.getDataType().name})),returnTypes:e.length>0?Array.from(new Set(e.map(c=>c.getDataType().name))):["none"]}}addReturns(e,n=!1){for(const s of e)if(s.getFirstExpression().is(t.ReturnStatement)){const o=s.getFirstExpression();u(this,Ye).push(o);for(const c of this.getObservers())c.is(t.UserDefinedFunctionCall)&&(u(c.getFunctionExpression(),Ye).push(o),o.addConnection(c));o.addObserver(this)}else m(this,cs,Qi).call(this);n&&m(this,cs,Qi).call(this),this.setDataType()}getReturnType(){const e=u(this,Ye).map(n=>n.getDataType());return Nt(e)}getReturnStatements(){return u(this,Ye).filter(e=>e.is(t.ReturnStatement))}}Ye=new WeakMap,cs=new WeakSet,Qi=function(){const e=new _t("proxy",t.VariableName,a.Identifiers,-1,-1,-1,!0);e.setDataType(d.None),u(this,Ye).push(e)};class ou extends Pr{constructor(){super(...arguments);I(this,yn,d.Class)}getContainingClass(){return u(this,yn)}setContainingClass(e){y(this,yn,e)}toJSON(){const e=super.toJSON();return e.containingClass=u(this,yn).name,this.getTextValue()==="__init__"&&(e.hasReturn=!0,e.hasBranchWithoutReturn=!1,e.returnTypes=[e.containingClass]),e}}yn=new WeakMap;class au extends kr{constructor(i,e,n,s,o,c){super(i,e,n,s,o,c,Mt.get(e))}setDataType(i){if(this.getEntity()!==t.FunctionName)throw new Error(`Cannot set the data type of a built-in function. Attempted to set the data type to ${i}`);super.setDataType(i)}}class lu extends Qe{constructor(e,n,s,o,c,f){var i=(...kd)=>(super(...kd),I(this,Qs),this);if(n===t.TrueType||n===t.FalseType)i(e,n,s,o,c,f,d.Bool);else if(n===t.NoneType)i(e,n,s,o,c,f,d.None);else throw new Error(`Not a valid type value: ${n.name}`);this.addRule(m(this,Qs,Ba))}setTextValue(e){throw new Error(`The text value of a built-in function cannot be changed. Attempted to change the value to ${e}.`)}setDataType(e){throw new Error(`Cannot set the data type of a built-in function. Attempted to set the data type to ${e}`)}matchesPattern(e){return e.getEntity()===t.TrueType||e.getEntity()===t.FalseType||e.getEntity()===t.NoneType}}Qs=new WeakSet,Ba=function(e){const n=[];return(e.getParent()===void 0||e.getParent().is(t.GroupStatement)&&e.getParent().getParent()===void 0)&&n.push(O.createStatementSymptom(b.UnusedValue,[e],0,0)),n};class gi extends Qe{constructor(i,e,n,s,o,c,f){super(i,e,n,s,o,c,f)}setTextValue(i){throw new Error(`The text value of a class or type cannot be changed. Attempted to change the value to ${i}.`)}matchesPattern(i){return this.getEntity()===i.getEntity()&&this.getTextValue()===i.getTextValue()}}class cu extends gi{constructor(i,e,n,s,o,c){super(i,e,n,s,o,c,d.Unknown)}setDataType(i){throw new Error(`Cannot change the data type of a built-in type. Attempted to set the data type to ${i}.`)}}class uu extends gi{constructor(i,e,n,s,o,c){super(i,e,n,s,o,c,d.Exception)}setDataType(i){throw new Error(`Cannot change the data type of a built-in type. Attempted to set the data type to ${i}.`)}}class du extends gi{constructor(i,e,n,s,o,c){super(i,e,n,s,o,c,d.Class)}matchesPattern(i){return this.getEntity()===i.getEntity()&&this.getTextValue()===i.getTextValue()}}class Rs extends Y{constructor(e,n,s,o){const c=Bs(s);super(e,n,s,a.CompoundTypes,c);I(this,Xs);I(this,te);y(this,te,o);for(let f=0;f<u(this,te).length;f++)if(s!==t.DictDefinition){u(this,te)[f].length>1&&(u(this,te)[f]=K.createTree(u(this,te)[f]));for(const p of u(this,te)[f])p.setParent(this),this.addConnection(p)}else for(let p=0;p<u(this,te)[f].length;p++){u(this,te)[f][p].length>1&&(u(this,te)[f][p]=K.createTree(u(this,te)[f][p]));for(const w of u(this,te)[f][p])w.setParent(this),this.addConnection(w)}this.addRule(m(this,Xs,Aa))}isComplete(){this.getChildren().length>1}getVariableExpressions(){let e=[];for(let n of u(this,te))for(let s of n)if(this.getEntity()!==t.DictDefinition)s.is(t.VariableName)?e.push(s):e=e.concat(s.getVariableExpressions());else for(let o of s)o.is(t.VariableName)?e.push(o):e=e.concat(o.getVariableExpressions());return e}contains(e){if(super.contains(e))return!0;for(let n of u(this,te))for(let s of n)if(this.getEntity()!==t.DictDefinition){if(s.contains(e))return!0}else for(let o of s)if(o.contains(e))return!0;return!1}getExpressionsOfKind(e){let n=super.getExpressionsOfKind(e);for(let s of u(this,te))for(let o of s)if(this.getEntity()!==t.DictDefinition)o.is(e)?n.push(o):n=n.concat(o.getExpressionsOfKind(e));else for(let c of o)c.is(e)?n.push(c):n=n.concat(c.getExpressionsOfKind(e));return n}getFirstExpressionOf(e){let n=super.getFirstExpressionOf(e);if(n===void 0)for(const s of u(this,te))for(const o of s)if(this.getEntity()!==t.DictDefinition){if(o.isOneOf(e))return o;if(n=o.getFirstExpressionOf(e),n!==void 0)return n}else for(const c of o){if(c.isOneOf(e))return c;if(n=c.getFirstExpressionOf(e),n!==void 0)return n}return n}setDataType(e){throw new Error("Can't update the type of a compound expression")}checkForSymptoms(){this.checkRules(this);for(const e of u(this,te))for(const n of e)if(this.getEntity()!==t.DictDefinition)n.checkForSymptoms();else for(const s of n)s.checkForSymptoms()}matchesPattern(e){return this.getEntity()===e.getEntity()}getAllNestedExpressions(){return this.getEntity()!==t.DictDefinition?[...super.getAllNestedExpressions(),...u(this,te).flatMap(e=>e.flatMap(n=>n.getAllNestedExpressions()))]:[...super.getAllNestedExpressions(),...u(this,te).flatMap(e=>e.flatMap(n=>n.flatMap(s=>s.getAllNestedExpressions())))]}toJSON(){const e=super.toJSON();try{e.elements=u(this,te).map(n=>n.map(s=>s.toJSON()))}catch{e.elements=u(this,te).map(s=>s.map(o=>o.map(c=>c.toJSON())))}return e}getElements(){return u(this,te)}}te=new WeakMap,Xs=new WeakSet,Aa=function(e){const n=[];return(e.getParent()===void 0||e.getParent().is(t.GroupStatement)&&e.getParent().getParent()===void 0)&&n.push(O.createStatementSymptom(b.UnusedValue,[e],0,0)),n};class nt extends Y{constructor(e,n,s){super(e,n,s,a.BlockDefinitionStatement,d.NA);I(this,Fn);I(this,le,[]);if(n.length>1){const o=m(this,Fn,ka).call(this);let c=K.createTree(n.slice(1,o));if(s===t.ForDefinitionStatement&&c.length>0)if(c[0].is(t.IteratorExpression))y(this,le,c);else if(c[0].is(t.ComparisonExpression)){c[0]=c[0].convertToIterator(),y(this,le,[c[0]]);const f=c.slice(1).filter(p=>!p.is(t.Colon));f.length>0&&y(this,le,u(this,le).concat(f))}else c=[new wi(e,c)],y(this,le,c);else s===t.WithDefinitionStatement||s===t.ExceptDefinitionStatement?c.length===3&&c[1].is(t.AsKeyword)&&c[2].is(t.VariableName)&&y(this,le,[new Lr(e,c)]):y(this,le,c);for(const f of c)f.setParent(this),this.addConnection(f)}s===t.WhileDefinitionStatement&&this.addRule(m(this,Fn,Pa))}isComplete(){const e=this.getChildren();return e.length>=2?e[0].is(a.BlockDefinitions)&&e[e.length-1].is(t.Colon):!1}setDataType(e){throw new Error("Can't update the type of a block definition")}getVariableExpressions(){let e=[];for(let n of u(this,le))n.is(t.VariableName)?e.push(n):e=e.concat(n.getVariableExpressions());return e}getExpressionsOfKind(e){let n=super.getExpressionsOfKind(e);for(let s of u(this,le))s.is(e)?n.push(s):n=n.concat(s.getExpressionsOfKind(e));return n}getFirstExpressionOf(e){let n=super.getFirstExpressionOf(e);if(n===void 0)for(const s of u(this,le)){if(s.isOneOf(e))return s;if(n=s.getFirstExpressionOf(e),n!==void 0)return n}return n}checkForSymptoms(){this.checkRules(this);for(const e of u(this,le))e.checkForSymptoms()}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...u(this,le).flatMap(n=>n.getAllNestedExpressions())]}getCondition(){return u(this,le)}toJSON(){const e=super.toJSON();return e.keyword=this.getChildren()[0].getTextValue(),e.condition=u(this,le).map(n=>n.toJSON()),e}getCondition(){return u(this,le)}getBlockEntity(){return this.getChildren()[0].getEntity()}}le=new WeakMap,Fn=new WeakSet,ka=function(){const e=this.getChildren();for(let n=e.length-1;n>=0;n--)if(e[n].is(t.Colon))return n;return e.length},Pa=function(e){const n=[],s=e.getChildren();if(e.is(t.WhileDefinitionStatement)){const o=u(e,le);oe(s,!0),o.length===1&&(o[0].is(t.TrueType)||o[0].is(t.GroupStatement)&&o[0].getContents().length===1&&o[0].getContents()[0].is(t.TrueType))&&n.push(O.createStatementSymptom(b.WhileTrue,s,0,s.length-1))}return n};class Lr extends Y{constructor(e,n){super(e,n,t.AssignmentStatement,a.Assignment,d.NotParsed);I(this,ee);I(this,Z,[]);I(this,we,[]);m(this,ee,La).call(this),this.addRules([m(this,ee,Ga),m(this,ee,Ua),m(this,ee,Ea)])}getVariableExpressions(){let e=[];for(let n of u(this,we))e=e.concat(n.getVariableExpressions());for(let n of u(this,Z))e=e.concat(n.getVariableExpressions());return e}setDataType(e){e=Nt(u(this,Z).map(n=>n.getDataType())),super.setDataType(e)}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...u(this,Z).flatMap(n=>n.getAllNestedExpressions()),...u(this,we).flatMap(n=>n.getAllNestedExpressions())]}toJSON(){const e=super.toJSON();return e.targets=u(this,Z).map(n=>n.toJSON()),e.values=u(this,we).map(n=>n.toJSON()),e}getTargetVariables(){return u(this,Z)}getAssignedValues(){return u(this,we)}}Z=new WeakMap,we=new WeakMap,ee=new WeakSet,La=function(){const e=this.getChildren();Zt(e,t.AssignmentOperator)>0?m(this,ee,va).call(this,e):Zt(e,t.AsKeyword)>0&&m(this,ee,Va).call(this,e)},Va=function(e){const n=K.split(e,t.AsKeyword),s=[];for(let o=0;o<n.length;o++)s.push(K.split(n[o],t.Comma));if(n.length===2&&s.length===2){for(let o of s[1])o[0].is(t.VariableName)?o[0].setAssignedOrChanged():o[0].is(t.PropertyCallExpression)&&o[0].getProperty().is(t.PropertyName)&&o[0].getProperty().setAssignedOrChanged(),u(this,Z).push(o[0]);for(let o of s[0])u(this,we).push(o[0])}u(this,Z).length===u(this,we).length?m(this,ee,Xi).call(this):u(this,Z).length>u(this,we).length?m(this,ee,Zi).call(this):m(this,ee,Yi).call(this)},va=function(e){const n=K.split(e,t.AssignmentOperator),s=[];for(let o=0;o<n.length;o++){const c=K.split(n[o],t.Comma);s.push(c)}if(n.length===2&&s.length===2){for(let o of s[0])o[0].is(t.VariableName)?o[0].setAssignedOrChanged():o[0].is(t.SubscriptedExpression)&&o[0].getChildren()[0].is(t.VariableName)?o[0].getChildren()[0].setAssignedOrChanged():o[0].is(t.PropertyCallExpression)&&o[0].getProperty().is(t.PropertyName)&&o[0].getProperty().setAssignedOrChanged(),u(this,Z).push(o[0]);for(let o of s[1])u(this,we).push(o[0])}u(this,Z).length===u(this,we).length?m(this,ee,Xi).call(this):u(this,Z).length>u(this,we).length?m(this,ee,Zi).call(this):m(this,ee,Yi).call(this);for(const o of u(this,Z))o.addObserver(this),this.addConnection(o);this.setDataType(Nt(u(this,Z).map(o=>o.getDataType())))},Xi=function(){for(let e=0;e<u(this,Z).length;e++)u(this,Z)[e].isOneOf([t.VariableName,t.SubscriptedExpression,t.PropertyCallExpression])?(u(this,Z)[e].setDataType(u(this,we)[e].getDataType()),u(this,we)[e].addObserver(u(this,Z)[e]),u(this,we)[e].addConnection(u(this,Z)[e])):u(this,Z)[e].is(t.TupleDefinition)?m(this,ee,Ra).call(this,u(this,Z)[e]):u(this,Z)[e].is(a.SpecialVariables)||this.setDataType(d.Invalid)},Ra=function(e){for(let n of e.getElements())n[0].isOneOf([t.VariableName,t.SubscriptedExpression])&&n[0].setDataType(d.Unknown)},Zi=function(){for(let e of u(this,Z))e.isOneOf([t.VariableName,t.SubscriptedExpression])?e.setDataType(d.Unknown):console.log("stop")},Yi=function(){for(let e of u(this,Z))e.isOneOf([t.VariableName,t.SubscriptedExpression])?e.setDataType(d.Tuple):console.log("stop")},Ua=function(e){const n=[];for(const s of e.getTargetVariables()){const o=We(s.getTextValue()).category;s.is(t.VariableName)&&s.getLastUsages().length===0&&o===a.BuiltInFunctions?n.push(O.createStatementSymptom(b.VariableWithSameNameAsFunction,[s],0,0,{funcType:Qt,varIsParameter:s.isParameter()})):(o===a.BlockDefinitions||o===a.LogicalOperators||o===a.Types||o===a.OtherKeywords)&&s.getTextValue()!=="f"&&s.getTextValue()!=="r"&&n.push(O.createStatementSymptom(b.ReservedWordAssigned,[s],0,0))}return n},Ea=function(e){const n=[],s=e.getAssignedValues();for(let o=0;o<s.length;o++)s[o].is(t.Colon)&&n.push(O.createStatementSymptom(b.UnexpectedColon,s,0,s.length-1,{before:o>0?s[o-1].getTextValue():ce,after:o<s.length-1?s[o+1].getTextValue():ce}));return n},Ga=function(e){const n=[],c=e.getAssignedValues().flatMap(f=>f.is(t.GroupStatement)?f.getContents():f).filter(f=>Ct(f)||f.getDataType()===d.None&&!f.isOneOf([t.NoneType,t.VariableName]));return c.length>0&&n.push(...c.map(f=>O.createStatementSymptom(b.AssignedNone,[f],0,0,{expression:f,usage:ai,target:u(e,Z)[0].getTextValue()}))),n};class hu extends Y{constructor(e,n){super(e,n,t.ChangeStatement,a.Assignment,d.NA);I(this,Ee);I(this,Ue,[]);I(this,Pe,-1);I(this,Tn,[]);I(this,ot);m(this,Ee,$a).call(this),this.addRule(m(this,Ee,ja))}getVariableExpressions(){let e=[];for(let n of u(this,Tn))e=e.concat(n.getVariableExpressions());for(let n of u(this,Ue))e=e.concat(n.getVariableExpressions());return e}getAssignedValue(){return u(this,ot)}getTargetVariables(){return u(this,Ue)}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...u(this,Ue).flatMap(n=>n.getAllNestedExpressions()),...u(this,ot).getAllNestedExpressions()]}toJSON(){const e=super.toJSON();return e.target=u(this,Ue)[0].toJSON(),e.operator=this.getChildren()[u(this,Pe)].toJSON(),e.changeValue=u(this,ot).toJSON(),e}}Ue=new WeakMap,Pe=new WeakMap,Tn=new WeakMap,ot=new WeakMap,Ee=new WeakSet,$a=function(){m(this,Ee,Wa).call(this);const e=this.getChildren();if(u(this,Pe)===1&&e.length===3)e[0].is(t.VariableName)?e[0].setAssignedOrChanged():e[0].is(t.SubscriptedExpression)&&e[0].getChildren()[0].is(t.VariableName)?e[0].getChildren()[0].setAssignedOrChanged():e[0].is(t.PropertyCallExpression)&&e[0].getProperty().is(t.PropertyName)&&e[0].getProperty().setAssignedOrChanged(),u(this,Ue).push(e[0]),y(this,ot,e[2]),this.addConnection(e[0]),e[2].addConnection(e[0]),e[0].isOneOf([t.VariableName,t.SubscriptedExpression])?m(this,Ee,Ja).call(this):this.setDataType(d.Invalid);else if(u(this,Pe)===1&&e.length>3&&En(e,t.Comma)){this.setDataType(d.Tuple);const n=e.slice(2),s=K.split(n,t.Comma),o=new Rs(oe(n),n,t.TupleDefinition,s);for(o.setParent(this);e.length>2;)e.pop();e.push(o),u(this,Ue).push(e[0]),y(this,ot,e[2])}else this.setDataType(d.Invalid),y(this,ot,e[u(this,Pe)-1]),y(this,Ue,u(this,Pe)>-1?e.slice(0,u(this,Pe)):[]),y(this,Tn,u(this,Pe)>-1?e.slice(u(this,Pe)+1):[])},Ja=function(){const e=m(this,Ee,Ka).call(this),n=u(this,Ue)[0],s=[new Br(e.entity.name,e.entity,e.category,-1,-1),this.getChildren()[2]];if(n.is(t.VariableName)){const c=new _t(n.getTextValue(),n.getEntity(),n.getCategory(),-1,-1,-1,!0);s.unshift(c)}else{const c=n.getChildren(),f=new Us("Placeholder",[c[0],c[1]]);s.unshift(f)}const o=new Es("Placeholder",s);u(this,Tn).push(o),n.setDataType(o.getDataType()),o.addObserver(n)},Ka=function(){const n=this.getChildren()[u(this,Pe)].getTextValue().replace("=","");return We(n)},Wa=function(){const e=this.getChildren();for(let n=0;n<e.length;n++)if(e[n].isChangeOperator()){y(this,Pe,n);break}},ja=function(e){const n=[],s=e.getAssignedValue();return(s.getDataType()===d.None&&!s.isOneOf([t.NoneType,t.VariableName])||Ct(s))&&n.push(O.createStatementSymptom(b.AssignedNone,[s],0,0,{expression:s,usage:ai,target:u(e,Ue)[0].getTextValue()})),n};class fu extends Y{constructor(e,n){super(e,n,t.GroupStatement,a.Group,d.NotParsed);I(this,Nn);I(this,ne);if(n.length>2){const s=n.slice(1,n.length-1);s.length>1?y(this,ne,K.createTree(n.slice(1,n.length-1))):y(this,ne,[s[0]])}else y(this,ne,[]);m(this,Nn,qa).call(this),this.setDataType(u(this,ne).length===1?u(this,ne)[0].getDataType():d.Unknown),u(this,ne).length===1?u(this,ne)[0].addObserver(this):this.setDataType(d.Invalid),this.addRule(m(this,Nn,Ha))}getContents(){return u(this,ne)}getVariableExpressions(){let e=[];for(let n of u(this,ne))e=e.concat(n.getVariableExpressions());return e}getExpressionsOfKind(e){let n=super.getExpressionsOfKind(e);for(let s of u(this,ne))s.is(e)?n.push(s):n=n.concat(s.getExpressionsOfKind(e));return n}getFirstExpressionOf(e){let n=super.getFirstExpressionOf(e);if(n===void 0)for(const s of u(this,ne)){if(s.isOneOf(e))return s;if(n=s.getFirstExpressionOf(e),n!==void 0)return n}return n}checkForSymptoms(){this.checkRules(this);for(const e of u(this,ne))e.checkForSymptoms()}matchesPattern(e){const n=this.getContents();for(const s of n)if(!s.matchesPattern(e))return!1;return!0}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...u(this,ne).flatMap(n=>n.getAllNestedExpressions())]}toJSON(){const e=super.toJSON();return e.contents=u(this,ne).map(n=>n.toJSON()),e}}ne=new WeakMap,Nn=new WeakSet,qa=function(){for(let e=0;e<u(this,ne).length;e++)e<u(this,ne).length-1&&u(this,ne)[e].addConnection(u(this,ne)[e+1]),u(this,ne)[e].setParent(this),this.addConnection(u(this,ne)[e])},Ha=function(e){const n=[],s=e.getContents();for(let o=0;o<s.length;o++)s[o].is(t.Colon)&&n.push(O.createStatementSymptom(b.UnexpectedColon,s,0,s.length-1,{before:o>0?s[o-1].getTextValue():ce,after:o<s.length-1?s[o+1].getTextValue():ce}));return n};class Vr extends Y{constructor(e,n,s=[]){super(e,n,t.Slice,a.Other,d.NA);I(this,Oe);y(this,Oe,s);for(let o=0;o<u(this,Oe).length;o++){u(this,Oe)[o].length>1&&(u(this,Oe)[o]=K.createTree(u(this,Oe)[o]));for(const c of u(this,Oe)[o])c.setParent(this),this.addConnection(c)}}isComplete(){const e=this.getChildren();return e.length>=4&&e[0].is(t.OpenSquareBracket)&&e[e.length-1].is(t.CloseSquareBracket)&&En(e,t.Colon)}getVariableExpressions(){let e=[];for(let n of u(this,Oe))for(let s of n)e=e.concat(s.getVariableExpressions());return e}checkForSymptoms(){this.checkRules(this);for(const e of u(this,Oe))for(const n of e)n.checkForSymptoms()}matchesPattern(e){return this.getEntity()===e.getEntity()}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...u(this,Oe).flatMap(n=>n.flatMap(s=>s.getAllNestedExpressions()))]}toJSON(){const e=super.toJSON();return e.indices=u(this,Oe).map(n=>n.map(s=>s.toJSON())),e}getIndices(){return u(this,Oe)}}Oe=new WeakMap;class vr extends Y{constructor(e,n){super(e,n,t.IndexKey,a.Other,d.NA);I(this,at,[]);n.length>2&&y(this,at,K.createTree(n.slice(1,n.length-1)));for(const s of u(this,at))s.setParent(this),this.addConnection(s)}isComplete(){const e=this.getChildren();return e.length>=3&&e[0].is(t.OpenSquareBracket)&&e[e.length-1].is(t.CloseSquareBracket)}getVariableExpressions(){let e=[];for(let n of u(this,at))e=e.concat(n.getVariableExpressions());return e}checkForSymptoms(){this.checkRules(this);for(const e of u(this,at))e.checkForSymptoms()}matchesPattern(e){return this.getEntity()===e.getEntity()}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...u(this,at).flatMap(n=>n.getAllNestedExpressions())]}toJSON(){const e=super.toJSON();return e.index=u(this,at).map(n=>n.toJSON()),e}}at=new WeakMap;const ds=class ds extends Y{constructor(e,n){var o;let s=m(o=ds,us,_i).call(o,n);super(e,n,t.SubscriptedExpression,a.MultipartValue,s);I(this,Cn);n[0].addObserver(this);for(const c of n)this.addConnection(c);this.addRules([m(this,Cn,Qa),m(this,Cn,za)])}matchesPattern(e){if(this.getEntity()!==e.getEntity())return!1;const n=this.getChildren(),s=e.getChildren();return n.length>0&&s.length>0&&n[0].matchesPattern(s[0])}isComplete(){const e=this.getChildren();return e.length===2&&e[1].isOneOf(t.IndexKey,t.Slice)}setDataType(e){var s;const n=m(s=ds,us,_i).call(s,this.getChildren());super.setDataType(n)}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...this.getChildren().flatMap(n=>n.getAllNestedExpressions())]}toJSON(){const e=super.toJSON();return e.nodes=this.getChildren().map(n=>n.toJSON()),e}};Cn=new WeakSet,za=function(e){const n=[];return(e.getParent()===void 0||e.getParent().is(t.GroupStatement)&&e.getParent().getParent()===void 0)&&n.push(O.createStatementSymptom(b.UnusedValue,[e],0,0)),n},Qa=function(e){const n=[],s=e.getChildren();return s.length>0&&!As(s[0].getDataType())&&n.push(O.createStatementSymptom(b.SubscriptedNonSubscriptable,s,0,s.length-1,{isUndefined:s[0].getDataType()===d.Undefined,subscriptedType:s[0].getDataType(),varName:s[0].getTextValue()})),n},us=new WeakSet,_i=function(e){if(e.length!==2)return d.Unknown;if(e[0].getDataType()===d.String)return d.String;if(e[1].is(t.Slice)){const n=e[0].getDataType();return n===d.NotParsed||n===d.Unknown||n===d.List||n===d.Tuple||n===d.String?n:d.Invalid}return d.Unknown},I(ds,us);let Us=ds;const Ut=class Ut extends Y{constructor(e,n){var o,c;let s=n.length===3?m(o=Ut,_e,er).call(o,...n):n.length===2?m(c=Ut,_e,tr).call(c,n[1]):d.Unknown;super(e,n,t.CalculatedExpression,a.MultipartValue,s);I(this,Ge);n.length===3?(n[0]!==void 0&&n[0].addObserver(this),n[2]!==void 0&&n[2].addObserver(this)):n.length>0&&n[1]!==void 0&&n[1].addObserver(this),m(this,Ge,Xa).call(this),this.addRules([m(this,Ge,tl),m(this,Ge,el),m(this,Ge,_a),m(this,Ge,Ya)])}setDataType(e){var s,o;const n=this.getChildren();e=n.length===3?m(s=Ut,_e,er).call(s,...n):m(o=Ut,_e,tr).call(o,n[1]),super.setDataType(e)}matchesPattern(e){if(this.getEntity()!==e.getEntity())return!1;const n=this.getChildren(),s=e.getChildren();if(n.length!==s.length)return!1;const o=new Map;for(const c of n){let f=!1;for(const p of s)if(c.matchesPattern(p)){f=!0;break}if(!f&&!c.is(t.VariableName))return!1;c.is(t.VariableName)&&o.set(c.getTextValue(),f)}return o.size===0?!0:Array.from(o.values()).filter(c=>c===!0).length>0}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...this.getChildren().flatMap(n=>n.getAllNestedExpressions())]}toJSON(){const e=super.toJSON();return e.nodes=this.getChildren().map(n=>n.toJSON()),e}};Ge=new WeakSet,Xa=function(){const e=this.getChildren();for(let n=0;n<e.length;n++)this.addConnection(e[n]),n<e.length-1&&e[n].addConnection(e[n+1])},_e=new WeakSet,er=function(e,n,s){const o=e.getDataType(),c=s.getDataType();return e.is(t.StringLiteral)&&n.is(t.ModulusOperator)?d.String:o===d.NotParsed||c===d.NotParsed?d.NotParsed:o===d.Undefined&&e.is(t.VariableName)&&e.isProxy()||c===d.Undefined&&s.is(t.VariableName)&&s.isProxy()?d.Undefined:o===d.Unknown||c===d.Unknown?d.Unknown:o===d.Invalid||c===d.Invalid||o===d.NA||c===d.NA?d.Invalid:e.isNumeric()&&s.isNumeric()?m(this,_e,Za).call(this,e,n,s):n.isOneOf([t.ExponentOperator,t.DivideOperator,t.IntDivideOperator])?d.Invalid:n.is(t.MultiplyOperator)?e.isNonFloatNumeric()&&(c===d.String||c===d.List||c===d.Tuple)?c:s.isNonFloatNumeric()&&(o===d.String||o===d.List||o===d.Tuple)?o:d.Invalid:n.is(t.ModulusOperator)?o===d.String?d.String:d.Invalid:n.is(t.AddOperator)?o===c&&(o===d.String||o===d.List||o===d.Tuple)||o===d.List&&(c===d.String||c===d.Dict||c===d.Set||c===d.Tuple)?o:d.Invalid:n.is(t.SubtractOperator)&&o===d.Set&&o===c?o:d.Invalid},tr=function(e){const n=e.getDataType();return n===d.Float||n===d.Int||n===d.Number||n===d.NotParsed||n===d.Unknown?n:n===d.Bool?d.Int:d.Invalid},Za=function(e,n,s){return n.is(t.DivideOperator)?d.Float:e.getDataType()===s.getDataType()&&e.getDataType()!==d.Bool?e.getDataType():e.isIntLike()&&s.isIntLike()?d.Int:e.getDataType()===d.Float||s.getDataType()===d.Float?d.Float:d.Number},Ya=function(e){const n=[];return(e.getParent()===void 0||e.getParent().is(t.GroupStatement)&&e.getParent().getParent()===void 0)&&n.push(O.createStatementSymptom(b.UnusedValue,[e],0,0)),n},_a=function(e){const n=[],s=e.getChildren();for(let o=0;o<s.length;o++)s[o].is(t.Colon)&&n.push(O.createStatementSymptom(b.UnexpectedColon,s,0,s.length-1,{before:o>0?s[o-1].getTextValue():ce,after:o<s.length-1?s[o+1].getTextValue():ce}));return n},el=function(e){const n=[],s=e.getChildren();return e.getDataType()===d.Invalid&&s.filter(o=>o.getDataType()===d.Undefined||o.getDataType()===d.Invalid).length===0&&n.push(O.createStatementSymptom(b.TypeErrorInvalid,s,0,s.length-1,{parts:s.map(o=>o.getDataType()===d.NA?o.getTextValue():o.getDataType().name)})),n},tl=function(e){const n=[],c=e.getChildren().flatMap(f=>f.is(t.GroupStatement)?f.getContents():f).filter(f=>Ct(f)||f.getDataType()===d.None&&!f.isOneOf([t.NoneType,t.VariableName]));return c.length>0&&n.push(...c.map(f=>O.createStatementSymptom(b.AssignedNone,[f],0,0,{expression:f,usage:dc}))),n},I(Ut,_e);let Es=Ut;const fs=class fs extends Y{constructor(e,n){var o;let s=n.length===3?m(o=fs,hs,nr).call(o,...n):d.Unknown;super(e,n,t.ComparisonExpression,a.MultipartValue,s);I(this,$e);n.length===3&&(n[0].addObserver(this),n[2].addObserver(this)),m(this,$e,nl).call(this),this.addRules([m(this,$e,ol),m(this,$e,rl),m(this,$e,il),m(this,$e,sl)])}setDataType(e){var s;const n=m(s=fs,hs,nr).call(s,...this.getChildren());n!==this.getDataType()&&super.setDataType(n)}matchesPattern(e){if(this.getEntity()!==e.getEntity())return!1;const n=this.getChildren(),s=e.getChildren();if(n.length!==s.length)return!1;const o=new Map;for(let c=0;c<n.length;c++){if(n[c].isOneOf([t.InKeyword,t.NotInKeyword])){const p=n[c].is(t.InKeyword)?t.NotInKeyword:t.InKeyword;for(let w=0;w<s.length;w++)if(s[w].is(p))return c>0&&c<n.length-1&&w>0&&w<s.length-1?n[c-1].matchesPattern(s[w-1])&&n[c+1].matchesPattern(s[w+1]):!1;return!1}let f=!1;for(const p of s)if(n[c].matchesPattern(p)){f=!0;break}if(!f&&!n[c].isOneOf([t.VariableName,t.BuiltInFunctionCall,t.UserDefinedFunctionCall,t.SubscriptedExpression]))return!1;n[c].isOneOf([t.VariableName,t.BuiltInFunctionCall,t.UserDefinedFunctionCall,t.SubscriptedExpression,t.CalculatedExpression])&&o.set(n[c].getTextValue(),f)}return o.size===0?!1:Array.from(o.values()).filter(c=>c===!0).length>0}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...this.getChildren().flatMap(n=>n.getAllNestedExpressions())]}toJSON(){const e=super.toJSON();return e.nodes=this.getChildren().map(n=>n.toJSON()),e}convertToIterator(){const e=this.getChildren();return e.length===3&&(e[0].removeObserver(this),e[2].removeObserver(this)),new wi(this.getTextValue(),e)}};$e=new WeakSet,nl=function(){const e=this.getChildren();for(let n=0;n<e.length;n++)this.addConnection(e[n]),n<e.length-1&&e[n].addConnection(e[n+1])},hs=new WeakSet,nr=function(e,n,s){const o=e.getDataType(),c=s.getDataType();return n.isOneOf([t.EqualOperator,t.NotEqualOperator,t.IsKeyword,t.IsNotKeyword])?d.Bool:n.isOneOf([t.InKeyword,t.NotInKeyword])?c===d.String&&(o===d.String||o===d.Unknown||o===d.NotParsed)||c===d.List||c===d.Tuple||c===d.Set||c===d.Dict||c===d.Unknown?d.Bool:c===d.NotParsed?d.NotParsed:d.Invalid:o===d.NotParsed||c===d.NotParsed?d.NotParsed:o===d.None||c===d.None?d.Invalid:o===d.Unknown||c===d.Unknown||e.isNumeric()&&s.isNumeric()||o===c?d.Bool:d.Invalid},sl=function(e){const n=[],s=e.getChildren();return!(s[0]!==void 0&&s[0].is(t.BuiltInFunctionCall)&&s[0].getFunctionExpression().is(t.AssertFunction))&&(e.getParent()===void 0||e.getParent().is(t.GroupStatement)&&e.getParent().getParent()===void 0)&&n.push(O.createStatementSymptom(b.UnusedValue,[e],0,0)),n},il=function(e){const n=[],s=e.getChildren();for(let o=0;o<s.length;o++)s[o].is(t.Colon)&&n.push(O.createStatementSymptom(b.UnexpectedColon,s,0,s.length-1,{before:o>0?s[o-1].getTextValue():ce,after:o<s.length-1?s[o+1].getTextValue():ce}));return n},rl=function(e){const n=[],s=e.getChildren();return s.length===3&&s[0].getDataType()===d.Bool&&s[1].isOneOf([t.EqualOperator,t.IsKeyword])&&s[2].isOneOf([t.TrueType,t.FalseType])&&n.push(O.createStatementSymptom(b.CompareBoolLiteral,s,0,s.length-1,{boolValue:s[0].getTextValue(),operator:s[1].getTextValue(),boolLiteral:s[2].getTextValue(),usedIn:e.getContextOfUse()})),n},ol=function(e){const n=[],c=e.getChildren().flatMap(f=>f.is(t.GroupStatement)?f.getContents():f).filter(f=>!(f.is(t.BuiltInFunctionCall)&&f.getFunctionExpression().is(t.AssertFunction))&&(Ct(f)||f.getDataType()===d.None&&!f.isOneOf([t.NoneType,t.VariableName])));return c.length>0&&n.push(...c.map(f=>O.createStatementSymptom(b.AssignedNone,[f],0,0,{expression:f,usage:hc}))),n},I(fs,hs);let pi=fs;const ps=class ps extends Y{constructor(e,n){var o;const s=m(o=ps,gs,sr).call(o,n);super(e,n,t.BooleanExpression,a.MultipartValue,s);I(this,qe);n.length===3&&n[1].is(a.LogicalOperators)&&(n[0].addObserver(this),n[2].addObserver(this)),m(this,qe,al).call(this),this.addRules([m(this,qe,ul),m(this,qe,cl),m(this,qe,ll)])}setDataType(e){var s;const n=m(s=ps,gs,sr).call(s,this.getChildren());n!==this.getDataType()&&super.setDataType(n)}matchesPattern(e){const n=this.getChildren();if(this.getEntity()!==e.getEntity())return e.is(t.VariableName)&&n.length===2&&n[0].is(t.NotOperator)&&n[1].is(t.VariableName)?n[1].matchesPattern(e):!1;const s=e.getChildren(),o=new Map;for(const c of n){if(c.is(t.NotOperator))continue;let f=!1;for(const p of s)if(!p.is(t.NotOperator)&&c.matchesPattern(p)){f=!0;break}if(!f&&!c.is(t.VariableName))return!1;c.is(t.VariableName)&&o.set(c.getTextValue(),f)}return o.size===0?!0:Array.from(o.values()).filter(c=>c===!0).length>0}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...this.getChildren().flatMap(n=>n.getAllNestedExpressions())]}toJSON(){const e=super.toJSON();return e.nodes=this.getChildren().map(n=>n.toJSON()),e}};qe=new WeakSet,al=function(){const e=this.getChildren();for(let n=0;n<e.length;n++)this.addConnection(e[n]),n<e.length-1&&e[n].addConnection(e[n+1])},gs=new WeakSet,sr=function(e){if(e.length===2&&e[0].is(t.NotOperator))return d.Bool;if(e.length===3&&e[1].is(a.LogicalOperators)){const n=e[0].getDataType(),s=e[2].getDataType();return n===s?n:n===d.NotParsed||s===d.NotParsed?d.NotParsed:d.Unknown}else return d.Invalid},ll=function(e){const n=[];return(e.getParent()===void 0||e.getParent().is(t.GroupStatement)&&e.getParent().getParent()===void 0)&&n.push(O.createStatementSymptom(b.UnusedValue,[e],0,0)),n},cl=function(e){const n=[],s=e.getChildren();for(let o=0;o<s.length;o++)s[o].is(t.Colon)&&n.push(O.createStatementSymptom(b.UnexpectedColon,s,0,s.length-1,{before:o>0?s[o-1].getTextValue():ce,after:o<s.length-1?s[o+1].getTextValue():ce}));return n},xd=function(e,n){const s=e.getDataType(),o=n.getDataType();return s!==d.Bool&&s!==d.Unknown||o!==d.Bool&&o!==d.Unknown},ul=function(e){const n=[],s=e.getChildren();if(s.length===3){const o=s[0].getDataType(),c=s[2].getDataType();(o!==d.Bool&&o!==d.Unknown||c!==d.Bool&&c!==d.Unknown)&&n.push(O.createStatementSymptom(b.NaturalLanguageBoolean,s,0,2,{form:ac,leftSideType:s[0].getDataType(),leftSideText:s[0].getTextValue(),leftSideEntity:s[0].getEntity(),operator:s[1].getTextValue(),rightSideType:s[2].getDataType(),rightSideText:s[2].getTextValue(),rightSideEntity:s[2].getEntity(),tempExpression:e}))}return n},I(ps,gs);let mi=ps;class wi extends Y{constructor(e,n){super(e,n,t.IteratorExpression,a.MultipartValue,d.NA);I(this,be);I(this,Mn);I(this,he);I(this,se,[]);m(this,be,hl).call(this),m(this,be,dl).call(this),this.addRules([m(this,be,pl),m(this,be,gl)])}checkForSymptoms(){this.checkRules(this),u(this,he).checkForSymptoms();for(const e of u(this,se))e.checkForSymptoms()}getVariableExpressions(){let e=u(this,he).getVariableExpressions();for(let n of u(this,se))e=e.concat(n.getVariableExpressions());return e}setDataType(e){m(this,be,ir).call(this)}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...u(this,se).flatMap(n=>n.getAllNestedExpressions()),...u(this,he).getAllNestedExpressions()]}toJSON(){const e=super.toJSON();return e.loopVariables=u(this,se).map(n=>n.toJSON()),e.iterable=u(this,he).toJSON(),e}getLoopVariables(){return u(this,se)}getIterable(){return u(this,he)}}Mn=new WeakMap,he=new WeakMap,se=new WeakMap,be=new WeakSet,dl=function(){const e=this.getChildren();for(let n=0;n<e.length;n++)this.addConnection(e[n]),n<e.length-1&&e[n].addConnection(e[n+1])},hl=function(){const e=this.getChildren();y(this,Mn,Zt(e,t.InKeyword)),y(this,he,e[e.length-1]),y(this,se,u(this,Mn)===1&&e[0].is(t.TupleDefinition)?e[0].getElements().filter(n=>n[0].is(t.VariableName)).map(n=>n[0]):e.slice(0,u(this,Mn)).filter(n=>n.is(t.VariableName)));for(let n of u(this,se))n.setAssignedOrChanged();m(this,be,fl).call(this)},fl=function(){if(u(this,he).isOneOf([t.BuiltInFunctionCall,t.BuiltInMethodCall])){const e=u(this,he).is(t.BuiltInMethodCall)?u(this,he).getMethodEntity():u(this,he).getFunctionEntity();if(e===t.EnumerateFunction)if(u(this,se).length===1)u(this,se)[0].setDataType(d.Tuple);else if(u(this,se).length===2){u(this,se)[0].setDataType(d.Int);const n=u(this,he).getArguments(),s=n.length===1&&n[0].length===1&&n[0][0].getDataType()===d.String?d.String:d.Unknown;u(this,se)[1].setDataType(s)}else for(const n of u(this,se))n.setDataType(d.Unknown);else if(e===t.RangeFunction&&u(this,se).length===1)u(this,se)[0].setDataType(d.Int);else if(Mt.get(e)===d.String&&u(this,se).length===1)u(this,se)[0].setDataType(d.String);else for(const n of u(this,se))n.setDataType(d.Unknown)}else u(this,he).addObserver(this),m(this,be,ir).call(this)},ir=function(){const e=u(this,he).getDataType()===d.String||u(this,he).getDataType()===d.File?d.String:d.Unknown;for(let n of u(this,se))n.setDataType(e)},gl=function(e){const n=[],s=u(e,he).getVariableExpressions();for(const o of u(e,se))for(const c of s)if(o.getTextValue()===c.getTextValue()){const f=o.getLastUsages(),p=c.getLastUsages().length>0&&c.getLastUsages()[0].isParameter();n.push(O.createStatementSymptom(b.OverwrittenVariable,[o],0,0,{isParameter:p,functionBlock:p?f[0].getBlockId():"",prevUsageIsDefinition:!1,overwriteType:oc,overwriteValue:o.compareValues(o,[f[f.length-1]]),usageText:e.getParent().getTextValue(),overwrittenVar:[{lineNumber:f[f.length-1].getStartLineNumber(),blockId:f[f.length-1].getBlockId(),docIndex:f[f.length-1].getDocumentStartIndex(),forLoopDefinition:f[f.length-1].getParent().is(t.IteratorExpression)&&f[f.length-1].getParent().getLoopVariables().filter(w=>w.getTextValue()===f[f.length-1].getTextValue()).length>0}]}))}return n},pl=function(e){const n=[],s=e.getChildren();for(let o=0;o<s.length;o++)s[o].is(t.Colon)&&n.push(O.createStatementSymptom(b.UnexpectedColon,s,0,s.length-1,{before:o>0?s[o-1].getTextValue():ce,after:o<s.length-1?s[o+1].getTextValue():ce}));return n};class gu extends Y{constructor(e,n){if(n.length<4)throw new Error("A lambda expression must have a minimum of 4 children");const s=K.split(n.slice(1),t.Colon);if(s.length!==2)throw new Error("Lambda expects at least one argument and a return value");const o=K.split(s[0],t.Comma);for(const f of o)for(const p of f)p.is(t.VariableName)&&(p.setAssignedOrChanged(),p.setDataType(d.Unknown));const c=K.createTree(s[1]);if(c.length!==1)throw new Error("Lambda can only have one return value");super(e,n,t.LambdaDefinitionStatement,a.BlockDefinitions,c[0].getDataType());I(this,ms);I(this,ws);y(this,ms,o),y(this,ws,c[0]),c[0].addObserver(this)}getVariableExpressions(){let e=[];for(let n of this.getChildren())n.is(t.VariableName)?e.push(n):e=e.concat(n.getVariableExpressions());return e}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...this.getChildren().flatMap(n=>n.getAllNestedExpressions())]}toJSON(){const e=super.toJSON();return e.arguments=u(this,ms).map(n=>n.map(s=>s.toJSON())),e.return=u(this,ws).toJSON(),e}}ms=new WeakMap,ws=new WeakMap;const Is=class Is extends Y{constructor(e,n){var o;if(n.length!==5)throw new Error("Ternary should contain 5 children");let s=m(o=Is,Ss,rr).call(o,n);super(e,n,t.TernaryStatement,a.BlockDefinitionStatement,s);I(this,Zs);n[0].addObserver(this),n[4].addObserver(this),this.addRule(m(this,Zs,ml))}setDataType(e){var s;const n=m(s=Is,Ss,rr).call(s,this.getChildren());n!==this.getDataType()&&super.setDataType(n)}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...this.getChildren().flatMap(n=>n.getAllNestedExpressions())]}toJSON(){const e=super.toJSON();return e.nodes=this.getChildren().map(n=>n.toJSON()),e}};Ss=new WeakSet,rr=function(e){return e.length===5?Nt([e[0].getDataType(),e[4].getDataType()]):d.Unknown},Zs=new WeakSet,ml=function(e){const n=[];if(e.getDataType()===d.Bool){const s=e.getChildren();if(s[0].is(t.TrueType)&&s[4].is(t.FalseType)){let o=e.getParent();for(;o.is(t.GroupStatement);)o=o.getParent();const c=f=>{switch(f){case t.ReturnStatement.name:return"return";case t.AssignmentStatement.name:return"assignment";default:return"unknown"}};n.push(O.createStatementSymptom(b.TernaryReturnsBool,s,0,s.length-1,{boolValue:s[2].getTextValue(),boolLiteralIfTrue:s[0].getTextValue(),boolLiteralIfFalse:s[4].getTextValue(),parentText:o?o.getTextValue():"",parentEntity:o?c(o.getEntity().name):""}))}}return n},I(Is,Ss);let Si=Is;const Ci=class Ci extends Y{constructor(e,n){if(n.length<3||n.length>5)throw new Error("List comprehension should contain 3-5 children");super(e,n,t.ListComprehension,a.BlockDefinitionStatement,d.List);I(this,On);const s=`${n[0].getStartLineNumber()}-listComprehension-${n[0].getDocumentStartIndex()}`;this.setBlockId(s),this.setScopeId(s),m(this,On,Sl).call(this)}getVariableExpressions(){let e=[];const n=this.getChildren(),s=m(this,On,wl).call(this);if(s>-1){e=e.concat(n[s].getVariableExpressions());for(let o=0;o<n.length;o++)o!==s&&(e=e.concat(n[o].getVariableExpressions()))}return e}copyAndConvertToPlaceholder(){const e=new Ci(this.getTextValue(),this.getChildren());return this.setTextValue(""),this.setChildren([]),e}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...this.getChildren().flatMap(n=>n.getAllNestedExpressions())]}toJSON(){const e=super.toJSON();return e.nodes=this.getChildren().map(n=>n.toJSON()),e}};On=new WeakSet,wl=function(){const e=this.getChildren();for(let n=0;n<e.length;n++)if(e[n].is(t.IteratorExpression))return n;return-1},Sl=function(){const e=this.getChildren();if(e.length>0&&e[0].is(t.ListComprehension)&&e[2].is(t.IteratorExpression)){const n=e[0].getChildren();if(n.length>=3&&n[2].is(t.IteratorExpression)){const s=e[2].getIterable(),o=n[2].getLoopVariables();for(const c of o)c.getTextValue()===s.getTextValue()&&(c.addObserver(s),s.setDataType(c.getDataType()),s.setAssignedOrChanged())}}};let Ii=Ci;class pu extends Y{constructor(e,n){if(n.length===0||!n[0].is(t.ReturnKeyword))throw new Error("Not a valid return statement");let s=d.None;if(n.length===2)s=n[1].getDataType();else if(n.length>2)if(En(n,t.Comma)){s=d.Tuple;const o=n.slice(1),c=K.split(o,t.Comma),f=new Rs(oe(o),o,t.TupleDefinition,c);n=[n[0],f]}else s=d.Invalid;super(e,n,t.ReturnStatement,a.MultipartValue,s);I(this,Je);n.length===2&&(n[1].addObserver(this),this.addConnection(n[1])),this.addRules([m(this,Je,Tl),m(this,Je,Fl),m(this,Je,Il),m(this,Je,yl)])}getReturnedValue(){return this.getChildren().slice(1)}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...this.getChildren().flatMap(n=>n.getAllNestedExpressions()).slice(1)]}toJSON(){const e=super.toJSON();return e.returnedValue=this.getReturnedValue().map(n=>n.toJSON()),e}}Je=new WeakSet,Il=function(e){var o;const n=[],s=e.getChildren();return s.length===2&&s[1].is(t.GroupStatement)&&n.push(O.createStatementSymptom(b.ReturnInParentheses,s,0,1,{contents:m(o=e,Je,bl).call(o,s[1]),textInParentheses:s[1].getTextValue().substring(1,s[1].getTextValue().length-1)})),n},bl=function(e){const n=e.getContents();if(n.length===1){if(n[0].isOneOf([a.Literals,a.Types]))return ic;if(n[0].isOneOf([t.VariableName,t.SubscriptedExpression]))return rc;if(n[0].isOneOf([a.FunctionCall,a.MethodCall]))return hr;if(n[0].is(a.CompoundTypes))return fr}return gr},yl=function(e){const n=[],s=e.getChildren();for(let o=0;o<s.length;o++)s[o].is(t.Colon)&&n.push(O.createStatementSymptom(b.UnexpectedColon,s,0,s.length-1,{before:o>0?s[o-1].getTextValue():ce,after:o<s.length-1?s[o+1].getTextValue():ce}));return n},Fl=function(e){const n=[],c=e.getChildren().flatMap(f=>f.is(t.GroupStatement)?f.getContents():f).filter(f=>Ct(f)||f.getDataType()===d.None&&!f.isOneOf([t.NoneType,t.VariableName]));return c.length>0&&n.push(...c.map(f=>O.createStatementSymptom(b.AssignedNone,[f],0,0,{expression:f,usage:dr}))),n},Tl=function(e){const n=e.getChildren(),s=[];for(let o=1;o<n.length;o++)if(n[o].is(t.AssignmentStatement)){const c=n[o].getTargetVariables().map(f=>f.getTextValue());s.push(O.createStatementSymptom(b.AssignmentInReturn,n,o,o,{assignedVariables:c}))}return s};class mu extends Y{constructor(e,n){super(e,n,t.ImportStatement,a.KeywordStatement,d.NA);I(this,Ys);I(this,Dn,[]);if(n.length>1&&(y(this,Ys,n[1]),n[0].is(t.FromKeyword)))for(let s=3;s<n.length;s++)n[s].is(t.Comma)||u(this,Dn).push(n[s])}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...u(this,Dn).flatMap(n=>n.getAllNestedExpressions())]}toJSON(){const e=super.toJSON();return e.importedEntities=u(this,Dn).map(n=>n.toJSON()),e}}Ys=new WeakMap,Dn=new WeakMap;class wu extends Y{constructor(e,n){if(n.length===0)throw new Error("Not enough elements to make a statement");let s=t.Unknown;if(n[0].is(t.AssertKeyword))s=t.AssertStatement;else if(n[0].is(t.GlobalKeyword))s=t.GlobalStatement;else if(n[0].is(t.RaiseKeyword))s=t.ThrowStatement;else throw new Error("Unknown keyword");super(e,n,s,a.KeywordStatement,d.NA);I(this,xn,[]);y(this,xn,n.slice(1))}getAllNestedExpressions(){return[...super.getAllNestedExpressions(),...u(this,xn).flatMap(n=>n.getAllNestedExpressions())]}toJSON(){const e=super.toJSON();return e.keyword=this.getChildren()[0].toJSON(),e.values=u(this,xn).map(n=>n.toJSON()),e}}xn=new WeakMap;const Gt=class Gt extends Ps{constructor(e,n,s,o=[],c=!0,f=!1){super();I(this,Ve);I(this,Et);l(this,"lineNumbers",new Set);I(this,me);I(this,bs);I(this,ys);I(this,Le);y(this,Et,e),this.lineNumbers.add(n),y(this,ys,s),y(this,bs,s.getSpaceCount()+s.getTabCount()),o.length>0&&(o[o.length-1].is(t.ContinuationLine)&&o.pop(),o.length>0&&o[0].isOneOf([t.IfDefinition,t.ElifDefinition,t.WhileDefinition])&&this.addRule(m(this,Ve,Ol))),y(this,me,o),this.addRule(m(this,Ve,Cl)),c&&m(this,Ve,or).call(this,f)}getRawText(){return u(this,Et)}updateRawText(e){y(this,Et,e)}getLineNumbers(){return this.lineNumbers}getFirstLineNumber(){return this.lineNumbers.size>0?Math.min(...Array.from(this.lineNumbers)):-1}getLastLineNumber(){return this.lineNumbers.size>0?Math.max(...Array.from(this.lineNumbers)):-1}addLineNumber(e){this.lineNumbers.add(e)}getIndentation(){return u(this,bs)}getIndent(){return u(this,ys)}getExpressions(){return u(this,Le)===void 0?u(this,me):u(this,Le)}getRawExpressions(){return u(this,me)}containsExpression(e){for(let n of this.getExpressions())if(n.contains(e))return!0;return!1}getVariableUsages(){const e=new Map;for(let n of u(this,Le)){const s=n.getVariableExpressions();for(let o of s)e.has(o.getTextValue())||e.set(o.getTextValue(),[]),e.get(o.getTextValue()).push(o)}return e}isBlank(){return u(this,Le).length===0}getFirstExpression(){if(this.isBlank())throw new Error("Statement is blank. Could not get first expression.");return u(this,Le)[0]}isBlockStatement(){return!1}isDefinitionOfBlock(){return u(this,Le).length===0?!1:u(this,Le)[0].is(a.BlockDefinitionStatement)}static createFromSource(e,n=!1){return new Gt(e.getText(),e.getLineNumber(),e.getIndent(),e.getExpressions(),!e.continuesOnNextLine(),n)}continueFromSource(e){this.addLineNumber(e.getLineNumber()),m(this,Ve,Nl).call(this,e.getExpressions()),this.updateRawText(u(this,Et)+`
`+e.getText()),e.continuesOnNextLine()||m(this,Ve,or).call(this)}toJSON(){return{expressions:u(this,Le).map(e=>e.toJSON())}}};Et=new WeakMap,me=new WeakMap,bs=new WeakMap,ys=new WeakMap,Le=new WeakMap,Ve=new WeakSet,or=function(e=!1){y(this,Le,K.createTree(u(this,me))),e||this.addRules([m(this,Ve,Ml)]),this.checkRules(this)},Nl=function(e){if(e.length>0&&e[0].is(t.OpenParenthesis)&&u(this,me).length>0&&u(this,me)[u(this,me).length-1].is(t.VariableName)){const n=u(this,me).length-1,s=u(this,me)[n];let o=We(u(this,me)[u(this,me).length-1]);o.category!==a.BuiltInFunctions&&(o=new q(t.FunctionName,a.Identifiers)),u(this,me)[n]=Yt(s.getTextValue(),o,s.getStartLineNumber(),s.getDocumentStartIndex(),s.getDocumentEndIndex(),s.getEndLineNumber())}y(this,me,u(this,me).concat(e))},Cl=function(e){var o,c,f;const n=e.getRawExpressions(),s=[];for(let p=0;p<n.length;p++)m(o=Gt,yt,Dl).call(o,n,p)&&s.push(O.createStatementSymptom(b.NaturalLanguageBoolean,n,p,p+1,{form:lc})),m(c=Gt,yt,Bl).call(c,n,p)&&s.push(O.createStatementSymptom(b.OutOfPlaceBooleanOperator,n,p,p)),m(f=Gt,yt,xl).call(f,n,p)&&s.push(O.createStatementSymptom(b.DoubleComparisonOperators,n,p,p+1));return s},Ml=function(e){const n=[],s=u(e,Le);for(let o=0;o<s.length;o++)s[o].is(t.Colon)&&n.push(O.createStatementSymptom(b.UnexpectedColon,s,0,s.length-1,{before:o>0?{type:s[o-1].getEntity().name,value:s[o-1].getTextValue()}:{type:ce},after:o<s.length-1?{type:s[o+1].getEntity().name,value:s[o+1].getTextValue()}:{type:ce}}));return n},Ol=function(e){const n=e.getFirstExpression().getExpressionsOfKind(t.AssignmentStatement),s=[];for(const o of n)s.push(O.createStatementSymptom(b.AssignmentInBoolean,[o],0,0,{parentText:e.getRawText()}));return s},yt=new WeakSet,Dl=function(e,n){return e[n].is(t.AndOperator)&&n<e.length-1&&e[n+1].is(t.OrOperator)},xl=function(e,n){return n<e.length-1&&e[n].isOneOf([t.AssignmentOperator,a.ComparisonOperators])&&e[n+1].isOneOf([t.AssignmentOperator,a.ComparisonOperators])},Bl=function(e,n){return e[n].is(a.LogicalOperators)?!!(!e[n].is(t.NotOperator)&&(n===0||e[n-1].isOneOf([a.LogicalOperators,a.MathsOperators,a.ComparisonOperators,a.BlockDefinitions]))||!e[n].is(t.NotOperator)&&n<e.length-1&&e[n+1].isOneOf([a.LogicalOperators,a.MathsOperators,a.ComparisonOperators,a.BlockDefinitions])&&!e[n+1].is(t.NotOperator)):!1},I(Gt,yt);let Ot=Gt;class Su extends Ot{constructor(e,n){super(e.getRawText(),e.getFirstLineNumber(),e.getIndent());I(this,et);I(this,H,[]);for(const s of e.getExpressions())s.setBlockId(`${e.getFirstLineNumber()}-${e.getRawExpressions()[0].getTextValue()}`),s.setScopeId(n);u(this,H).push(e);for(const s of e.getLineNumbers())this.addLineNumber(s);this.addRules([m(this,et,ar)])}getExpressions(){let e=[];for(let n of u(this,H))e=e.concat(n.getExpressions());return e}getVariableUsages(){const e=new Map;for(let n of u(this,H)){const s=n.getVariableUsages();for(const[o,c]of s)if(!e.has(o))e.set(o,c);else{const f=e.get(o).concat(c);e.set(o,f)}}return e}isBlank(){return!1}getFirstExpression(){if(this.isBlank())throw new Error("Statement is blank. Could not get first expression.");return u(this,H)[0].getFirstExpression()}isBlockStatement(){return!0}getLineNumbers(){const e=new Set;for(let n of u(this,H))for(let s=n.getFirstLineNumber();s<=n.getLastLineNumber();s++)e.add(s);return e}getFirstLineNumber(){return u(this,H).length===0?-1:u(this,H)[0].getFirstLineNumber()}getLastLineNumber(){return u(this,H).length===0?-1:u(this,H)[u(this,H).length-1].getLastLineNumber()}getStatements(){return u(this,H)}getDefinitionStatement(){let e=u(this,H)[0];for(;e.isBlockStatement();)e=e.getDefinitionStatment();return e}addStatement(e,n){const s=u(this,H).length>0&&u(this,H)[u(this,H).length-1].getExpressions().length>0?u(this,H)[u(this,H).length-1].getFirstExpression().getBlockId():"unknown";u(this,H).push(e);for(const f of e.getExpressions())f.setBlockId(s),f.setScopeId(n.getScope().getId());const o=oe(this.getExpressions());this.updateRawText(o);for(let f of e.getLineNumbers())this.addLineNumber(f);K.connectVariableUsages(e,n);const c=n.getBlockEntity()===t.DocumentDefinition?n:n.getParentBlock().getScope();K.connectUserDefinedFunctions(e,c),K.connectUserDefinedMethods(e,c),K.makeGraphConnections(u(this,H))}getBlockStatementForIndent(e){if(u(this,H).length===0||e<=this.getIndentation())return;const n=u(this,H)[u(this,H).length-1];if(!n.isBlockStatement())return this;const s=n.getBlockStatementForIndent(e);return s===void 0?this:s}getLastBlockStatement(){if(u(this,H).length===0)return;const e=u(this,H)[u(this,H).length-1];if(!e.isBlockStatement())return this;const n=e.getLastBlockStatement();return n===void 0?this:n}toJSON(){return{definition:this.getDefinitionStatement().toJSON(),statements:u(this,H).slice(1).map(e=>e.toJSON())}}}H=new WeakMap,et=new WeakSet,ar=function(e){var c,f,p;const n=[],s=e.getDefinitionStatement();s.getFirstExpression().is(t.ForDefinitionStatement)?n.push(...m(c=e,et,kl).call(c,e,s)):s.getFirstExpression().is(t.ExceptDefinitionStatement)&&n.push(...m(f=e,et,Al).call(f,e,s));const o=e.getStatements().filter(w=>w.isBlockStatement());for(const w of o)n.push(...m(p=w,et,ar).call(p,w));return n},Al=function(e,n){const s=[];if(n.getFirstExpression().getChildren().length===3&&n.getFirstExpression().getChildren()[1].is(t.ExceptionName)){const o=n.getFirstExpression().getChildren()[1],c=e.getStatements().slice(1);for(const f of c){const p=f.getFirstExpression();if(p.is(t.ThrowStatement)){const w=p.getExpressionsOfKind(t.ExceptionName);for(const S of w)S.getTextValue()===o.getTextValue()&&s.push(O.createStatementSymptom(b.RedundantException,[p],0,0))}}}return s},Bd=function(e,n){const s=[],o=n.getFirstExpression(),c=o.getVariableExpressions();for(const f of e.getStatements()){const p=f.getExpressions();for(const w of p){if(Xt(w))return s;const S=w.getVariableExpressions().filter(N=>N.isAssignedOrChanged()),F=new Set(S.map(N=>N.getTextValue()));for(const N of c)if(F.has(N.getTextValue()))return s}}return s.push(O.createStatementSymptom(b.InfiniteLoop,[o],0,0)),s},kl=function(e,n){const s=[],o=n.getFirstExpression().getCondition()[0];if(o!==void 0&&o.is(t.IteratorExpression)){const c=o.getLoopVariables(),f=e.getVariableUsages();for(const p of c)if(f.has(p.getTextValue())){const w=f.get(p.getTextValue()).filter(S=>S.getStartLineNumber()!==n.getFirstLineNumber());for(let S=0;S<w.length;S++){const F=w[S].getParent();if(F.is(t.IteratorExpression)&&F.getLoopVariables().filter(N=>N===w[S]).length>0)break;if(w[S].isAssignedOrChanged()&&!(w.slice(S+1).filter(R=>!R.isAssignedOrChanged()).length>0)){const R=n.getFirstExpression().getTextValue(),k=p.getDataType().name;s.push(O.createStatementSymptom(b.ForLoopIteratorModified,[w[S]],0,0,{definitionText:R.trim(),loopVarTypeAtDefinition:k,modificationText:w[S].getParent().getTextValue()}));break}}}}return s};const Iu=(g,i,e)=>{let n=new Map;for(let[s,o]of Hu){const c=o(g,i,e);c.length>0&&n.set(s,bi.create(s,c))}return n},bu=g=>g.filter(e=>e.getID()===b.AssignmentInBoolean.name).map(e=>new J(e.getLineNumber(),e.getDocIndex(),new $([e],"A single equals operator is used in a boolean expression where a double equals operator might be expected."))),yu=g=>{const i=g.filter(n=>n.getID()===b.UnexpectedColon.name&&n.getAdditionalInfo().after.type!==ce&&n.getAdditionalInfo().before.type===t.VariableName.name);let e=[];for(let n of i){const s=new $([n],"The unexpected colon is preceded by a variable name and followed by a value. The intention may be to assign the value to the named variable.");e.push(new J(n.getLineNumber(),n.getDocIndex(),s))}return e},Fu=g=>{const i=g.filter(o=>o.getID()===b.NaturalLanguageBoolean.name&&o.getAdditionalInfo().operator==="or"),e=new Map,n=[];for(const o of i){let c,f=o.getAdditionalInfo().tempExpression.is(t.BooleanExpression)?o.getAdditionalInfo().tempExpression:void 0;try{for(c=o.getAdditionalInfo().tempExpression.getParent();c.is(t.BooleanExpression);)f=c,c=c.getParent()}catch{c=void 0}if(c)try{c.getFirstExpressionOf(t.ComparisonExpression)&&o.getAdditionalInfo().operator==="or"?(e.has(c)||e.set(c,[]),e.get(c).push(o),o.getAdditionalInfo().parentText=c.getTextValue(),o.getAdditionalInfo().parentEntity=c.getEntity(),f&&(o.getAdditionalInfo().completeBooleanExpression=f.getTextValue())):n.push(o)}catch{n.push(o)}else n.push(o)}let s=[];for(const o of e.values()){o.sort((f,p)=>f.getDocIndex()-p.getDocIndex());const c=new $(o,"One or more non-boolean value is used where a boolean expression is expected.");s.push(new J(o[0].getLineNumber(),o[0].getDocIndex(),c))}return s},Tu=g=>{const i=g.filter(n=>n.getID()===b.CompareBoolLiteral.name);let e=[];for(let n of i){const s=n.toJSON();if(s.boolLiteral===tc){const o=new $([n],`${s.boolValue} is a boolean value so ${s.operator} ${s.boolLiteral} is redundant.`);e.push(new J(n.getLineNumber(),n.getDocIndex(),o))}else{const o=new $([n],`${s.boolValue} is a boolean value so the expression can be rewritten as not ${s.boolValue}.`);e.push(new J(n.getLineNumber(),n.getDocIndex(),o))}}return e},Nu=g=>{const i=g.filter(n=>n.getID()===b.UnreachableExit.name&&n.getAdditionalInfo().exitKeyword===dr);g.filter(n=>n.getID()===b.LoopReturn.name&&n.getAdditionalInfo().loopType==="for"&&n.getAdditionalInfo().exitType==="return");let e=[];for(let n of i){const s=new $([n],"Code follows a return statement in the same branch.");e.push(new J(n.getLineNumber(),n.getDocIndex(),s))}return e},Cu=g=>{const i=g.filter(n=>n.getID()===b.OverwrittenVariable.name&&n.getAdditionalInfo().overwriteType===oi&&n.getAdditionalInfo().overwriteValue!==li&&!(n.getAdditionalInfo().prevUsageIsDefinition&&n.getAdditionalInfo().overwrittenVar[n.getAdditionalInfo().overwrittenVar.length-1].forLoopDefinition));let e=[];for(let n of i){const s=new $([n],`The iterating variable ${n.getAffectedText()} is initialised before the loop. ${n.getAdditionalInfo().overwriteValue===mr?"The overwritten value is different from the value initialised by the loop":"It could not be determined if the overwritten value is the same as the value initialised by the loop"}.`);e.push(new J(n.getLineNumber(),n.getDocIndex(),s))}return e},Mu=(g,i)=>{const e=g.filter(f=>f.getID()===b.UndefinedVariable.name),n=Array.from(i.values()).flatMap(f=>f).flatMap(f=>f.getUsages()).filter(f=>f.getVariable().getDataType()===d.Function).map(f=>f.getVariable()),s=g.filter(f=>f.getID()===b.SubscriptedNonSubscriptable.name),o=g.filter(f=>f.getID()===b.VariableWithSameNameAsFunction.name&&(f.getAdditionalInfo().funcType===Qt||f.getAdditionalInfo().funcType===zt&&f.getAdditionalInfo().numArgsExpected>0));let c=[];if(o.length===0||e.length===0&&n.length===0)return c;for(let f of o){const p=f.getAffectedText(),w=f.getDocIndex();for(let S of e)if(S.getAffectedText()===p&&S.getDocIndex()===w&&s.filter(N=>N.getAdditionalInfo().varName===p&&N.getDocIndex()===w).length===0){const N=new $([S,f],`The variable ${p} has not been assigned a value and the file contains a user-defined function of the same name.`);c.push(new J(S.getLineNumber(),S.getDocIndex(),N))}for(let S of n)if(S.getTextValue()===p&&S.getDocumentStartIndex()===w&&s.filter(N=>N.getAdditionalInfo().varName===p&&N.getDocIndex()===w).length===0){const N=new $([f],`The variable ${p} has not been assigned a value and the file contains a user-defined function of the same name.`);c.push(new J(f.getLineNumber(),f.getDocIndex(),N))}}return c},Ou=g=>{const i=g.filter(s=>s.getID()===b.SubscriptedNonSubscriptable.name),e=g.filter(s=>s.getID()===b.VariableWithSameNameAsFunction.name);let n=[];for(let s of i){let o=s.getAdditionalInfo().varName,c=s.getDocIndex();for(let f of e)if(f.getAffectedText()===o&&f.getDocIndex()===c){const p=s.getAdditionalInfo().isUndefined?"undefined variable":s.getAdditionalInfo().subscriptedType==="unknown data type"?"variable with unknown data type":`variable with ${s.getAdditionalInfo().subscriptedType} data type`,w=new $([s,f],`${o} (${p}) has the same name as a function. ${o} is subscripted, suggesting a mistake may have been made while calling a function of the same name. It is possible there is confusion about when to use square brackets versus parentheses.`);n.push(new J(s.getLineNumber(),s.getDocIndex(),w))}}return n},Du=g=>{const i=g.filter(s=>s.getID()===b.LoopVarModifiedInChildLoop.name&&s.getAdditionalInfo().modifiedIn.every(o=>o.loopType==="for"&&o.varDataType==="int")),e=g.filter(s=>s.getID()===b.LoopVarNotModified.name);let n=[];for(let s of i){const o=s.getAffectedText(),c=s.getBlock();for(const f of e)if(f.getBlock()===c&&f.getAdditionalInfo().unmodifiedVars.includes(o)){const p=new $([s,f],`The int variable ${o} is referenced in a while loop condition but only modified in a nested for loop. If ${o} is being used to count the iterated items, the two loops could be replaced with a single for loop using enumerate() or range() to count the items.`);n.push(new J(s.getLineNumber(),s.getDocIndex(),p));break}}return n},xu=g=>{const i=g.filter(n=>n.getID()===b.OverwrittenVariable.name&&n.getAdditionalInfo().overwriteType===oi&&n.getAdditionalInfo().overwriteValue===li&&n.getAdditionalInfo().prevUsageIsDefinition&&!n.getAdditionalInfo().overwrittenVar[n.getAdditionalInfo().overwrittenVar.length-1].forLoopDefinition);let e=[];for(let n of i){const s=new $([n],`The iterating variable ${n.getAffectedText()} is initialised before the loop with the same value that it is initialised with in the for loop definition.`);e.push(new J(n.getLineNumber(),n.getDocIndex(),s))}return e},Bu=(g,i)=>{const e=g.filter(s=>s.getID()===b.UndefinedVariable.name&&s.getAdditionalInfo().variable.getScope().getBlockEntity()===t.DocumentDefinition);let n=[];for(let s of e){const o=s.getAdditionalInfo().variable.getName(),c=i.get(o).filter(f=>f.getScope().getBlockEntity()!==t.DocumentDefinition);if(c.length>0){s.getAdditionalInfo().localVariables=[];for(const p of c){const w={scope:p.getScope().getBlockEntity().name};p.getScope().getBlockEntity()===t.FunctionDefinition&&(w.functionName=p.getScope().getFunctionName()),s.getAdditionalInfo().localVariables.push(w)}const f=new $([s],`The undefined variable ${s.getAffectedText()} has global scope. The document contains ${c.length} other ${c.length===1?"variable":"variables"} with the same name in function scope.`);n.push(new J(s.getLineNumber(),s.getDocIndex(),f))}}return n},Au=g=>{let i=g.filter(n=>n.getID()===b.ForLoopIteratorModified.name),e=[];for(let n of i){let s="";s=`The for loop iterator variable ${n.getAffectedText()} is modified in the loop.`;const o=new $([n],s);e.push(new J(n.getLineNumber(),n.getDocIndex(),o))}return e},ku=g=>{const i=g.filter(n=>n.getID()===b.OneLineConditional.name);let e=[];for(let n of i){const s=n.toJSON();if(s.form===ii){const o=new $([n],"Conditional returns a boolean literal that matches the value of the boolean expression in the if statement. The whole conditional could be replaced with a single line.");e.push(new J(n.getLineNumber(),n.getDocIndex(),o))}else if(s.form===ri){const o=new $([n],`The variable ${s.variableAssigned} is assigned a boolean literal that matches the value of the boolean expression in the if statement. The whole conditional could be replaced with a single line.`);e.push(new J(n.getLineNumber(),n.getDocIndex(),o))}}return e},Pu=g=>{const i=g.filter(n=>n.getID()===b.TernaryReturnsBool.name);let e=[];for(let n of i){const s=new $([n],"Ternary returns a boolean literal that matches the value of the boolean expression in the ternary. The ternary could be replaced with the boolean expression alone.");e.push(new J(n.getLineNumber(),n.getDocIndex(),s))}return e},Lu=g=>{const i=g.filter(s=>s.getID()===b.UnexpectedColon.name&&s.getAdditionalInfo().after.type===ce&&(s.getAdditionalInfo().before.type===t.FunctionName.name||s.getAdditionalInfo().before.type===pr)),e=g.filter(s=>s.getID()===b.UnknownFunction.name);let n=[];for(let s of i)if(s.getAdditionalInfo().before.type===t.FunctionName.name){let o=e.filter(c=>c.getAffectedText()===s.getAdditionalInfo().before.value);if(o.length>0){const c=new $([s,o[0]],`The unexpected colon is preceded by a call to unknown function, ${o[0].getAffectedText()}. It is possible the intention was to declare a function but the def keyword has been omitted.`);n.push(new J(s.getLineNumber(),s.getDocIndex(),c))}}else if(s.getAdditionalInfo().before.type===pr){const o=new $([s],"The unexpected colon is preceded by a Boolean expression. It is possible the intention was to declare a while, if, or elif but the keyword was omitted.");n.push(new J(s.getLineNumber(),s.getDocIndex(),o))}return n},Vu=g=>{const i=g.filter(s=>s.getID()===b.DefinitionFollowedByReservedWord.name),e=g.filter(s=>s.getID()===b.ReservedWordAssigned.name);let n=[];for(let s of i){const o=new $([s],`The reserved word, ${s.getAdditionalInfo().reservedWord}, follows the ${s.getAdditionalInfo().definitionType}.`);n.push(new J(s.getLineNumber(),s.getDocIndex(),o))}for(let s of e){const o=new $([s],`The reserved word, ${s.getAffectedText()}, is followed by the assignment operator.`);n.push(new J(s.getLineNumber(),s.getDocIndex(),o))}return n},vu=(g,i)=>{const e=g.filter(f=>f.getID()===b.UndefinedVariable.name),n=Array.from(i.values()).flatMap(f=>f).flatMap(f=>f.getUsages()).filter(f=>f.getVariable().getDataType()===d.Function).map(f=>f.getVariable()),s=g.filter(f=>f.getID()===b.SubscriptedNonSubscriptable.name),o=g.filter(f=>f.getID()===b.VariableWithSameNameAsFunction.name&&f.getAdditionalInfo().funcType===zt&&f.getAdditionalInfo().numArgsExpected===0);let c=[];if(o.length===0||e.length===0&&n.length===0)return c;for(let f of o){const p=f.getAffectedText(),w=f.getDocIndex();for(let S of e)if(S.getAffectedText()===p&&S.getDocIndex()===w&&s.filter(N=>N.getAdditionalInfo().varName===p&&N.getDocIndex()===w).length===0){const N=new $([S,f],`The variable ${p} has not been assigned a value and the file contains a user-defined function of the same name, which does not expect any arguments.`);c.push(new J(S.getLineNumber(),S.getDocIndex(),N))}for(let S of n)if(S.getTextValue()===p&&S.getDocumentStartIndex()===w&&s.filter(N=>N.getAdditionalInfo().varName===p&&N.getDocIndex()===w).length===0){const N=new $([f],`The variable ${p} has not been assigned a value and the file contains a user-defined function of the same name, which does not expect any arguments.`);c.push(new J(f.getLineNumber(),f.getDocIndex(),N))}}return c},Ru=g=>{const i=g.filter(o=>o.getID()===b.AssignedNone.name),e=g.filter(o=>o.getID()===b.FunctionPrints.name),n=g.filter(o=>o.getID()===b.UnusedReturn.name&&o.getAdditionalInfo().expression.is(t.FunctionName));let s=[];for(let o of i){const c=o.toJSON();if(c.expressionNoValue.type===zt){const f=c.expressionNoValue.value.split("(")[0],p=e.filter(S=>S.getAffectedText()===f);if(p.length>0){const S=new $([o,...p],`User-defined function ${f} prints to the console but does not return a value.`);s.push(new J(o.getLineNumber(),o.getDocIndex(),S))}else{const S=new $([o],`User-defined function ${f} does not return a value but it is used as if it does.`);s.push(new J(o.getLineNumber(),o.getDocIndex(),S))}}else if(c.expressionNoValue.type===Qt&&c.expressionNoValue.value.indexOf("print(")===0){const f=new $([o],"The print function does not return a value but it is used as if it does.");s.push(new J(o.getLineNumber(),o.getDocIndex(),f))}}for(let o of n){const f=o.toJSON().unusedFunc.value,p=e.filter(S=>S.getAffectedText()===f);if(p.length>0){const S=new $([o,...p],`User-defined function ${f} prints to the console and returns a value but the value is not used.`);s.push(new J(o.getLineNumber(),o.getDocIndex(),S))}}return s},Uu=g=>{const i=g.filter(s=>s.getID()===b.FunctionPrints.name),e=g.filter(s=>s.getID()===b.UnusedReturn.name&&!(s.getAdditionalInfo().expression.is(a.BuiltInMethods)&&br.has(s.getAdditionalInfo().expression.getEntity()))&&!s.getAdditionalInfo().expression.isOneOf([t.StrFunction,t.IntFunction,t.FloatFunction,t.BoolFunction,t.ListFunction,t.TupleFunction,t.SetFunction])),n=[];for(let s of e){const c=s.toJSON().unusedFunc.value;if(!(i.filter(w=>w.getAffectedText()===c).length>0)){const w=new $([s],`The function ${c} returns a value but the value is not used.`);n.push(new J(s.getLineNumber(),s.getDocIndex(),w))}}return n},Eu=g=>{const i=g.filter(n=>n.getID()===b.ReturnInParentheses.name),e=n=>n===hr?"function call":n===fr?"compound type (e.g. list, set)":n===gr?"compound expression":n;return i.map(n=>new J(n.getLineNumber(),n.getDocIndex(),new $([n],`The function returns a ${e(n.getAdditionalInfo().contents)} wrapped in parentheses. The parentheses are unnecessary.`)))},Gu=g=>{const i=g.filter(n=>n.getID()===b.SequentialIfs.name&&n.getAdditionalInfo().branchMatches.length>0);let e=[];for(let n of i)for(let s of n.getAdditionalInfo().branchMatches){let o=s.map(f=>f.lineNum+1).join(", "),c=o.lastIndexOf(",");o=o.substring(0,c)+" and"+o.substring(c+1),s.length>0&&e.push(new J(s[0].lineNum,s[0].docIndex,new $([n],`The if statement is part of a sequence of if statements (lines ${o}) that have very similar boolean expressions.`)))}return e},$u=(g,i,e)=>{const n=new Set(g.filter(c=>c.getID()===b.AssignmentInReturn.name).map(c=>c.getLineNumber())),s=g.filter(c=>c.getID()===b.OverwrittenVariable.name&&c.getAdditionalInfo().isParameter&&c.getAdditionalInfo().prevUsageIsDefinition&&!n.has(c.getLineNumber()));let o=[];for(let c of s){const f=c.getAdditionalInfo().functionBlock;let p="";for(const[S,F]of e.entries())if(F.getBlockId()===f){p=S;break}c.getAdditionalInfo().functionBlock=p;const w=new $([c],`The parameter ${c.getAffectedText()} is overwritten before use.`);o.push(new J(c.getLineNumber(),c.getDocIndex(),w))}return o},Ju=g=>{const i=g.filter(n=>n.getID()===b.UnusedReturn.name&&n.getAdditionalInfo().expression.is(a.BuiltInMethods)&&br.has(n.getAdditionalInfo().expression.getEntity())&&n.getAdditionalInfo().expression.getParent().getObject().getDataType()===d.String);let e=[];for(let n of i){const s=new $([n],`A String method, ${n.getAdditionalInfo().expression.getTextValue()}, that returns a new string is called but the return value is not assigned or passed.`);e.push(new J(n.getLineNumber(),n.getDocIndex(),s))}return e},Ku=g=>{const i=g.filter(n=>n.getID()===b.UnusedReturn.name&&n.getAdditionalInfo().expression.isOneOf([t.StrFunction,t.IntFunction,t.FloatFunction,t.BoolFunction,t.ListFunction,t.TupleFunction,t.SetFunction]));let e=[];for(let n of i){const s=new $([n],`${n.getAdditionalInfo().expression.getTextValue()}() is called but the converted value returned by the function is not saved or passed.`);e.push(new J(n.getLineNumber(),n.getDocIndex(),s))}return e},Wu=g=>{const i=g.filter(s=>s.getID()===b.LoopVarNotModified.name),e=g.filter(s=>s.getID()===b.LoopReturn.name);let n=[];for(const s of e){if(s.getAdditionalInfo().exitTypes.filter(c=>c!=="return").length>0||s.getAdditionalInfo().loopType==="while"&&i.filter(c=>c.getBlock()===s.getBlock()).length>0)continue;const o=new $([s],`A ${s.getAdditionalInfo().loopType} always exits on the first iteration due to return statements. Related to DeferredReturn.`);n.push(new J(s.getLineNumber(),s.getDocIndex(),o))}return n},ju=g=>{const i=g.filter(s=>s.getID()===b.LoopVarNotModified.name),e=g.filter(s=>s.getID()===b.LoopReturn.name);let n=[];for(let s of i){const o=e.filter(c=>c.getBlock()===s.getBlock());if(o.length>0){const c=new $([s,...o],"No while loop variables are modified (excluding modifications in any nested loops) and the loop always exits on the first iteration.");n.push(new J(s.getLineNumber(),s.getDocIndex(),c))}}return n},qu=g=>{const i=g.filter(n=>n.getID()===b.TypeUnnecessary.name);let e=[];for(let n of i){const s=n.toJSON();let o;s.argType===nc&&s.convertedType===sc?o=new $([n],`A string value, ${s.convertedValue}, is converted to a list which may not be necessary. The programmer may not realise that much of the functionality provided by a list is also available to strings.`):o=new $([n],`${s.convertedValue} is guaranteed to be a ${s.argType} so there is no need to convert it to ${s.convertedType}.`),o!==void 0&&e.push(new J(n.getLineNumber(),n.getDocIndex(),o))}return e},Mi=class Mi{constructor(i,e){I(this,Bn);I(this,Fs);I(this,$t);y(this,Bn,i.name),y(this,Fs,i.description),y(this,$t,e)}addOccurrence(i){u(this,$t).push(i)}getName(){return u(this,Bn)}isPresentInToken(i,e){for(const n of u(this,$t))for(const s of n.getReason().getContributingSymptoms())if(i<=s.getDocIndex()&&e>=s.getDocIndex())return!0;return!1}toJSON(){return{type:u(this,Bn),description:u(this,Fs),occurrences:u(this,$t).map(i=>i.toJSON())}}static create(i,e){return new Mi(i,e)}};Bn=new WeakMap,Fs=new WeakMap,$t=new WeakMap;let bi=Mi;class J{constructor(i,e,n){I(this,An);I(this,kn);I(this,Pn);y(this,An,i),y(this,kn,e),y(this,Pn,n)}getLineNumber(){return u(this,An)}getDocIndex(){return u(this,kn)}getReason(){return u(this,Pn)}toJSON(){return{line:u(this,An),docIndex:u(this,kn),reason:u(this,Pn).toJSON()}}}An=new WeakMap,kn=new WeakMap,Pn=new WeakMap;class ${constructor(i,e){I(this,Ln);I(this,Ts);y(this,Ln,i),y(this,Ts,e)}getContributingSymptoms(){return u(this,Ln)}toJSON(){return{contributingSymptoms:u(this,Ln).map(i=>i.toJSON()),explanation:u(this,Ts)}}}Ln=new WeakMap,Ts=new WeakMap;const Hu=new Map([[L.PrintSameAsReturn,Ru],[L.UnusedReturn,Uu],[L.MapToBooleanWithIf,ku],[L.ComparisonWithBoolLiteral,Tu],[L.DeferredReturn,Nu],[L.TypeMustBeSpecified,qu],[L.CompareMultipleValuesWithOr,Fu],[L.ParenthesesOnlyIfArgument,vu],[L.FunctionCallsUseSquareBrackets,Ou],[L.FunctionCallsNoParentheses,Mu],[L.AssignCompares,bu],[L.ReturnCall,Eu],[L.SequentialIfsAreExclusive,Gu],[L.WhileSameAsIf,ju],[L.IterationRequiresTwoLoops,Du],[L.StringMethodsModifyTheString,Ju],[L.TypeConversionModifiesArgument,Ku],[L.MapToBooleanWithTernaryOperator,Pu],[L.NoReservedWords,Vu],[L.ParameterMustBeAssignedInFunction,$u],[L.LocalVariablesAreGlobal,Bu],[L.IteratorInitialisedOutsideLoop,xu],[L.ForLoopVarIsLocal,Cu],[L.LoopCounter,Au],[L.NoKeyword,Lu],[L.ColonAssigns,yu],[L.ReturnWaitsForLoop,Wu]]);class Rr{constructor(i){I(this,_s);I(this,Jt);I(this,Ke);I(this,Ft);I(this,Ns);I(this,Kt);I(this,Wt);I(this,Vn);y(this,Jt,i.getTextValue()),y(this,Ke,i.getCategory()),y(this,Ft,i.getEntity()),y(this,Kt,i.getDocumentStartIndex()),y(this,Wt,i.getDocumentEndIndex()),y(this,Ns,i.getConnectedTo()),y(this,Vn,new Set)}getText(){return u(this,Jt)}getEntity(){return u(this,Ft)}getCategory(){return u(this,Ke)}getConnectedTo(){return u(this,Ns)}addMisconception(i){u(this,Vn).add(i)}getID(){let i=`${u(this,Ft).name}_${u(this,Ke).name} ${u(this,Jt)}`;return m(this,_s,Pl).call(this)?i:`${u(this,Kt)}_${u(this,Wt)}_${i}`}getStartIndex(){return u(this,Kt)}getEndIndex(){return u(this,Wt)}toJSON(){return{id:this.getID(),text:u(this,Jt),entity:u(this,Ft).name,category:u(this,Ke).name,startDocIndex:u(this,Kt),endDocIndex:u(this,Wt),misconceptions:Array.from(u(this,Vn))}}}Jt=new WeakMap,Ke=new WeakMap,Ft=new WeakMap,Ns=new WeakMap,Kt=new WeakMap,Wt=new WeakMap,Vn=new WeakMap,_s=new WeakSet,Pl=function(){return u(this,Ft)===t.FunctionName&&u(this,Ke)===a.Identifiers||u(this,Ke)===a.BuiltInFunctions||u(this,Ke)===a.BuiltInMethods||u(this,Ke)===a.BuiltInModules||u(this,Ke)===a.BuiltInExceptions};class zu{constructor(i,e){I(this,He);I(this,Tt,new Map);I(this,vn,new Map);const n=Array.from(e.values());for(const s of i)m(this,He,Ll).call(this,n,s),m(this,He,lr).call(this,s);m(this,He,Vl).call(this)}toJSON(){const i={nodes:{},edges:{}};for(const[e,n]of u(this,Tt))i.nodes[e]=n.toJSON();for(const[e,n]of u(this,vn))i.edges[e]=Array.from(n);return i}}Tt=new WeakMap,vn=new WeakMap,He=new WeakSet,Ll=function(i,e){const n=i.filter(s=>s.isPresentInToken(e.getStartIndex(),e.getEndIndex()));for(const s of n)e.addMisconception(s.getName())},lr=function(i){const e=i.getID();u(this,Tt).has(e)||(u(this,Tt).set(e,i),u(this,vn).set(e,new Set))},Vl=function(){for(const[i,e]of u(this,Tt)){const n=e.getConnectedTo();for(const s of n){const o=new Rr(s);u(this,Tt).has(o.getID())||m(this,He,lr).call(this,o),i!==o.getID()&&m(this,He,vl).call(this,i,o.getID())}}},vl=function(i,e){u(this,vn).get(i).add(e)};class Qu{constructor(i){I(this,v);I(this,Cs);I(this,De,[]);I(this,ye);l(this,"variables");l(this,"userDefinedFunctions");l(this,"userDefinedClasses");l(this,"modules");y(this,Cs,i),y(this,ye,new $n),this.variables=new Map,this.modules=new Map,O.symptoms=[];try{m(this,v,Rl).call(this,i)}catch(e){const n=`Unable to process ${i} due to error: ${e.stack}`;throw new Error(n)}}getUserDefinedFunctions(){return this.userDefinedFunctions}getUserDefinedClasses(){return this.userDefinedClasses}getVariables(){return this.variables}getSymptoms(){return O.symptoms}getMisconceptions(){return Iu(O.symptoms,this.variables,this.getUserDefinedFunctions())}getText(){return u(this,Cs)}getBlocks(){return u(this,ye)}getGraph(){let i=[];for(const n of u(this,De))for(const s of n.getExpressions()){let o=s.getAllNestedExpressions();try{i.push(...o.map(c=>new Rr(c)))}catch(c){console.log("Unable to get graph nodes:",c)}}return new zu(i,this.getMisconceptions())}}Cs=new WeakMap,De=new WeakMap,ye=new WeakMap,v=new WeakSet,Rl=function(i){y(this,De,[]);let e=u(this,ye);const n=i.split(/\r?\n/),s=[...i.matchAll(/\r?\n/g)].map(o=>o[0]);if(n.length>0){let o=new Jn(n[0],0,0);u(this,De).push(Ot.createFromSource(o)),o.continuesOnNextLine()||(e=m(this,v,ur).call(this,u(this,De)[u(this,De).length-1],e));for(let c=1;c<n.length;c++){const f=e.isScopeBlock()?m(this,v,cr).call(this,e):m(this,v,cr).call(this,e.getScope()),p=Array.from(e.getScope().findAllModules().keys()),w={varsWithTypeNames:f,moduleNames:p,classDefinitionInProgress:e.hasParentOfEntity(t.ClassDefinition)},S=o.getDocumentStartIndex()+o.getText().length+s[c-1].length;if(o.continuesOnNextLine())w.groupCharCounts=o.getOpenGroupChars(),w.lastLineExpressions=o.getExpressions(),o.hasOpenComment()&&(w.multilineCommentDelimiter=o.getCommentDelimiter()),o.hasOpenString()&&(w.stringLiteralDelimiter=o.getStringLiteralDelimiter()),o=new Jn(n[c],c,S,w),u(this,De)[u(this,De).length-1].continueFromSource(o);else if(o.followedBySeparateStatement()){c--;const F=o.getLineEndIndex()+1;w.startFrom=F,o=new Jn(n[c],c,o.getDocumentStartIndex(),w),u(this,De).push(Ot.createFromSource(o,e.getBlockEntity()===t.ClassDefinition))}else o=new Jn(n[c],c,S,w),u(this,De).push(Ot.createFromSource(o,e.getBlockEntity()===t.ClassDefinition));o.continuesOnNextLine()||(e=m(this,v,ur).call(this,u(this,De)[u(this,De).length-1],e))}}m(this,v,El).call(this),m(this,v,Gl).call(this),m(this,v,Ul).call(this)},Ht=function(){return[u(this,ye)].concat(u(this,ye).getChildBlocksOfKind(t.FunctionDefinition)).concat(u(this,ye).getChildBlocksOfKind(t.ClassDefinition)).concat(u(this,ye).getChildBlocksOfKind(t.ListComprehension))},Ul=function(){const i=m(this,v,Ht).call(this);for(const e of i)for(const n of e.getStatements()){for(const s of n.getExpressions())s.checkForSymptoms(),s.checkForConstructs(s);n.isBlockStatement()&&n.checkRules(n)}for(const e of this.variables.values())for(const n of e)n.checkRules(n);for(const e of this.userDefinedFunctions.values()){const n=e.getParent();if(n!==void 0&&n.is(t.FunctionDefinitionStatement)){const s=n.getParameters().length-n.getOptionalParameterCount(),o=n.getParameters().length,c=Array.from(e.getObservers()).filter(f=>f.is(t.UserDefinedFunctionCall));for(const f of c){const p=f.getArguments();(p.length<s||p.length>o)&&O.symptoms.push(O.createStatementSymptom(b.WrongArgNumber,[f],0,0,{expectedMinArgs:s,expectedMaxArgs:o,receivedArgs:p.length}))}}}u(this,ye).checkRules(u(this,ye))},El=function(){const i=new Map,e=m(this,v,Ht).call(this);for(const n of e){const s=n.getVariableMap(),o=n.getUserDefinedFunctions();for(const[c,f]of s){let p=!1;const w=f.getUsages()[0].getVariable();w.getDataType()===d.NotParsed&&!w.isAssignedOrChanged()&&!w.isParameter()&&(K.checkIfVariableExistsInParent(f,n)?p=!0:o.has(c)?w.setDataType(d.Function):(f.getUsages()[0].getVariable().setDataType(d.Undefined),f.checkAndAdjustUndefined())),i.has(c)||i.set(c,[]),p||i.get(c).push(f)}}this.variables=i},Gl=function(){this.userDefinedFunctions=m(this,v,Wl).call(this),this.userDefinedClasses=u(this,ye).getUserDefinedClasses();const i=u(this,ye).getChildBlocksOfKind(t.FunctionDefinition);for(const n of i){let s=n.getLastExecutedStatements();const o=n.alwaysReturnsAValue();if(o&&(s=s.filter(c=>c.getFirstExpression().is(t.ReturnStatement))),n.getParentBlock().getBlockEntity()!==t.ClassDefinition)this.userDefinedFunctions.has(n.getFunctionName())&&this.userDefinedFunctions.get(n.getFunctionName()).is(t.FunctionName)&&this.userDefinedFunctions.get(n.getFunctionName()).addReturns(s,!o);else{const c=n.getParentBlock().getClassType().name;if(this.userDefinedClasses.has(c)){const f=this.userDefinedClasses.get(c).methods;f.has(n.getFunctionName())&&f.get(n.getFunctionName()).addReturns(s,!o)}}}m(this,v,jl).call(this);const e=m(this,v,Jl).call(this);m(this,v,Kl).call(this,e),m(this,v,$l).call(this),m(this,v,ql).call(this)},$l=function(){const i=this.userDefinedFunctions.keys(),e=Array.from(i).filter(n=>this.variables.has(n));for(const n of e){const s=this.userDefinedFunctions.get(n).getParent();if(s!==void 0){for(const o of this.variables.get(n))if(o.getUsages().length>0){const c=o.getUsages()[0].getVariable();O.symptoms.push(O.createStatementSymptom(b.VariableWithSameNameAsFunction,[c],0,0,{funcType:zt,numArgsExpected:s.getParameters().length-s.getOptionalParameterCount(),varIsParameter:c.isParameter()}))}}}},Jl=function(){const i=this.userDefinedFunctions.keys(),e=[];for(const n of i)We(n).category===a.BuiltInFunctions&&e.push(n);return e},Kl=function(i){if(i.length>0){const e=m(this,v,Ht).call(this);for(const n of e){const s=n.getStatements();for(const o of s){const f=o.getExpressions().flatMap(p=>p.getExpressionsOfKind(t.BuiltInFunctionCall)).filter(p=>i.includes(p.getFunctionName()));for(const p of f)i.includes(p.getFunctionName())&&p.convertToUserDefinedFunction(this.userDefinedFunctions.get(p.getFunctionName()))}}}},Wl=function(){const i=new Map;let e=m(this,v,Ht).call(this);for(const n of e){const s=n.getUserDefinedFunctions();for(const[o,c]of s)i.set(o,c)}return i},jl=function(){const i=m(this,v,Ht).call(this);for(const e of i){const n=e.getUnconnectedFunctionCalls();for(let s of n)for(let o of s[1])if(this.userDefinedFunctions.has(s[0])){const c=this.userDefinedFunctions.get(s[0]);c.addObserver(o),o.setDataType(c.getReturnType())}else m(this,v,Hl).call(this,s[0],e)?o.convertToImportedFunction():(o.setDataType(d.Unknown),O.symptoms.push(O.createStatementSymptom(b.UnknownFunction,[o],0,0)))}},ql=function(){const i=m(this,v,Ht).call(this);for(const e of i){const n=e.getUnconnectedMethodCalls();for(let s of n)for(let o of s[1]){const c=o.getObject();let f;if(c.getDataType().isCustom)c.getDataType().methods.has(s[0])&&(f=c.getDataType().methods.get(s[0]));else for(const p of this.userDefinedClasses.values())if(p.methods.has(s[0])){f=p.methods.get(s[0]);break}f&&(f.addObserver(o),o.setDataType(f.getReturnType()))}}},Hl=function(i,e){let n=e;for(;n!==void 0;){if(n.getModuleMap().has(i)||Array.from(n.getModuleMap().values()).filter(s=>s.hasDirectImport(i)).length>0)return!0;n=n.getParentBlock()!==void 0?n.getParentBlock().getScope():void 0}return!1},cr=function(i){const e=new Set(["int","float","bool","str","list","set","dict"]);let n=Array.from(i.getVariableMap().keys()).filter(o=>e.has(o)),s=i;for(;s.getBlockEntity()!==t.DocumentDefinition;)s=s.getParentBlock().getScope(),n=n.concat(Array.from(s.getVariableMap().keys()).filter(o=>e.has(o)));return n},ur=function(i,e){if(!i.isBlank()){const n=i.getFirstExpression(),s=i.getIndentation(),o=n.getStartLineNumber();let c;const f=m(this,v,Xl).call(this,i);e.isScopeBlock()||(c=e.getScope().getStatementToUpdate(s,o)),n.isOneOf([t.FunctionDefinitionStatement,t.MethodDefinitionStatement])?(e=m(this,v,Yl).call(this,e,i,s),n.is(t.MethodDefinitionStatement)&&m(this,v,Ql).call(this,e,n)):n.is(t.ClassDefinitionStatement)?e=m(this,v,_l).call(this,e,i,s):n.is(a.BlockDefinitionStatement)&&!n.is(t.TernaryStatement)?e=m(this,v,Zl).call(this,e,i,s,c):c!==void 0?(e=m(this,v,Un).call(this,s,e,o),c.addStatement(i,e)):(e=m(this,v,Un).call(this,s,e,o),e.addStatement(i)),f.length>0&&m(this,v,zl).call(this,f,e)}return e},zl=function(i,e){for(let n of i){const s=new zc(e,n);e.addChildBlock(s)}},Ql=function(i,e){const n=i.getParentBlock();if(n&&n.getBlockEntity()===t.ClassDefinition){const s=n.getClassType(),o=e.getMethodNameExpression();o.setContainingClass(s),s.methods.set(o.getTextValue(),o)}},Xl=function(i){const e=i.getExpressions();let n=[];for(const s of e){const o=s.getExpressionsOfKind(t.ListComprehension);for(const c of o)n.push(c.copyAndConvertToPlaceholder())}return n},Zl=function(i,e,n,s){const o=new Su(e,i.getScope().getId()),c=new Mr(i,o),f=m(this,v,Un).call(this,n,i,e.getFirstLineNumber()),p=o.getFirstExpression().isOneOf([t.ElifDefinitionStatement,t.ElseDefinitionStatement]),w=o.getFirstExpression().is(t.ExceptDefinitionStatement);if(o.isBlockStatement()&&(p||w)){const S=s?s.getStatements():f.getStatements(),F=S[S.length-1],N=p?[t.IfDefinitionStatement,t.ElifDefinitionStatement,t.ElseDefinitionStatement]:[t.TryDefinitionStatement];if(F!==void 0&&F.isBlockStatement()&&F.getFirstExpression().isOneOf(N)){const R=f.getChildBlocks(),k=R[R.length-1],M=k.getBlockEntity();if(p&&(M===t.IfDefinition||M===t.ElifDefinition)||w&&M===t.TryDefinition){const jt=k.getSiblingConditionalBranches();for(const Er of jt)c.addSibling(Er),Er.addSibling(c);k.addSibling(c),c.addSibling(k)}}}return f.addChildBlock(c),s?s.addStatement(o,c):f.addStatement(o),c},Yl=function(i,e,n){i=m(this,v,Un).call(this,n,i,e.getFirstLineNumber());const s=new di(i,e);return i.addChildBlock(s),s},_l=function(i,e,n){i=m(this,v,Un).call(this,n,i,e.getFirstLineNumber());const s=new Hc(i,e);return i.addChildBlock(s),s},Un=function(i,e,n){let s=e.getIndentation();const o=e.getStatements();if(o.length>0&&o[o.length-1].getLastLineNumber()===n)return e;for(;e.getBlockEntity()!==t.DocumentDefinition&&i<=s;){let c=e.getParentBlock();e=c!==void 0?c:u(this,ye),s=e.getIndentation()}return e};class Q{constructor(i,e,n,s,o){l(this,"type");l(this,"docIndex");l(this,"affectedText");l(this,"firstMessage");l(this,"extendedFeedbackParams");for(this.type=i,this.docIndex=e,this.affectedText=n,this.firstMessage=s,this.extendedFeedbackParams=o;this.extendedFeedbackParams.includes("+");)this.extendedFeedbackParams=this.extendedFeedbackParams.replace("+","%2B");this.extendedFeedbackParams=encodeURI(this.extendedFeedbackParams)}static notImplemented(){return new Q("Invalid",-1,"N/A","No feedback","")}toJSON(){return{type:this.type,docIndex:this.docIndex,affectedText:this.affectedText,firstMessage:this.firstMessage,extendedFeedbackParams:this.extendedFeedbackParams}}}const Xu=g=>g.hasOwnProperty("reason")&&g.reason.hasOwnProperty("contributingSymptoms")&&g.reason.contributingSymptoms.length>0,lt=(g,i)=>g.type===i,Zu=g=>{const i=[];try{for(const e of g.occurrences)if(Xu(e))switch(g.type){case L.AssignCompares.name:i.push(Yu(g.type,e));break;case L.ColonAssigns.name:i.push(_u(g.type,e));break;case L.CompareMultipleValuesWithOr.name:i.push(ed(g.type,e));break;case L.ComparisonWithBoolLiteral.name:i.push(td(g.type,e));break;case L.DeferredReturn.name:i.push(sd(g.type,e));break;case L.ForLoopVarIsLocal.name:case L.IteratorInitialisedOutsideLoop.name:i.push(id(g.type,e));break;case L.FunctionCallsNoParentheses.name:case L.ParenthesesOnlyIfArgument.name:i.push(od(g.type,e));break;case L.IterationRequiresTwoLoops.name:i.push(ad(g.type,e));break;case L.LocalVariablesAreGlobal.name:i.push(ld(g.type,e));break;case L.LoopCounter.name:i.push(rd(g.type,e));break;case L.MapToBooleanWithIf.name:i.push(cd(g.type,e));break;case L.MapToBooleanWithTernaryOperator.name:i.push(ud(g.type,e));break;case L.ParameterMustBeAssignedInFunction.name:i.push(dd(g.type,e));break;case L.PrintSameAsReturn.name:i.push(hd(g.type,e));break;case L.ReturnCall.name:i.push(fd(g.type,e));break;case L.ReturnWaitsForLoop.name:i.push(Sd(g.type,e));break;case L.SequentialIfsAreExclusive.name:i.push(nd(g.type,e));break;case L.StringMethodsModifyTheString.name:i.push(gd(g.type,e));break;case L.TypeConversionModifiesArgument.name:i.push(pd(g.type,e));break;case L.TypeMustBeSpecified.name:i.push(md(g.type,e));break;case L.UnusedReturn.name:i.push(wd(g.type,e));break;case L.WhileSameAsIf.name:i.push(Id(g.type,e));break;default:console.log("Not implemented!",g.type)}}catch(e){console.log(e)}return i},ie=(g,i)=>`?miscon=${g}&lineNumber=${i.line+1}`,Yu=(g,i)=>{const e=i.reason.contributingSymptoms[0],n=i.docIndex,s=e.text,o="Should this = be == ?",c=`${ie(g,i)}&text=${s}&parentText=${e.parentText}`;return new Q(g,n,s,o,c)},_u=(g,i)=>{const e=i.reason.contributingSymptoms[0],n=i.docIndex,s=e.text,o="Should this : be = ?",c=`${ie(g,i)}&text=${s}&variableName=${e.before.value}&assignedValue=${e.after.value}`;return new Q(g,n,s,o,c)},ed=(g,i)=>{const e="NA",n=i.docIndex,s=i.reason.contributingSymptoms[0].text?i.reason.contributingSymptoms[0].text:e,o=i.reason.contributingSymptoms[0].completeBooleanExpression?`${i.reason.contributingSymptoms[0].completeBooleanExpression} will always be True`:"This boolean expression will always be True";let c=e,f=e,p=e;const w=[],S=[],F=[],N=[],R=[];for(const M of i.reason.contributingSymptoms)lt(M,b.NaturalLanguageBoolean.name)&&(M.completeBooleanExpression&&(c=M.completeBooleanExpression),M.parentText&&(f=M.parentText),M.parentEntity&&(p=M.parentEntity),M.rightSideEntity&&(M.rightSideEntity===t.ComparisonExpression.name&&(w.length===0||w[0]!==M.rightSideText)?w.unshift(M.rightSideText):M.rightSideEntity!==t.BooleanExpression.name&&(S.length===0||S[0]!==M.rightSideText)&&(S.unshift(M.rightSideText),N.unshift(M.rightSideEntity),F.unshift(M.rightSideType))),M.leftSideEntity&&(M.leftSideEntity===t.ComparisonExpression.name?w.unshift(M.leftSideText):M.leftSideEntity!==t.BooleanExpression.name&&(S.unshift(M.leftSideText),N.unshift(M.leftSideEntity),F.unshift(M.leftSideType))),R.unshift(M.operator));const k=`${ie(g,i)}&booleanExpressionText=${c}&parentText=${f}&parentEntity=${p}&${w.map(M=>"comparisonText="+M).join("&")}&${S.map(M=>"otherText="+M).join("&")}&${N.map(M=>"otherEntity="+M).join("&")}&${F.map(M=>"otherType="+M).join("&")}&${R.map(M=>"operator="+M).join("&")}}`;return new Q(g,n,s,o,k)},td=(g,i)=>{const e=i.reason.contributingSymptoms[0],n=i.docIndex,s=e.text,o=e.boolValue,c=e.boolLiteral,f=c==="True"?`${o} is boolean so == True is not needed`:`${s} is the same as not ${o}`,p=`${ie(g,i)}&text=${s}&boolValue=${o}&boolLiteral=${c}`;return new Q(g,n,s,f,p)},nd=(g,i)=>{const e=i.docIndex;let n=i.reason.contributingSymptoms[0].text;const s=new Set;for(const p of i.reason.contributingSymptoms){if(!lt(p,b.SequentialIfs.name))continue;const w=p.branchMatches.flat();w.forEach(M=>{s.add(M.lineNum+1)});const S=w[0].docIndex-p.docIndex,F=S,N=w[w.length-1].docIndex-w[0].docIndex+S,R=n.substring(N).indexOf(`
`),k=R>-1?N+R:n.length;n=n.substring(F,k)}const c=`Should this sequence of if statements be if${Array(s.size-1).fill("-elif").join("")} instead?`,f=`${ie(g,i)}&fullText=${n}&${[...s].map(p=>"statementLine="+p).join("&")}`;return new Q(g,e,n,c,f)},sd=(g,i)=>{for(const e of i.reason.contributingSymptoms)if(lt(e,b.UnreachableExit.name)&&e.exitKeyword==="return"){const n=e.docIndex,s=e.text,o="This code will never execute",c=`${ie(g,i)}&exitKeyword=${e.exitKeyword}`;return new Q(g,n,s,o,c)}return Q.notImplemented()},id=(g,i)=>{const e=i.reason.contributingSymptoms[0],n=e.text,s=e.usageText,o=e.overwrittenVar[e.overwrittenVar.length-1].lineNum+1,c=e.prevUsageIsDefinition,f=c?`${n} does not need to be defined if it is only used in the for loop on line ${e.line+1}`:`This for loop changes the value of an existing variable, ${n}`,p=c?e.overwrittenVar[0].docIndex:i.docIndex,w=`${ie(g,i)}&loopVariable=${n}&forDefinition=${s}&overwrittenVarLine=${o}&overwrittenIsDefinition=${c}`;return new Q(g,p,n,f,w)},rd=(g,i)=>{const e=i.docIndex,n=i.reason.contributingSymptoms[0],s=n.text,o=`This value of ${s} will be ignored by the next loop iteration`,c=`${ie(g,i)}&loopVarName=${s}&definitionText=${n.definitionText}&loopVarTypeAtDefinition=${n.loopVarTypeAtDefinition}&modificationText=${n.modificationText}`;return new Q(g,e,s,o,c)},od=(g,i)=>{let e=i.docIndex,n=`${ie(g,i)}`,s="";const o=i.reason.contributingSymptoms;if(o.length===2){const f=lt(o[0],b.UndefinedVariable.name)?o[0]:o[1],p=lt(o[1],b.VariableWithSameNameAsFunction.name)?o[1]:o[0];lt(f,b.UndefinedVariable.name)&&lt(p,b.VariableWithSameNameAsFunction.name)&&(s=p.text,e=f.docIndex,n=`${n}&funcName=${s}&funcType=${p.funcType}&funcExpectedArgs=${p.numArgsExpected}&matchesUndefinedVarOnLine=${f.line+1}`)}else o.length===1&&lt(o[0],b.VariableWithSameNameAsFunction.name)&&(s=o[0].text,e=o[0].docIndex,n=`${n}&funcName=${s}&funcType=${o[0].funcType}&funcExpectedArgs=${o[0].numArgsExpected}`);const c=`Did you forget () after ${s}?`;return new Q(g,e,s,c,n)},ad=(g,i)=>{const e="This while loop might not be needed",n=i.reason.contributingSymptoms,s=n[0].type===b.LoopVarNotModified.name?n[0]:n[1],o=n[0].type===b.LoopVarModifiedInChildLoop.name?n[0]:n[1],c=s.text,f=s.docIndex,p=`${ie(g,i)}&outerLoopText=${c}&outerLoopVariable=${o.text}${o.modifiedIn.map(w=>`&modifiedInType=${w.loopType}&modifiedInStartLine=${w.startLine+1}`)}`;return new Q(g,f,c,e,p)},ld=(g,i)=>{const e=i.reason.contributingSymptoms[0],n=i.docIndex,s=e.text,o=`${s} is undefined`;let c=`${ie(g,i)}&text=${s}`;return e.hasOwnProperty("localVariables")&&(c=`${c}${e.localVariables.map(f=>`&localScope=${f.scope}${f.hasOwnProperty("functionName")?"&localFunction="+f.functionName:"&localFunction=NA"}`).join()}`),new Q(g,n,s,o,c)},cd=(g,i)=>{const e=i.reason.contributingSymptoms[0],n=i.docIndex,s=e.text,o="This conditional could be shortened to one line";let c=`${ie(g,i)}&text=${e.text}&form=${e.form}`;return e.form==="valueAssigned"&&(c=`${c}&variableAssigned=${e.variableAssigned}`),e.condition&&e.condition.length>0&&(c=`${c}&condition=${e.condition}`),new Q(g,n,s,o,c)},ud=(g,i)=>{const e=i.reason.contributingSymptoms[0],n=i.docIndex,s=e.text,o="This ternary is not needed",c=`${ie(g,i)}&text=${e.text}&boolExp=${e.boolValue}&valueIfTrue=${e.boolLiteralIfTrue}&valueIfFalse=${e.boolLiteralIfFalse}&parentText=${e.parentText}&parentEntity=${e.parentEntity}`;return new Q(g,n,s,o,c)},dd=(g,i)=>{const e=i.reason.contributingSymptoms[0],n=i.docIndex,s=e.text,o="This statement replaces the value of an argument passed to the function";let c=`${ie(g,i)}&paramName=${s}`;return e.functionBlock!==""&&(c=`${c}&functionName=${e.functionBlock}`),new Q(g,n,s,o,c)},hd=(g,i)=>{const e=i.reason.contributingSymptoms.filter(o=>o.type===b.AssignedNone.name),n=i.reason.contributingSymptoms.filter(o=>b.UnusedReturn);let s=`${ie(g,i)}`;if(e.length>0){const o=e[0],c=o.docIndex,f=o.expressionNoValue.value,p=`${o.expressionNoValue.value} has no value`;if(s=`${s}&variant=AssignedNoReturn&expressionNoValueType=${o.expressionNoValue.type}&expressionNoValueUsage=${o.usage}&expressionNoValueText=${o.expressionNoValue.value}&expressionNoValueTarget=${o.target}`,o.expressionNoValue.type==="userDefinedFunction"){const w=i.reason.contributingSymptoms.filter(F=>F.type===b.FunctionPrints.name),S=w.length===1?w[0]:void 0;S&&S.printLines.filter(N=>N.isEndOfExitBranch).length>0&&!S.functionReturns&&(s=`${s}&isFuncPrintNoReturn=true`)}return new Q(g,c,f,p,s)}else if(n.length>0){const o=n[0],c=o.docIndex,f=o.unusedFunc.value,p=`The value returned by ${f}() is not used`;if(s=`${s}&variant=UnusedReturn&expressionUnusedType=${o.unusedFunc.type}&expressionUnusedText=${o.unusedFunc.value}`,o.unusedFunc.type==="userDefinedFunction"){const w=i.reason.contributingSymptoms.filter(F=>F.type===b.FunctionPrints.name),S=w.length===1?w[0]:void 0;S&&S.text===o.unusedFunc.value&&(s=`${s}&isFuncPrintsAndReturns=true`)}return new Q(g,c,f,p,s)}return Q.notImplemented()},fd=(g,i)=>{const e=i.reason.contributingSymptoms[0],n=i.docIndex,s=e.text,o=`The () around ${e.textInParentheses} are not needed`,c=`${ie(g,i)}&text=${s}&returnValueType=${e.contents}&returnValueText=${e.textInParentheses}`;return new Q(g,n,s,o,c)},gd=(g,i)=>{const e=i.reason.contributingSymptoms[0],n=i.docIndex,s=e.text,o=e.unusedFunc.value,c=e.unusedFunc.returnType,f=new RegExp("[ ]*.[ ]*"+o),p=s.split(f)[0],w=`${o}() will not change ${p}`,S=`${ie(g,i)}&text=${s}&unusedMethod=${o}&unusedReturnType=${c}&stringValue=${p}`;return new Q(g,n,s,w,S)},pd=(g,i)=>{const e=i.reason.contributingSymptoms[0],n=i.docIndex,s=e.text,o=e.unusedFunc.value,c=e.unusedFunc.returnType,f=s.substring(s.indexOf("(")+1,s.lastIndexOf(")")),p=`${o}() will not change ${f}`,w=`${ie(g,i)}&text=${s}&typeFunction=${o}&returnType=${c}&argument=${f}`;return new Q(g,n,s,p,w)},md=(g,i)=>{const e=i.reason.contributingSymptoms[0],n=i.docIndex,s=e.text,o="This type conversion is not needed",c=`${ie(g,i)}&text=${s}&argType=${e.argType}&convertedType=${e.convertedType}&convertedValue=${e.convertedValue}`;return new Q(g,n,s,o,c)},wd=(g,i)=>{const e=i.reason.contributingSymptoms[0],n=i.docIndex,s=e.text,o=e.unusedFunc.returnType,c=o!==d.Unknown.name&&o!==d.Invalid.name&&o!==d.NA.name&&o!==d.NotParsed.name,f=c?`The ${o} returned by ${s} is not used`:`The value returned by ${s} is not used`,p=`${ie(g,i)}&expressionUnusedType=${e.unusedFunc.type}&expressionUnusedText=${e.unusedFunc.value}${c?"&returnType="+o:""}`;return new Q(g,n,s,f,p)},Sd=(g,i)=>{const e=i.docIndex,n=i.reason.contributingSymptoms[0],s=n.text,o=n.loopType,c=n.exitTypes.length,f=n.exitLevel,p=`This ${o} loop always ends the first time it runs because of where return is used`,w=`${ie(g,i)}&text=${s}&loopType=${o}&returnCount=${c}&exitLevel=${f}`;return new Q(g,e,s,p,w)},Id=(g,i)=>{const e=i.docIndex,n=i.reason.contributingSymptoms,s=n.filter(f=>f.type===b.LoopReturn.name),o=n.filter(f=>f.type===b.LoopVarNotModified.name),c=ie(g,i);if(o.length===1){const f=o[0].text,p="Could this while loop be an if statement?",w=`${c}&variant=${o[0].type}&definitionText=${f}&loopText=${o[0].loopText}${o[0].unmodifiedVars.map(S=>`&loopVar=${S}`)}${s.map(S=>`&earlyExitLine=${S.line+1}&earlyExitText=${S.text}`)}`;return new Q(g,e,f,p,w)}return Q.notImplemented()},bd=(g,i)=>g.getLineNumber()===i.getLineNumber()&&g.getID()===i.getID()?0:g.getLineNumber()<i.getLineNumber()||g.getLineNumber()===i.getLineNumber()&&g.getID()<i.getID()?-1:1,Ur=(g,i=!1,e=!1,n=!1)=>{const s=[];try{s.push("Sending to DocInfo");let o=new Qu(g);s.push("Getting symptom information");const c=o.getSymptoms().sort(bd).map(R=>{try{return R.toJSON()}catch(k){return{error:"Could not process symptom",msg:k.toString()}}});s.push("Getting variable information");const f=Array.from(o.getVariables().values()).flat().map(R=>{try{return R.toJSON()}catch(k){return{error:"Could not process variable",msg:k.toString()}}});s.push("Getting function information");const p=Array.from(o.getUserDefinedFunctions().values()).filter(R=>R.is(t.FunctionName)).map(R=>{try{return R.toJSON()}catch(k){return{error:"Could not process function",msg:k.toString()}}});s.push("Getting class information");const w=Array.from(o.getUserDefinedClasses().values()).map(R=>R.toJSON());s.push("Getting misconception information");const S=Array.from(o.getMisconceptions().values()).map(R=>{try{return R.toJSON()}catch(k){return{error:"Could not process misconception",msg:k.toString()}}});s.push("Getting block information");const F=o.getBlocks(),N={misconceptions:S,symptoms:c,blocks:F.toJSON(),variables:f,functions:p,classes:w};if(i){const R=F.toTree();N.tree=R}if(e){const R=o.getGraph();N.graph=R.toJSON()}return N}catch(o){console.log("Unable to parse",o);const c={misconceptions:[],symptoms:[],blocks:[],variables:[],functions:[],classes:[],error:`Unable to parse! ${o.toString()}`};return s.push(o.toString()),n&&(c.errorDetail=s.join(`
`)),c}},yd=()=>{let g={};for(let i in b)g[b[i].name]=b[i].description;return g},Fd=()=>{let g={};for(let i in L)g[L[i].name]=L[i].description;return g},Td=(g,i=!1)=>{const e=Ur(g),n={};if(i&&(n.parse=e),n.feedback=[],e.hasOwnProperty("misconceptions"))for(const s of e.misconceptions)s.hasOwnProperty("type")&&n.feedback.push(...Zu(s).map(o=>o.toJSON()));return n};E.feedback=Td,E.misconceptionInfo=Fd,E.parse=Ur,E.symptomInfo=yd,Object.defineProperty(E,Symbol.toStringTag,{value:"Module"})});
